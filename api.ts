/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://integration.knetikcloud.com/".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AchievementDefinitionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this resource type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The description of the achievement. Must be at least 2 characters in length.
     */
    "description"?: string;
    /**
     * Whether the achievement is hidden from the user
     */
    "hidden": boolean;
    /**
     * The name of the achievement. Must be at least 6 characters in length. IMMUTABLE
     */
    "name": string;
    /**
     * The required progress for the achievement definition
     */
    "requiredProgress": number;
    /**
     * The id of the rule generated for this achievement
     */
    "ruleId"?: string;
    /**
     * The tags for the achievement definition
     */
    "tags"?: Array<string>;
    /**
     * An achievement template this achievement is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The name of the trigger event associated with this achievement
     */
    "triggerEventName"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface AchievementProgressUpdateRequest {
    /**
     * Whether to add one to the current progress instead of setting it to progress_value. Default: false
     */
    "incrementValue"?: boolean;
    /**
     * The amount of progress towards earning the achievement. The max/target depends on the achievement. Required if increment_value is false/missing.
     */
    "progressValue"?: number;
}

export interface ActionResource {
    /**
     * The category the action is in. All customer specific actions are in the 'custom' category
     */
    "category"?: ActionResourceCategoryEnum;
    /**
     * The description of the action
     */
    "description": string;
    /**
     * The name of the action. Used as the unique id for reference
     */
    "name": string;
    /**
     * The variables required for the action
     */
    "variables": Array<ActionVariableResource>;
}

export type ActionResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface ActionVariableResource {
    /**
     * The name of the variable
     */
    "name": string;
    /**
     * Whether this variable is optional and can be left out/null
     */
    "optional": boolean;
    /**
     * The type of the variable (see variable type endpoint for list)
     */
    "type": string;
}

export interface ActivityEntitlementResource {
    /**
     * The ISO3 currency code the price is in, if available
     */
    "currencyCode"?: string;
    /**
     * The id of the entitlement item
     */
    "itemId": number;
    /**
     * The name of the entitlement item
     */
    "name"?: string;
    /**
     * The price of the sku, if available
     */
    "price"?: number;
    /**
     * The sku id, if available. If multiple are available, then first one is returned
     */
    "sku"?: string;
}

export interface ActivityOccurrenceCreationFailure {
    /**
     * The details of each user's entry, or just the current user's if not run with ACTIVITIES_ADMIN permission
     */
    "userResults"?: Array<ActivityOccurrenceJoinResult>;
}

export interface ActivityOccurrenceJoinResult {
    /**
     * The details on the entitlement object needed to enter the occurrence (if any)
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * Zero if the user was/could be added to the occurrence. Jsapi error code indicating the reason of the failure otherwise
     */
    "errorCode": number;
    /**
     * An error message if failure
     */
    "message"?: string;
    /**
     * The user's id
     */
    "userId": number;
}

export interface ActivityOccurrenceResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge activity (as part of the event, required if eventId set)
     */
    "challengeActivityId"?: number;
    /**
     * The date this occurrence was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The id of the event
     */
    "eventId"?: number;
    /**
     * The id of the activity occurrence
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: ActivityOccurrenceResourceRewardStatusEnum;
    /**
     * The list of settings and their options available for this activity. Should be null on create if and only if part of an event
     */
    "settings"?: Array<SelectedSettingResource>;
    /**
     * Whether this occurrence will be played as a simulation.
     */
    "simulated"?: boolean;
    /**
     * The date this occurrence was started, unix timestamp in seconds. null if not yet started
     */
    "startDate"?: number;
    /**
     * The current status of the occurrence (default: OPEN)
     */
    "status"?: ActivityOccurrenceResourceStatusEnum;
    /**
     * The date this occurrence was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The list of users playing in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
     */
    "users"?: Array<ActivityUserResource>;
}

export type ActivityOccurrenceResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export type ActivityOccurrenceResourceStatusEnum = "SETUP" | "OPEN" | "PLAYING" | "FINISHED" | "ABANDONED";
export interface ActivityOccurrenceResults {
    /**
     * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
     */
    "users": Array<UserActivityResultsResource>;
}

export interface ActivityResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The list of items that can be used for entitlement (wager amounts/etc)
     */
    "entitlements"?: Array<ActivityEntitlementResource>;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The list of settings and their options available for this activity. Not populated when getting listing
     */
    "settings"?: Array<AvailableSettingResource>;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * The type of the activity
     */
    "type": string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ActivityUserResource {
    /**
     * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
     */
    "host"?: boolean;
    /**
     * The id of the activity user entry
     */
    "id"?: number;
    /**
     * The date this user last joined the occurrence, unix timestamp in seconds
     */
    "joinedDate"?: number;
    /**
     * The date this user last left the occurrence, unix timestamp in seconds. Null if still present
     */
    "leftDate"?: number;
    /**
     * The metric for the user's results, after the game is over
     */
    "metric"?: MetricResource;
    /**
     * The current status of the user in the occurrence (default: present)
     */
    "status"?: ActivityUserResourceStatusEnum;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export type ActivityUserResourceStatusEnum = "present" | "ready" | "left" | "surrendered" | "disconnected";
export interface AddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface Affiliate {
    "affiliateKey"?: string;
    "id"?: number;
}

export interface AggregateCountResource {
    "count"?: number;
    "date"?: string;
}

export interface AggregateInvoiceReportResource {
    "count"?: number;
    "date"?: string;
    "revenue"?: number;
    "userCount"?: number;
}

export interface AmazonS3Activity {
    /**
     * S3 action (i.e., 'PUT') associated with the activity
     */
    "action"?: string;
    /**
     * Date the resource was created in S3
     */
    "createdDate"?: number;
    /**
     * Name of the file being processed as a resource in S3
     */
    "filename"?: string;
    /**
     * Unique id of the S3 activity
     */
    "id"?: number;
    /**
     * S3 object key for the resource
     */
    "objectKey"?: string;
    /**
     * URL for accessing the S3 resource
     */
    "url"?: string;
    /**
     * The id of the user that created this S3 activity
     */
    "userId"?: number;
}

export interface AnswerResource {
    /**
     * The answer to the question. Different 'type' values indicate different structures as the answer may be test, image, etc. See information on additional properties for the list and their structures
     */
    "answer": Property;
    /**
     * Whether the answer is correct or not
     */
    "correct": boolean;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
}

export interface ApplyPaymentRequest {
    /**
     * The id of the local invoice being paid.
     */
    "invoiceId": number;
    /**
     * The encoded receipt string from Apple's services.
     */
    "receipt": string;
    /**
     * The id of the specific transaction from Apple's services.
     */
    "transactionId": string;
}

export interface ArticleResource {
    /**
     * Whether the article is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The body of the article
     */
    "body": string;
    /**
     * The category for the article
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the article
     */
    "id"?: string;
    /**
     * The tags for the article
     */
    "tags"?: Array<string>;
    /**
     * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The title of the article
     */
    "title": string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface Artist {
    "additionalProperties"?: { [key: string]: Property; };
    "born"?: number;
    "contributionCount"?: number;
    "created"?: number;
    "died"?: number;
    "id"?: number;
    "longDescription"?: string;
    "name"?: string;
    "priority"?: number;
    "propertiesString"?: string;
    "shortDescription"?: string;
    "template"?: string;
    "updated"?: number;
}

export interface ArtistResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * YYYY/MM/DD when this artist was born
     */
    "born"?: string;
    /**
     * The current number of contributions the artist has made
     */
    "contributionCount"?: number;
    /**
     * The list of media this artist has contributed to as well as role(s) during contribution.  Use media endpoint to add contributions
     */
    "contributions"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * YYYY/MM/DD when this artist died
     */
    "died"?: string;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order priority ofr the artist.  Default 100
     */
    "priority"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * An artist template this artist is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface AvailableSettingResource {
    /**
     * Whether the setting is advanced. Default: false
     */
    "advancedOption"?: boolean;
    /**
     * The value of the default option (must be in options array)
     */
    "defaultValue": string;
    /**
     * The description of the setting
     */
    "description"?: string;
    /**
     * The unique ID for the setting
     */
    "key": string;
    /**
     * The textual name of the setting
     */
    "name": string;
    /**
     * The set of options available for this setting
     */
    "options": Array<SettingOption>;
}

export interface BareActivityResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * The type of the activity
     */
    "type": string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface BareChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge
     */
    "challengeId": number;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
}

export interface Batch {
    "batch"?: Array<BatchRequest>;
}

export interface BatchRequest {
    /**
     * The request body as would be passed to the URI
     */
    "body": any;
    /**
     * Content type used, Ex:(application/json)
     */
    "contentType": string;
    /**
     * The HTTP method used, Ex: (GET)
     */
    "method": string;
    /**
     * Time in seconds before process will timeout.  Default is 60.  Range is 1-300
     */
    "timeout": number;
    /**
     * The oauth token only
     */
    "token"?: string;
    /**
     * Full URI of REST call
     */
    "uri": string;
}

export interface BatchReturn {
    /**
     * The result body
     */
    "body": any;
    /**
     * The HTTP response code
     */
    "code": number;
    /**
     * Full URI of REST call
     */
    "uri": string;
}

export interface Behavior {
    /**
     * Used for polymorphic type recognition and thus must match an expected type with additional properties
     */
    "typeHint"?: string;
}

export interface BillingReport {
    "created"?: number;
    "id"?: string;
    "lastKnownFailures"?: Array<string>;
    "statistics"?: { [key: string]: number; };
}

export interface BooleanResource {
    "value"?: boolean;
}

export interface BreCategoryResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The name of the category. Serves as the unique id
     */
    "name"?: string;
    /**
     * A template this BRE category is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface BreEvent {
    /**
     * The event name of the trigger to be fired
     */
    "eventName": string;
    /**
     * The parameters to the event. A Map (assosiative array) with a key for each trigger parameter name and a corrosponding value.
     */
    "params": any;
}

export interface BreEventLog {
    /**
     * The customer of the BRE event log
     */
    "customer"?: string;
    /**
     * The event id of the BRE event log
     */
    "eventId"?: number;
    /**
     * The event name of the BRE event log
     */
    "eventName"?: string;
    /**
     * The event start date of the BRE event log
     */
    "eventStartDate"?: number;
    /**
     * The id of the BRE event log
     */
    "id"?: string;
    /**
     * The event paramters of the BRE event log
     */
    "parameters"?: any;
    /**
     * The rules of the BRE event log
     */
    "rules"?: Array<BreRuleLog>;
}

export interface BreGlobalResource {
    /**
     * A human readable description for display in admin pages
     */
    "description"?: string;
    /**
     * The id of the global definition. Default is a random guid. Cannot be updated
     */
    "id"?: string;
    /**
     * The key for the global. Must be unique when combined with scope names. Usually a single descriptive word like 'purchases' or 'logins'
     */
    "key": string;
    /**
     * A human readable name for display in admin pages
     */
    "name"?: string;
    /**
     * A list of scoping parameters. Allows the global to have a different value in different context such as a count of purchases for each user (by putting a 'user' scope in this list). When using this global in a rule these scopes will need to be mapped with an expression to provide a value, similar to the parameters in an action
     */
    "scopes"?: Array<BreGlobalScopeDefinition>;
    /**
     * Where this global came from. System globals cannot be removed or updated
     */
    "systemGlobal"?: boolean;
    /**
     * The variable type the global stores. See the See Bre Variables enpoint for list
     */
    "type": string;
}

export interface BreGlobalScopeDefinition {
    /**
     * The name of the scoping parameter. This is used as the unique identifier of this scope
     */
    "name": string;
    /**
     * The variable type of this scoping parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreRule {
    /**
     * A list of actions to execute, and the mapping for their parameters, when the rule runs. Minimum 1
     */
    "actions": ActionResource;
    /**
     * A condition expression that must be met in a given event for the rule to run. Empty to always run
     */
    "condition"?: PredicateOperation;
    /**
     * The condition as a readable string. Filled in by the system from the condition
     */
    "conditionText"?: string;
    /**
     * The human readable description of the rule
     */
    "description"?: string;
    /**
     * Whether the rule is enabled to run (in conjunction with dates). Default true
     */
    "enabled"?: boolean;
    /**
     * The date the rule ceases to take effect, or null if never. Unix timestamp in seconds
     */
    "endDate"?: number;
    /**
     * The event name of the trigger this rule runs for. Affects which parameters are available
     */
    "eventName": string;
    /**
     * The id of the rule for later references. If left null a random guid will be generated. Must be unique. Cannot be changed
     */
    "id"?: string;
    /**
     * The human readable name of the rule
     */
    "name": string;
    /**
     * Used to sort rules to control the order they run in. Larger numbered sort values run first.  Default 500
     */
    "sort"?: number;
    /**
     * The date the rule begins to take effect, or null if always. Unix timestamp in seconds
     */
    "startDate"?: number;
    /**
     * Whether the rule is a default part of the system. System rules cannot be edited or deleted, but may be disabled
     */
    "systemRule"?: boolean;
}

export interface BreRuleLog {
    /**
     * Whether the rule ran
     */
    "ran"?: boolean;
    /**
     * The reason for the rule
     */
    "reason"?: string;
    /**
     * The end date of the rule in seconds
     */
    "ruleEndDate"?: number;
    /**
     * The id of the rule
     */
    "ruleId"?: string;
    /**
     * The name of the rule
     */
    "ruleName"?: string;
    /**
     * The start date of the rule in seconds
     */
    "ruleStartDate"?: number;
}

export interface BreTriggerParameterDefinition {
    /**
     * The name of the parameter. This is used as the unique identifier of this parameter
     */
    "name": string;
    /**
     * The variable type of this parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreTriggerResource {
    /**
     * The category this trigger belongs to. See endpoints for related asset information. All new triggers are in category 'custom'
     */
    "category"?: BreTriggerResourceCategoryEnum;
    /**
     * The unique name for the event. This serves as the unique identifier. Cannot be changed after creation
     */
    "eventName": string;
    /**
     * A list af parameters that will be sent with the event when the trigger is fired. These must be included in the event and match the described types
     */
    "parameters"?: Array<BreTriggerParameterDefinition>;
    /**
     * Where this trigger came from. System triggers cannot be removed or updated
     */
    "systemTrigger"?: boolean;
    /**
     * A description of the trigger
     */
    "triggerDescription": string;
    /**
     * A human readable name for this trigger
     */
    "triggerName": string;
}

export type BreTriggerResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface BundleItem {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * The skus of items to be included in this bundle, and how they influence the bundle total price.  Must have at least one SKU
     */
    "bundledSkus": Array<BundledSku>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether or not the item is currently displayable.  Default = true
     */
    "displayable"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: BundleItemGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type BundleItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface BundledSku {
    /**
     * The amount this item will cost inside the bundle instead of its regular price
     */
    "priceOverride"?: number;
    /**
     * The quantity of this item within the bundle
     */
    "quantity": number;
    /**
     * The stock keeping unit (SKU) for an item included in the bundle
     */
    "sku": string;
}

export interface CampaignResource {
    /**
     * Whether the campaign is active or not.  Defaults to false
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The name of the next challenge coming up
     */
    "nextChallenge"?: string;
    /**
     * The date/time of the next challenge coming up
     */
    "nextChallengeDate"?: number;
    /**
     * The rewards to give at the end of the campaign. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: CampaignResourceRewardStatusEnum;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * A campaign template this campaign is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type CampaignResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface Cart {
    "countryTax"?: number;
    "coupons"?: Array<CouponDefinition>;
    "created"?: number;
    "currencyCode"?: string;
    "discountTotal"?: number;
    "errorCode"?: number;
    "errorMessage"?: string;
    "grandTotal"?: number;
    "id"?: string;
    "invoiceId"?: number;
    "items"?: Array<CartLineItem>;
    "owner"?: number;
    "selectedShippingOptions"?: Array<CartShippingOption>;
    "shippable"?: boolean;
    "shippingAddress"?: CartShippingAddressRequest;
    "shippingCost"?: number;
    "shippingOptions"?: { [key: string]: Set; };
    "stateTax"?: number;
    "status"?: CartStatusEnum;
    "subtotal"?: number;
    "updated"?: number;
}

export type CartStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CartItemRequest {
    /**
     * The affiliate key of the item
     */
    "affiliateKey"?: string;
    /**
     * The catalog SKU of the item
     */
    "catalogSku": string;
    /**
     * The quantity of the item
     */
    "quantity": number;
}

export interface CartLineItem {
    "currencyCode"?: string;
    "description"?: string;
    "discount"?: Discount;
    "lineTotal"?: number;
    "name"?: string;
    "originalLineTotal"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "storeItemId"?: number;
    "tags"?: Array<string>;
    "thumbUrl"?: string;
    "unitPrice"?: number;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartShippableResponse {
    /**
     * The id of the cart
     */
    "cartId"?: number;
    /**
     * Whether the item is shippable
     */
    "shippable"?: boolean;
}

export interface CartShippingAddressRequest {
    /**
     * The city of the user
     */
    "city"?: string;
    /**
     * The country code of the user
     */
    "countryCodeIso3"?: string;
    /**
     * The email of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    "namePrefix"?: string;
    /**
     * The order notes the user
     */
    "orderNotes"?: string;
    /**
     * The phone number of the user
     */
    "phoneNumber"?: string;
    /**
     * The postal state code of the user
     */
    "postalStateCode"?: string;
    /**
     * The shipping address of the user, first line
     */
    "shippingAddressLine1"?: string;
    /**
     * The shipping address of the user, second line
     */
    "shippingAddressLine2"?: string;
    /**
     * The zipcode of the user
     */
    "zip"?: string;
}

export interface CartShippingOption {
    "currencyCode"?: string;
    "description"?: string;
    "name"?: string;
    "originalPrice"?: number;
    "price"?: number;
    "shippingItemId"?: number;
    "sku"?: string;
    "taxable"?: boolean;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartSummary {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique id code for the currency used in the cart
     */
    "currencyCode"?: string;
    /**
     * The grand total for the cart
     */
    "grandTotal"?: number;
    /**
     * The unique ID for the cart
     */
    "id"?: string;
    /**
     * The ID of the invoice associated with this cart
     */
    "invoiceId"?: number;
    /**
     * The number of items in the cart
     */
    "itemsInCart"?: number;
    /**
     * The status of the cart
     */
    "status"?: CartSummaryStatusEnum;
    /**
     * The subtotal of all items in the cart
     */
    "subtotal"?: number;
}

export type CartSummaryStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CatalogSale {
    /**
     * The iso3 code for the currency for this discountValue.  The sku purchased will have to match for it this sale to apply
     */
    "currencyCode": string;
    /**
     * The way in which the price is reduced. 'value' means subtracting directly, 'percentage' means subtracting by the price times the discountValue (1.0 == 100%)
     */
    "discountType": CatalogSaleDiscountTypeEnum;
    /**
     * The amount deducted from the price, in the same currencyCode as the item
     */
    "discountValue"?: number;
    /**
     * The id of the sale
     */
    "id"?: number;
    /**
     * The id of the item this sale applies to.  Leave null to use other filters
     */
    "item"?: number;
    /**
     * The long description of the sale
     */
    "longDescription"?: string;
    /**
     * The name of the sale.  Max 40 characters
     */
    "name": string;
    /**
     * The date the sale ends, null for never.  Unix timestamp in seconds
     */
    "saleEndDate"?: number;
    /**
     * The date the sale begins.  Unix timestamp in seconds
     */
    "saleStartDate": number;
    /**
     * The short description of the sale.  Max 140 characters
     */
    "shortDescription"?: string;
    /**
     * The tag this sale applies to.  Leave null to skip this filter (applies to all tags)
     */
    "tag"?: string;
    /**
     * The id of the vendor this sale applies to.  Leave null to skip this filter (applies to all vendors)
     */
    "vendor"?: number;
}

export type CatalogSaleDiscountTypeEnum = "value" | "percentage";
export interface CategoryResource {
    /**
     * Whether the category is currently active. If not, it and its questions will be filtered out.
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The unique ID for this category
     */
    "id"?: string;
    /**
     * The name of this category. Cannot be blank
     */
    "name": string;
    /**
     * A category template this category is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface ChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * The entitlement item needed to participate in the activity as part of this event. Null indicates free entry. When creating/updating only id is used. Item must be pre-existing
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The list of settings and the select options
     */
    "settings"?: Array<SelectedSettingResource>;
}

export interface ChallengeEventParticipantResource {
    "email"?: string;
    "fullname"?: string;
    "score"?: number;
    "userId"?: number;
    "username"?: string;
}

export interface ChallengeEventResource {
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * The end date in seconds
     */
    "endDate"?: number;
    /**
     * The id of the challenge event
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already 
     */
    "rewardStatus"?: ChallengeEventResourceRewardStatusEnum;
    /**
     * The start date in seconds
     */
    "startDate"?: number;
}

export type ChallengeEventResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface ChallengeResource {
    /**
     * The number of activities allowed to this challenge
     */
    "activities"?: number;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The id of the campaign this challenge is a part of. The challenge must be tied to an active campaign before it will spawn events
     */
    "campaignId"?: number;
    /**
     * The ID of the original challenge it was copied from
     */
    "copyOf"?: number;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The end date of this challenge in seconds since epoch. required if part of a campaign
     */
    "endDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service.
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The next date this challenge will be occur in seconds since epoch
     */
    "nextEventDate"?: number;
    /**
     * The number of minutes minimum to wait at the end of this challenge before running rewards, to allow activities to complete
     */
    "rewardLagMinutes"?: number;
    /**
     * The rewards to give at the end of the challenge. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The repeat schedule for the challenge
     */
    "schedule"?: Schedule;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The start date of this challenge in seconds since epoch. required if part of a campaign
     */
    "startDate"?: number;
    /**
     * A challenge template this challenge is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ClientResource {
    /**
     * The time limit of the token in seconds
     */
    "accessTokenValiditySeconds"?: number;
    /**
     * The client key, cannot be edited once created
     */
    "clientKey": string;
    /**
     * The grant types of the client
     */
    "grantTypes"?: Array<string>;
    /**
     * The id of the client
     */
    "id"?: number;
    /**
     * Whether the client is public or not
     */
    "isPublic"?: boolean;
    /**
     * Whether a client is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the client
     */
    "name": string;
    /**
     * The redirect uris of the client
     */
    "redirectUris"?: Array<string>;
    /**
     * The time limit of the refresh token in seconds
     */
    "refreshTokenValiditySeconds"?: number;
    /**
     * The secret key of the client
     */
    "secret": string;
}

export interface CollectionCountry {
}

export interface CollectionVideoContribution {
}

export interface Collectionstring {
}

export interface CommentResource {
    /**
     * The comment content of that resource
     */
    "content": string;
    /**
     * The type of object this comment applies to (ex: video, article, etc). Required when passed to /comments
     */
    "context"?: string;
    /**
     * The id of the object this comment applies to.  Required when passed to /comments
     */
    "contextId"?: number;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The summary of that resource
     */
    "summary"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The user who created the comment
     */
    "user"?: SimpleUserResource;
}

export interface CommentSearch {
    "content"?: string;
    "context"?: string;
    "contextId"?: number;
    "id"?: number;
    "ownerId"?: number;
    "ownerUsername"?: string;
}

export interface Config {
    /**
     * The name of the config
     */
    "name": string;
    /**
     * Whether the config is public for viewing. True means that it can be publicly viewed by all. Default: false
     */
    "publicRead"?: boolean;
    /**
     * The value of the config
     */
    "value"?: string;
}

export interface ContributionResource {
    /**
     * A reference to the contributing artist
     */
    "artist": SimpleReferenceResourcelong;
    /**
     * A reference to the media being contributed to
     */
    "media": SimpleReferenceResourcelong;
    /**
     * The nature of the contribution (role of the artist as in 'producer', 'performer', etc)
     */
    "role": string;
}

export interface Country {
    "id"?: number;
    "iso2"?: string;
    "iso3"?: string;
    "name"?: string;
}

export interface CountryResource {
    /**
     * The iso2 of the country
     */
    "iso2"?: string;
    /**
     * The iso3 of the country
     */
    "iso3"?: string;
    /**
     * The name of the country resource
     */
    "name"?: string;
}

export interface CountryTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface CouponDefinition {
    "code"?: string;
    "description"?: string;
    "discountType"?: CouponDefinitionDiscountTypeEnum;
    "exclusive"?: boolean;
    "maxDiscount"?: number;
    "maxQuantity"?: number;
    "minCartTotal"?: number;
    "name"?: string;
    "selfExclusive"?: boolean;
    "targetItemId"?: number;
    "type"?: CouponDefinitionTypeEnum;
    "validForTags"?: Array<string>;
    "value"?: number;
    "vendorId"?: number;
}

export type CouponDefinitionDiscountTypeEnum = "value" | "percentage";
export type CouponDefinitionTypeEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
export interface CouponItem {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The type of coupon
     */
    "couponTypeHint": CouponItemCouponTypeHintEnum;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The amount this coupon is maxed out at.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMax"?: number;
    /**
     * The minimium amount needed in the cart for the coupon to apply.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMinCartValue"?: number;
    /**
     * The type of coupon discount
     */
    "discountType": CouponItemDiscountTypeEnum;
    /**
     * The amount the coupon will discount the item
     */
    "discountValue": number;
    /**
     * Whether or not the item is currently displayable.  Default = true
     */
    "displayable"?: boolean;
    /**
     * Whether this coupon is exclusive or not (true means cannot be in same cart as another).  Default = false
     */
    "exclusive"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: CouponItemGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * The id of the item the coupon is applied to.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "itemId"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The maximum quantity of items the coupon can apply to, null if no limit and minimum 1 otherwise.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "maxQuantity"?: number;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
     */
    "selfExclusive"?: boolean;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * A list of tags for a coupon.  The coupon can only apply to an item that has at least one of these tags.  Applies if coupon_type_hint is coupon_tag
     */
    "validForTags"?: Array<string>;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type CouponItemCouponTypeHintEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
export type CouponItemDiscountTypeEnum = "value" | "percentage";
export type CouponItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface CreateBillingAgreementRequest {
    /**
     * The endpoint URL to which PayPal should forward the user if they cancel (do not accept) the agreement
     */
    "cancelUrl": string;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept the agreement. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface CreatePayPalPaymentRequest {
    /**
     * The endpoint URL to which PayPal should forward the user to if they cancel the checkout process
     */
    "cancelUrl": string;
    /**
     * The ID of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
}

export interface Currency {
    "active"?: boolean;
    "code"?: string;
    "dateCreated"?: number;
    "dateUpdated"?: number;
    "factor"?: number;
    "icon"?: string;
    "id"?: number;
    "name"?: string;
    "type"?: CurrencyTypeEnum;
    "virtual"?: boolean;
}

export type CurrencyTypeEnum = "real" | "virtual";
export interface CurrencyResource {
    /**
     * Whether the currency is active. Default true
     */
    "active"?: boolean;
    /**
     * The unique id code for the currency. Maximum 5 characters
     */
    "code": string;
    /**
     * The unix timestamp in seconds the currency was added to the system
     */
    "createdDate"?: number;
    /**
     * The decimal to multiply the system base currency (from config 'currency') to localize to this one. Should be 1 for the base currency itself.
     */
    "factor": number;
    /**
     * The url for an icon of the currency
     */
    "icon"?: string;
    /**
     * The name of the currency
     */
    "name": string;
    /**
     * The type of currency. Default 'real'
     */
    "type"?: CurrencyResourceTypeEnum;
    /**
     * The unix timestamp in seconds the currency was last updated in the system.
     */
    "updatedDate"?: number;
}

export type CurrencyResourceTypeEnum = "real" | "virtual";
export interface DeltaResource {
    /**
     * The id of the category for question
     */
    "categoryId"?: string;
    /**
     * The media type of the question
     */
    "mediaType"?: string;
    /**
     * The id of the question
     */
    "questionId"?: string;
    /**
     * Whether the question was updated or removed
     */
    "state"?: DeltaResourceStateEnum;
    /**
     * The tags for the question
     */
    "tags"?: Array<string>;
    /**
     * The date this question was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type DeltaResourceStateEnum = "UPDATED" | "REMOVED";
export interface DeviceResource {
    /**
     * The authorization code for the device
     */
    "authorization"?: string;
    /**
     * The current condition of the device (New, Defective, Reconditioned)
     */
    "condition"?: DeviceResourceConditionEnum;
    /**
     * The date the device log was created
     */
    "createdDate"?: number;
    /**
     * The key/value pairs for extended data
     */
    "data"?: { [key: string]: string; };
    /**
     * The description of the device
     */
    "description"?: string;
    /**
     * The type of the device
     */
    "deviceType"?: string;
    /**
     * The unique ID for this device. Cannot be changed once created
     */
    "id": number;
    /**
     * The location of the device
     */
    "location"?: string;
    /**
     * The MAC (media access control) address of the device
     */
    "macAddress"?: string;
    /**
     * The make of the device
     */
    "make"?: string;
    /**
     * The model of the device
     */
    "model"?: string;
    /**
     * The name of the device
     */
    "name"?: string;
    /**
     * The OS (operating system) on the device
     */
    "os"?: string;
    /**
     * The serial number of the device
     */
    "serial"?: string;
    /**
     * The current status the device (Active, Pending Active, Inactive, Repair
     */
    "status"?: DeviceResourceStatusEnum;
    /**
     * The date the device log was updated
     */
    "updatedDate"?: number;
    /**
     * The user that owns the device
     */
    "user"?: SimpleUserResource;
}

export type DeviceResourceConditionEnum = "New" | "Defective" | "Reconditioned";
export type DeviceResourceStatusEnum = "Active" | "PendingActive" | "Inactive" | "Repair";
export interface Discount {
    "description"?: string;
    "name"?: string;
    "sku"?: string;
    "value"?: number;
}

export interface DispositionCount {
    /**
     * The number of users that have expressed this disposition
     */
    "count"?: number;
    /**
     * The name of the disposition this count is for
     */
    "name"?: string;
}

export interface DispositionResource {
    /**
     * The context of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "context"?: string;
    /**
     * The context_id of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The name of the disposition, 1-20 characters. (ex: like/dislike/favorite, etc)
     */
    "name": string;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

export interface EntitlementGrantRequest {
    /**
     * The ID of the entitlement item to grant
     */
    "entitlementId": number;
}

export interface EntitlementItem {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface Expressionobject {
}

export interface FinalizeBillingAgreementRequest {
    /**
     * The ID of the invoice being paid along with the creation of this agreement
     */
    "invoiceId"?: number;
    /**
     * Whether the new payment method created should be the user's default
     */
    "newDefault"?: boolean;
    /**
     * The payer ID from PayPal (passed as a parameter in the return URL). Only required if an invoice ID was included
     */
    "payerId"?: string;
    /**
     * The token from PayPal (passed as a parameter in the return URL)
     */
    "token": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface FinalizePayPalPaymentRequest {
    /**
     * The ID of the invoice that is being paid. Must match the invoice sent in originally
     */
    "invoiceId": number;
    /**
     * The ID of the payer that PayPal returned with the user at the return URL
     */
    "payerId": string;
    /**
     * The token that PayPal returned with the user in the return URL
     */
    "token": string;
}

export interface FlagReportResource {
    /**
     * The context of that resource 
     */
    "context"?: string;
    /**
     * The context ID of that resource
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The reason of that resource required only in case of active resolution
     */
    "reason"?: string;
    /**
     * The resolution of that resource
     */
    "resolution": FlagReportResourceResolutionEnum;
    /**
     * The date/time this report was resolved in seconds since epoch. Null if not resolved yet
     */
    "resolved"?: number;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
}

export type FlagReportResourceResolutionEnum = "banned" | "ignored";
export interface FlagResource {
    /**
     * The context of that resource
     */
    "context": string;
    /**
     * The context_id of that resource
     */
    "contextId": string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The flag reason of that resource
     */
    "reason"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The basic user resource
     */
    "user"?: SimpleUserResource;
}

export interface ForwardLog {
    /**
     * The end date of the forward log entry
     */
    "endDate"?: number;
    "errorMsg"?: string;
    /**
     * The http status code the forward log entry
     */
    "httpStatusCode"?: number;
    /**
     * The id of the forward log entry
     */
    "id"?: string;
    /**
     * The payload of the forward log entry
     */
    "payload"?: any;
    /**
     * The response string of the forward log entry
     */
    "response"?: string;
    /**
     * The retry count of the forward log entry
     */
    "retryCount"?: number;
    /**
     * The start date of the forward log entry
     */
    "startDate"?: number;
    /**
     * The endpoint url of the forward log entry
     */
    "url"?: string;
}

export interface FulfillmentType {
    /**
     * Whether the type is core and cannot be altered/deleted, read-only
     */
    "core"?: boolean;
    /**
     * A description of the type
     */
    "description"?: string;
    /**
     * The unique id of the type, read-only
     */
    "id"?: number;
    /**
     * The name of the type
     */
    "name": string;
}

export interface GooglePaymentRequest {
    /**
     * The json payload exactly as sent from Google
     */
    "jsonPayload": string;
    /**
     * The signature from Google to verify the payload
     */
    "signature": string;
}

export interface GrantTypeResource {
    /**
     * The description of the grant type
     */
    "description"?: string;
    /**
     * The name of the grant type
     */
    "name"?: string;
}

export interface Group {
    "additionalProperties"?: { [key: string]: Property; };
    "description"?: string;
    "id"?: number;
    "memberCount"?: number;
    "messageOfTheDay"?: string;
    "name"?: string;
    "parent"?: Group;
    "propertiesString"?: string;
    "status"?: GroupStatusEnum;
    "subMemberCount"?: number;
    "template"?: string;
    "uniqueName"?: string;
}

export type GroupStatusEnum = "open" | "closed";
export interface GroupMember {
    "group"?: Group;
    "secondary"?: boolean;
    "status"?: GroupMemberStatusEnum;
    "user"?: User;
}

export type GroupMemberStatusEnum = "moderator" | "member";
export interface GroupMemberResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The member's access level. Default: member
     */
    "status": GroupMemberResourceStatusEnum;
    /**
     * The username of the user
     */
    "username"?: string;
}

export type GroupMemberResourceStatusEnum = "moderator" | "member";
export interface GroupResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * A description of the group. Max 250 characters
     */
    "description"?: string;
    /**
     * The number of users in the group
     */
    "memberCount"?: number;
    /**
     * A message of the day for members of the group
     */
    "messageOfTheDay"?: string;
    /**
     * The name of the group. Max 50 characters
     */
    "name": string;
    /**
     * The unique name of another group that this group is a subset of
     */
    "parent"?: string;
    /**
     * The status which describes whether other users can freely join the group or not
     */
    "status": GroupResourceStatusEnum;
    /**
     * The number of users in child groups
     */
    "subMemberCount"?: number;
    /**
     * A group template this group is validated against. May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created
     */
    "uniqueName": string;
}

export type GroupResourceStatusEnum = "open" | "closed";
export interface ImportJobOutputResource {
    /**
     * The description of the import job
     */
    "description"?: string;
    /**
     * The line number of the import job
     */
    "lineNumber"?: number;
}

export interface ImportJobResource {
    /**
     * The id of the category to assign all questions in the import to
     */
    "categoryId": string;
    /**
     * The date the job was created in seconds since unix epoc
     */
    "createdDate"?: number;
    /**
     * The id of the job
     */
    "id"?: number;
    /**
     * A name for this import for later reference
     */
    "name": string;
    /**
     * Error information from validation
     */
    "output"?: Array<ImportJobOutputResource>;
    /**
     * The number of questions form the CSV file. Filled in after validation
     */
    "recordCount"?: number;
    /**
     * The status of the job
     */
    "status"?: ImportJobResourceStatusEnum;
    /**
     * The date the job was last updated in seconds since unix epoc
     */
    "updatedDate"?: number;
    /**
     * The url of a CSV file to pull trivia questions from. Cannot be changed after initial POST
     */
    "url": string;
    /**
     * The vendor who supplied this set of questions
     */
    "vendor": string;
}

export type ImportJobResourceStatusEnum = "PENDING_VALIDATION" | "VALIDATING" | "VALID" | "INVALID" | "PENDING_PROCESS" | "PROCESSING" | "PROCESSED" | "FAILED";
export interface InventorySubscriptionResource {
    /**
     * The date the subscription will be billed
     */
    "billDate"?: number;
    /**
     * A credit of money already applied to a subscription for the next bill, or a debt if negative
     */
    "credit"?: number;
    /**
     * A record of past and present credit/debt changes
     */
    "creditLog"?: Array<SubscriptionCreditResource>;
    /**
     * The date the grace period ends
     */
    "graceEnd"?: number;
    /**
     * The id of the inventory
     */
    "inventoryId"?: number;
    /**
     * The inventory status object
     */
    "inventoryStatus"?: InventorySubscriptionResourceInventoryStatusEnum;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The payment method object
     */
    "paymentMethod"?: PaymentMethodResource;
    /**
     * The recurring price
     */
    "recurringPrice"?: number;
    /**
     * The sku of the subscription
     */
    "sku"?: string;
    /**
     * The date the subscription will start
     */
    "startDate"?: number;
    /**
     * The status of the subscription
     */
    "subscriptionStatus"?: number;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

export type InventorySubscriptionResourceInventoryStatusEnum = "pending" | "active" | "inactive";
export interface InvoiceCreateRequest {
    /**
     * The guid of a cart to create a new invoice for
     */
    "cartGuid": string;
}

export interface InvoiceItemResource {
    "affiliateId"?: number;
    "bundleSku"?: string;
    "currentFulfillmentStatus"?: string;
    "id"?: number;
    "invoiceId"?: number;
    "itemId"?: number;
    "itemName"?: string;
    "originalTotalPrice"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "systemPrice"?: number;
    "totalPrice"?: number;
    "typeHint"?: string;
    "unitPrice"?: number;
}

export interface InvoiceLogEntry {
    /**
     * The date this event occured as a unix timestamp in seconds
     */
    "date"?: number;
    /**
     * The ID of the invoice
     */
    "invoiceId"?: number;
    /**
     * A message describing the event
     */
    "message"?: string;
    /**
     * The type of event
     */
    "type"?: string;
}

export interface InvoicePaymentStatusRequest {
    /**
     * If included, will set the payment method used on the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The new status for the invoice. Additional options may be available based on configuration.  Allowable values: 'new', 'paid', 'hold', 'canceled', 'payment failed', 'partial refund', 'refund'
     */
    "status": string;
}

export interface InvoiceResource {
    /**
     * Line one of the customer's billing address
     */
    "billingAddress1"?: string;
    /**
     * Line two of the customer's billing address
     */
    "billingAddress2"?: string;
    /**
     * The city for the customer's billing address
     */
    "billingCityName"?: string;
    /**
     * The country for the customer's billing address
     */
    "billingCountryName"?: string;
    /**
     * The customer's name for the billing address
     */
    "billingFullName"?: string;
    /**
     * The postal code for the customer's billing address
     */
    "billingPostalCode"?: string;
    /**
     * The state for the customer's billing address
     */
    "billingStateName"?: string;
    /**
     * The guid of the cart this invoice came from
     */
    "cartId"?: string;
    /**
     * The date the invoice was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The code for the currency invoice prices are in
     */
    "currency"?: string;
    /**
     * The fulfillment status of the invoice
     */
    "currentFulfillmentStatus"?: string;
    /**
     * The payment status of the invoice
     */
    "currentPaymentStatus"?: string;
    /**
     * The amount of money saved through coupons
     */
    "discount"?: number;
    /**
     * The customer's email address
     */
    "email"?: string;
    /**
     * An external reference to filter on
     */
    "externalRef"?: string;
    /**
     * The amount of federal tax added
     */
    "fedTax"?: number;
    /**
     * The final price of the invoice
     */
    "grandTotal"?: number;
    /**
     * The id of the invoice
     */
    "id"?: number;
    /**
     * A reference number for the invoice
     */
    "invoiceNumber"?: string;
    /**
     * A list of items within the invoice
     */
    "items"?: Array<InvoiceItemResource>;
    /**
     * The customer's name prefix
     */
    "namePrefix"?: string;
    /**
     * Notes about the order
     */
    "orderNotes"?: string;
    /**
     * The id of an invoice this is a child of
     */
    "parentInvoiceId"?: number;
    /**
     * The id of a saved payment method used to pay for the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The customer's phone number
     */
    "phone"?: string;
    /**
     * The customer's phone number
     */
    "phoneNumber"?: string;
    /**
     * The shipping cost
     */
    "shipping"?: number;
    /**
     * Line one of the customer's shipping address
     */
    "shippingAddress1"?: string;
    /**
     * Line two of the customer's shipping address
     */
    "shippingAddress2"?: string;
    /**
     * The city for the customer's shipping address
     */
    "shippingCityName"?: string;
    /**
     * The country for the customer's shipping address
     */
    "shippingCountryName"?: string;
    /**
     * The customer's name for the shipping address
     */
    "shippingFullName"?: string;
    /**
     * The postal code for the customer's shipping address
     */
    "shippingPostalCode"?: string;
    /**
     * The state for the customer's shipping address
     */
    "shippingStateName"?: string;
    /**
     * A number to use in sorting items. default 500.
     */
    "sort"?: number;
    /**
     * The amount of state tax added
     */
    "stateTax"?: number;
    /**
     * The sum price of all items before shipping, coupons and tax
     */
    "subtotal"?: number;
    /**
     * The date the invoice was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The owner of the invoice
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the vendor
     */
    "vendorId"?: number;
    /**
     * The name of the invoice
     */
    "vendorName"?: string;
}

export interface ItemBehaviorDefinitionResource {
    /**
     * The default version of the behavior
     */
    "behavior": Behavior;
    /**
     * Whether the behavior's values can be modified
     */
    "modifiable": boolean;
    /**
     * Whether the behavior can be removed
     */
    "required": boolean;
}

export interface ItemTemplateResource {
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface KeyValuePairstringstring {
    "key"?: string;
    "value"?: string;
}

export interface Language {
    "code"?: string;
    "dateCreated"?: number;
    "dateUpdated"?: number;
    "description"?: string;
    "direction"?: string;
    "id"?: number;
    "isPrimary"?: boolean;
    "name"?: string;
}

export interface LeaderboardEntryResource {
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface LeaderboardResource {
    /**
     * The paginated list of user results, in order from best to worst
     */
    "entries"?: Array<LeaderboardEntryResource>;
    /**
     * The id of the leaderboard
     */
    "id"?: number;
    /**
     * The name of the strategy that defines how entries are stored and compared
     */
    "strategy"?: string;
}

export interface LevelingResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the leveling schema was created
     */
    "createdDate"?: number;
    /**
     * The description of the leveling schema
     */
    "description"?: string;
    /**
     * The name of the leveling schema.  IMMUTABLE
     */
    "name": string;
    /**
     * A set of tiers that contain experience boundaries
     */
    "tiers"?: Array<TierResource>;
    /**
     * The date the leveling schema was updated
     */
    "updatedDate"?: number;
}

export interface Localizer {
}

export interface LocationLogResource {
    "country"?: string;
    "ip"?: string;
    "time"?: number;
}

export interface LookupTypeResource {
    /**
     * The description of the expression type
     */
    "description": string;
    /**
     * The variable type the key expression must be, or null if it's dependent (see description for explanation in this case)
     */
    "keyType": string;
    /**
     * The name of the expression type
     */
    "name": string;
    /**
     * The variable type of the value this expression returns, or null if it's dependent (see description for explanation in this case)
     */
    "valueType": string;
}

export interface Maintenance {
    /**
     * Whether access to the system has been locked
     */
    "accessLocked": boolean;
    /**
     * A simple object of any schema for client side use and processing
     */
    "details"?: any;
    /**
     * User displayable message about the maintenance
     */
    "message": string;
}

export interface Mapstringobject extends null<String, any> {
}

export interface MetricResource {
    /**
     * The id of the activity occurence where this score/metric occured
     */
    "activityOccurenceId": number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The value/score of the metric
     */
    "value": number;
}

export interface NestedCategory {
    /**
     * Whether the category is active
     */
    "active"?: boolean;
    /**
     * The id of the category
     */
    "id": string;
    /**
     * The name of the category
     */
    "name"?: string;
}

export interface NewPasswordRequest {
    /**
     * The new password in plain text
     */
    "password": string;
    /**
     * The secret provided after the password reset
     */
    "secret": string;
}

export interface OauthAccessTokenResource {
    /**
     * The key of the client assosciated with the token
     */
    "clientId"?: string;
    /**
     * The token.  Not shown in list view
     */
    "token"?: string;
    /**
     * The username of the user associated with the token
     */
    "username"?: string;
}

export interface Operator {
}

export interface OptimalPaymentRequest {
    /**
     * The email address of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The url to redirect the user to after declining payment
     */
    "onDecline": string;
    /**
     * The url to redirect the user to after an error in payment
     */
    "onError": string;
    /**
     * The url to redirect the user to after successful payment
     */
    "onSuccess": string;
}

export interface Order {
    "ascending"?: boolean;
    "direction"?: OrderDirectionEnum;
    "ignoreCase"?: boolean;
    "nullHandling"?: OrderNullHandlingEnum;
    "property"?: string;
}

export type OrderDirectionEnum = "ASC" | "DESC";
export type OrderNullHandlingEnum = "NATIVE" | "NULLS_FIRST" | "NULLS_LAST";
export interface PageResourceAchievementDefinitionResource {
    "content"?: Array<AchievementDefinitionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateCountResource {
    "content"?: Array<AggregateCountResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateInvoiceReportResource {
    "content"?: Array<AggregateInvoiceReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArticleResource {
    "content"?: Array<ArticleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArtistResource {
    "content"?: Array<ArtistResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareActivityResource {
    "content"?: Array<BareActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareChallengeActivityResource {
    "content"?: Array<BareChallengeActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBillingReport {
    "content"?: Array<BillingReport>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreCategoryResource {
    "content"?: Array<BreCategoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreEventLog {
    "content"?: Array<BreEventLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreGlobalResource {
    "content"?: Array<BreGlobalResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreRule {
    "content"?: Array<BreRule>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreTriggerResource {
    "content"?: Array<BreTriggerResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCampaignResource {
    "content"?: Array<CampaignResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCartSummary {
    "content"?: Array<CartSummary>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCatalogSale {
    "content"?: Array<CatalogSale>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCategoryResource {
    "content"?: Array<CategoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventParticipantResource {
    "content"?: Array<ChallengeEventParticipantResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventResource {
    "content"?: Array<ChallengeEventResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeResource {
    "content"?: Array<ChallengeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceClientResource {
    "content"?: Array<ClientResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCommentResource {
    "content"?: Array<CommentResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceConfig {
    "content"?: Array<Config>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCountryTaxResource {
    "content"?: Array<CountryTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCurrencyResource {
    "content"?: Array<CurrencyResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDeviceResource {
    "content"?: Array<DeviceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDispositionResource {
    "content"?: Array<DispositionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceEntitlementItem {
    "content"?: Array<EntitlementItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFlagReportResource {
    "content"?: Array<FlagReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceForwardLog {
    "content"?: Array<ForwardLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFulfillmentType {
    "content"?: Array<FulfillmentType>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupMemberResource {
    "content"?: Array<GroupMemberResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupResource {
    "content"?: Array<GroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceImportJobResource {
    "content"?: Array<ImportJobResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceLogEntry {
    "content"?: Array<InvoiceLogEntry>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceResource {
    "content"?: Array<InvoiceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceItemTemplateResource {
    "content"?: Array<ItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLevelingResource {
    "content"?: Array<LevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLocationLogResource {
    "content"?: Array<LocationLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceMapstringobject {
    "content"?: Array<Mapstringobject>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceOauthAccessTokenResource {
    "content"?: Array<OauthAccessTokenResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePermissionResource {
    "content"?: Array<PermissionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePollResource {
    "content"?: Array<PollResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionResource {
    "content"?: Array<QuestionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionTemplateResource {
    "content"?: Array<QuestionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueCountryReportResource {
    "content"?: Array<RevenueCountryReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueProductReportResource {
    "content"?: Array<RevenueProductReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRewardSetResource {
    "content"?: Array<RewardSetResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRoleResource {
    "content"?: Array<RoleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSavedAddressResource {
    "content"?: Array<SavedAddressResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleUserResource {
    "content"?: Array<SimpleUserResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleWallet {
    "content"?: Array<SimpleWallet>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStateTaxResource {
    "content"?: Array<StateTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItem {
    "content"?: Array<StoreItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItemTemplateResource {
    "content"?: Array<StoreItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionResource {
    "content"?: Array<SubscriptionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionTemplateResource {
    "content"?: Array<SubscriptionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTemplateResource {
    "content"?: Array<TemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTransactionResource {
    "content"?: Array<TransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUsageInfo {
    "content"?: Array<UsageInfo>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserAchievementGroupResource {
    "content"?: Array<UserAchievementGroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserActionLog {
    "content"?: Array<UserActionLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserBaseResource {
    "content"?: Array<UserBaseResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserInventoryResource {
    "content"?: Array<UserInventoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserItemLogResource {
    "content"?: Array<UserItemLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserLevelingResource {
    "content"?: Array<UserLevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserRelationshipResource {
    "content"?: Array<UserRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVendorResource {
    "content"?: Array<VendorResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoRelationshipResource {
    "content"?: Array<VideoRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoResource {
    "content"?: Array<VideoResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTotalResponse {
    "content"?: Array<WalletTotalResponse>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTransactionResource {
    "content"?: Array<WalletTransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcestring {
    "content"?: Array<string>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PayBySavedMethodRequest {
    /**
     * The id of the payment method to use. Must belong to the caller, be public or have PAYMENTS_ADMIN permission
     */
    "paymentMethod": number;
}

export interface PaymentAuthorizationResource {
    /**
     * Whether this authorization has been captured
     */
    "captured"?: boolean;
    /**
     * The date this authorization was received, unix timestamp in seconds
     */
    "created"?: number;
    /**
     * The details for this authorization. Format dependent on payment provider
     */
    "details"?: any;
    /**
     * The id of the authorization
     */
    "id"?: number;
    /**
     * The invoice this authorization is intended to pay
     */
    "invoice"?: number;
    /**
     * The payment type (which provider) this payment is through
     */
    "paymentType": SimpleReferenceResourceint;
}

export interface PaymentMethodResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    "default"?: boolean;
    /**
     * Whether this payment method is disabled or not
     */
    "disabled"?: boolean;
    /**
     * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
     */
    "expirationDate"?: number;
    /**
     * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
     */
    "expirationMonth"?: number;
    /**
     * The expiration year for the payment method. Typically used for credit card payment methods
     */
    "expirationYear"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
     */
    "last4"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The type of payment method. Must be a pre-existing value
     */
    "paymentMethodType": PaymentMethodTypeResource;
    /**
     * The generic payment type. Default is card
     */
    "paymentType"?: PaymentMethodResourcePaymentTypeEnum;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The sort value for the payment method
     */
    "sort"?: number;
    /**
     * The unique token for the payment method
     */
    "token"?: string;
    /**
     * An optional unique identifier
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user's id. If null, indicates a shared payment method that any user can use (i.e., 'wallet')
     */
    "userId"?: number;
    "verified"?: boolean;
}

export type PaymentMethodResourcePaymentTypeEnum = "card" | "bank_account";
export interface PaymentMethodTypeResource {
    /**
     * The id of the payment method type
     */
    "id": number;
    /**
     * The name of the payment method type
     */
    "name": string;
}

export interface Permission {
    "createdDate"?: number;
    "description"?: string;
    "id"?: number;
    "locked"?: boolean;
    "name"?: string;
    "parent"?: string;
    "permission"?: string;
    "permissionRole"?: Array<Role>;
    "updatedDate"?: number;
}

export interface PermissionResource {
    /**
     * The date the permission was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The description of the permission
     */
    "description"?: string;
    /**
     * Whether a permission is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the permission used for display purposes
     */
    "name": string;
    /**
     * The name of the parent of the permission
     */
    "parent"?: string;
    /**
     * The keyword that defines the permission
     */
    "permission": string;
    /**
     * The date the permission was updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface PollAnswerResource {
    /**
     * The number of uesrs that selected this answer
     */
    "count"?: number;
    /**
     * The key to the answer (for code reference)
     */
    "key": string;
    /**
     * The text of the answer (for user display)
     */
    "text": string;
}

export interface PollResource {
    /**
     * Whether the poll is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The answers to the poll
     */
    "answers": Array<PollAnswerResource>;
    /**
     * The category for the poll
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the poll
     */
    "id"?: string;
    /**
     * The tags for the poll
     */
    "tags"?: Array<string>;
    /**
     * A poll template this poll is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The text of the poll
     */
    "text": string;
    /**
     * The media type of the poll
     */
    "type": PollResourceTypeEnum;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type PollResourceTypeEnum = "TEXT" | "IMAGE" | "VIDEO" | "AUDIO";
export interface PollResponseResource {
    /**
     * The answer to the poll
     */
    "answer": string;
    /**
     * The date the poll was answered, in seconds since unix epoc
     */
    "answeredDate"?: number;
    /**
     * The id of the poll response
     */
    "id"?: string;
    /**
     * The id of the poll
     */
    "pollId": string;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export interface PredicateOperation {
    "args"?: Array<Expressionobject>;
    "operator"?: Operator;
}

export interface Property {
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface PropertyDefinitionResource {
    /**
     * The name of the property
     */
    "name": string;
    /**
     * Whether the property is required
     */
    "required": boolean;
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface QuestionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The list of available answers
     */
    "answers"?: Array<AnswerResource>;
    /**
     * The category for the question
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The difficulty of the question
     */
    "difficulty": number;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
    /**
     * The id of the import job that created the question, or null if not from an import
     */
    "importId"?: number;
    /**
     * When the question becomes available, null for never, in seconds since epoch
     */
    "publishedDate"?: number;
    /**
     * The question. Different 'type' values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
     */
    "question": Property;
    /**
     * The first source of the question
     */
    "source1"?: string;
    /**
     * The second source of the question
     */
    "source2"?: string;
    /**
     * The list of tags
     */
    "tags"?: Array<string>;
    /**
     * A question template this question is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The supplier of the question
     */
    "vendor"?: string;
}

export interface QuestionTemplateResource {
    /**
     * A property definition for all answers. If included each answer must match this definition's type and be valid
     */
    "answerProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A property definition for the question itself. If included the answer must match this definition's type and be valid
     */
    "questionProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface RawEmailResource {
    /**
     * The body of the outgoing message.
     */
    "body": string;
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * Whether the body is to be treated as html. Default false.
     */
    "html"?: boolean;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The subject of the outgoing message.
     */
    "subject": string;
}

export interface RawSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The body of the outgoing text message.
     */
    "text": string;
}

export interface ReactivateSubscriptionRequest {
    /**
     * The inventory to reactivate. Only required if using the deprecated subscriptions service
     */
    "inventoryId"?: number;
    /**
     * Whether to add the additional reactivation fee in addition to the recurring fee
     */
    "reactivationFee"?: boolean;
}

export interface RefundRequest {
    /**
     * The amount to refund. If left off, will refund the remaining balance of the transaction or specific item balance (if SKU provided), whichever is less.
     */
    "amount"?: number;
    /**
     * Notes about or reason for the refund
     */
    "notes": string;
    /**
     * The SKU of a specific item from the invoice to refund. Affects the maximum refund amount (not to exceed the price of this item times quantity on invoice). Transaction must be tied to an invoice if used.
     */
    "sku"?: string;
}

export interface RefundResource {
    /**
     * The amount refunded
     */
    "amount"?: number;
    /**
     * The id of the refund transaction
     */
    "refundTransactionId"?: number;
    /**
     * The id of the original transaction
     */
    "transactionId"?: number;
}

export interface RevenueCountryReportResource {
    "country"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueProductReportResource {
    "itemId"?: number;
    "itemName"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueReportResource {
    "customerCount"?: number;
    "saleCount"?: number;
    "salesAverage"?: number;
    "salesTotal"?: number;
}

export interface RewardCurrencyResource {
    /**
     * The code of the currency type to give
     */
    "currencyCode": string;
    /**
     * The name of the currency reward to give.  Set by currency_code)
     */
    "currencyName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * True if the value is actually a percentage of the intake
     */
    "percent": boolean;
    /**
     * The amount of currency to give. For percentage values, 0.5 is 50%
     */
    "value": number;
}

export interface RewardItemResource {
    /**
     * The id of the item to reward
     */
    "itemId": number;
    /**
     * The name of the item to reward (read only, set by id)
     */
    "itemName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * How many copies to give
     */
    "quantity": number;
}

export interface RewardSetResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The currency to give as rewards
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * The assigned unique ID for this reward set
     */
    "id"?: number;
    /**
     * The items to give as rewards
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * A longer describe the reward set, usually included in details
     */
    "longDescription"?: string;
    /**
     * The maximum placing that will receive a reward
     */
    "maxPlacing"?: number;
    /**
     * The user friendly name for this reward set
     */
    "name": string;
    /**
     * A short paragraph to describe the reward set, usually included in listings.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A provided unique key for this reward set
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface Role {
    "clientCount"?: number;
    "createdDate"?: number;
    "id"?: number;
    "locked"?: boolean;
    "name"?: string;
    "role"?: string;
    "rolePermission"?: Array<Permission>;
    "userCount"?: number;
}

export interface RoleResource {
    /**
     * The number of clients this role is assigned to
     */
    "clientCount"?: number;
    /**
     * The date the role was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether a role is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the role used for display purposes
     */
    "name": string;
    /**
     * The keyword that defines the role
     */
    "role": string;
    /**
     * The list of permissions this role has
     */
    "rolePermission"?: Array<PermissionResource>;
    /**
     * The number of users this role is assigned to
     */
    "userCount"?: number;
}

export interface SampleCountriesResponse {
    "vendorId1"?: Array<Country>;
    "vendorId2"?: Array<Country>;
}

export interface SavedAddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    "default"?: boolean;
    /**
     * The first name of the user
     */
    "firstName": string;
    /**
     * The id of the address
     */
    "id"?: number;
    /**
     * The last name of the user
     */
    "lastName": string;
    /**
     * The name of the address
     */
    "name": string;
    /**
     * The first phone number of the user
     */
    "phone1"?: string;
    /**
     * The second phone number of the user
     */
    "phone2"?: string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface Schedule {
    /**
     * The duration of the repeatable events
     */
    "duration": number;
    /**
     * The unit of time for the duration field
     */
    "durationUnit": ScheduleDurationUnitEnum;
    /**
     * How often the event is scheduled
     */
    "repeat": ScheduleRepeatEnum;
}

export type ScheduleDurationUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type ScheduleRepeatEnum = "DAILY" | "WEEKLY";
export interface SearchReferenceMapping {
    /**
     * Unique identifier for the mapping to protect against duplicates
     */
    "id": string;
    /**
     * The field within the type that contains the id from the refType
     */
    "refIdField": string;
    /**
     * The index type that the mapping pulls data from
     */
    "refType": string;
    /**
     * A map whose keys are the field names in the refType and values are the field name in the type
     */
    "sourceFieldToDestinationField": { [key: string]: string; };
    /**
     * The index type that the mapping is for
     */
    "type": string;
}

export interface SelectedSettingResource {
    /**
     * The unique ID for the setting
     */
    "key": string;
    /**
     * The textual name of the setting
     */
    "keyName": string;
    /**
     * The unique ID for the option
     */
    "value": string;
    /**
     * The textual name of the option
     */
    "valueName": string;
}

export interface SettingOption {
    /**
     * The textual name of the option
     */
    "name": string;
    /**
     * The unique ID for the option
     */
    "value"?: string;
}

export interface ShippingItem {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * A unique list of country iso3 codes that allow the shipping option
     */
    "countries"?: Array<string>;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether or not the item is currently displayable.  Default = true
     */
    "displayable"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: ShippingItemGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * An abstract max value that the values of item's shipping_tier work against to decide whether an order can be fulfilled
     */
    "maxTierTotal": number;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * Whether tax should be applied to the shipping price.  Default = false
     */
    "taxable"?: boolean;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type ShippingItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface SimpleReferenceResourceint {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcelong {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcestring {
    /**
     * The id of the referenced object
     */
    "id": string;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleUserResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface SimpleWallet {
    /**
     * The current balance of the wallet
     */
    "balance"?: number;
    /**
     * The ISO currency code for the wallet
     */
    "code"?: string;
    /**
     * The name of the currency stored in the wallet
     */
    "currencyName"?: string;
    /**
     * The unique ID of the wallet
     */
    "id"?: number;
    /**
     * The ID of the user to whom the wallet belongs
     */
    "userId"?: number;
}

export interface Sku {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The currency code for the SKU, a three letter string (ISO3)
     */
    "currencyCode": string;
    /**
     * The description of the SKU (Ex: An item comes in multiple sizes/colors, each needing its own unique description)
     */
    "description"?: string;
    /**
     * The number of SKUs currently in stock
     */
    "inventory"?: number;
    /**
     * Alerts vendor when SKU inventory drops below this value
     */
    "minInventoryThreshold"?: number;
    /**
     * The base price before any sale
     */
    "originalPrice": number;
    /**
     * The current price of the SKU with sales, if any. Set original_price for the base
     */
    "price"?: number;
    /**
     * Whether or not the SKU is currently published
     */
    "published"?: boolean;
    /**
     * The id of a sale affecting the price, if any
     */
    "saleId"?: number;
    /**
     * The name of a sale affecting the price, if any
     */
    "saleName"?: string;
    /**
     * The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters
     */
    "sku": string;
    /**
     * The date the sku becomes available, unix timestamp in seconds.  If set to null, sku will become available immediately
     */
    "startDate"?: number;
    /**
     * The date the sku becomes unavailable, unix timestamp in seconds.  If set to null, sku is always available
     */
    "stopDate"?: number;
}

export interface SkuRequest {
    /**
     * SKU code of the item
     */
    "sku": string;
}

export interface StateResource {
    /**
     * The code of the state
     */
    "code"?: string;
    /**
     * The iso3 of the country this state is in
     */
    "countryCodeIso3"?: string;
    /**
     * The unique ID for the state
     */
    "id"?: number;
    /**
     * The name of the state
     */
    "name"?: string;
}

export interface StateTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * Whether the state is exempt from paying the country tax
     */
    "federallyExempt": boolean;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * The code of the state, cannot be changed
     */
    "stateCode": string;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface StoreItem {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether or not the item is currently displayable.  Default = true
     */
    "displayable"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: StoreItemGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type StoreItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface StoreItemTemplateResource {
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A template to apply to all skus on an item using this template
     */
    "skuTemplate"?: TemplateResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface StripeCreatePaymentMethod {
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
    /**
     * The id of the user, if null the logged in user is used. Admin privilege need to specify other users
     */
    "userId"?: number;
}

export interface StripePaymentRequest {
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
}

export interface SubscriptionCreditResource {
    /**
     * The amount of the credit, negative for debt
     */
    "amount": number;
    /**
     * The date this credit was added, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the credit record
     */
    "id"?: number;
    /**
     * The id of the subscription inventory entry
     */
    "inventoryId"?: number;
    /**
     * The reason for the subscription credit
     */
    "reason": string;
}

export interface SubscriptionPlanResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The length of the billing cycle in number of billing cycle unit
     */
    "billingCycleLength": number;
    /**
     * The time period unit to apply to the length of billing cycles
     */
    "billingCycleUnit": SubscriptionPlanResourceBillingCycleUnitEnum;
    /**
     * Whether this plan will be renewed on the consolidated billing cycle
     */
    "consolidated": boolean;
    /**
     * The ISO3 currency code to use for the fees
     */
    "currencyCode": string;
    /**
     * Used to schedule plan availability end date
     */
    "endDate"?: number;
    /**
     * Optional override for the length of the first billing cycle before the first recurring billing
     */
    "firstBillingCycleLength"?: number;
    /**
     * The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified
     */
    "firstBillingCycleUnit"?: SubscriptionPlanResourceFirstBillingCycleUnitEnum;
    /**
     * The number of late payment days before a subscription is canceled
     */
    "gracePeriod": number;
    /**
     * The id of the plan used to generate the SKUs
     */
    "id"?: string;
    /**
     * The fee charged when the subscription is purchased
     */
    "initialFee": number;
    /**
     * The SKU to be used when purchasing the subscription through the cart
     */
    "initialSku"?: string;
    /**
     * The fee to add to the bill when an invoice has gone unpaid passed the grace period
     */
    "latePaymentFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is delinquent
     */
    "latePaymentSku"?: string;
    /**
     * Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed
     */
    "locked"?: boolean;
    /**
     * The number of charge attempts before the subscription becomes delinquent
     */
    "maxBillAttempts": number;
    /**
     * Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached
     */
    "maxCycles"?: number;
    /**
     * Automatically migrate to the specified plan when the subscription is first renewed
     */
    "migrateToPlan"?: string;
    /**
     * The minimum number of renewals to charge for
     */
    "minCycles"?: number;
    /**
     * The name of the plan used to generate the SKUs
     */
    "name": string;
    /**
     * Whether this plan is currently available
     */
    "published": boolean;
    /**
     * The fee to charge when a suspended subscription is to be re-activated
     */
    "reactivationFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is re-activated after a suspension
     */
    "reactivationSku"?: string;
    /**
     * The recurring fee to charge for each renewal
     */
    "recurringFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is activated
     */
    "recurringSku"?: string;
    /**
     * Used to schedule plan availability start date
     */
    "startDate"?: number;
}

export type SubscriptionPlanResourceBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type SubscriptionPlanResourceFirstBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export interface SubscriptionResource {
    /**
     * A map of item additional properties, keyed on the property name. Must match the names and types defined in the template for this item type.
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * Who can purchase this subscription
     */
    "availability"?: SubscriptionResourceAvailabilityEnum;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The day of the month 1..31 this subscription will renew
     */
    "consolidationDayOfMonth"?: number;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A list of country iso3 codes to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: SubscriptionResourceGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the subscription
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * The billing options for this subscription
     */
    "plans"?: Array<SubscriptionPlanResource>;
    /**
     * A short description of the subscription.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * Used to schedule removal from store.  Null means the subscription will never be removed
     */
    "storeEnd"?: number;
    /**
     * Used to schedule appearance in store.  Null means the subscription will appear now
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against. May be null and no validation of additional properties will be done.
     */
    "template"?: string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated
     */
    "updatedDate"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type SubscriptionResourceAvailabilityEnum = "all" | "new_subscribers";
export type SubscriptionResourceGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface SubscriptionTemplateResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * A template to apply to all plans on a subscription using this template
     */
    "planTemplate"?: TemplateResource;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateEmailResource {
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The key for the template
     */
    "templateKey": string;
    /**
     * A list of variables to fill in the template
     */
    "templateVars"?: Array<KeyValuePairstringstring>;
}

export interface TemplateResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    "localizer"?: Localizer;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The key for the template.
     */
    "templateKey": string;
    /**
     * A list of values to fill in the template. Order matters.
     */
    "templateVars"?: Array<string>;
}

export interface TierResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The name of the tier
     */
    "name"?: string;
    /**
     * The required progress for the tier
     */
    "requiredProgress": number;
    /**
     * The name of the triggered event
     */
    "triggerEventName"?: string;
}

export interface Timezone {
    "code"?: string;
    "id"?: number;
    "name"?: string;
    "offset"?: number;
}

export interface TokenDetailsResource {
    "roles"?: Array<string>;
    "userId"?: number;
}

export interface TransactionResource {
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: TransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
}

export type TransactionResourceSourceEnum = "digital" | "physical";
export interface UsageInfo {
    /**
     * The number of requests within the range
     */
    "count"?: number;
    /**
     * The date at the start of the range (see granularity)
     */
    "date"?: number;
    /**
     * The http method
     */
    "method"?: string;
    /**
     * The url path
     */
    "url"?: string;
}

export interface User {
    "additionalProperties"?: { [key: string]: Property; };
    "address"?: string;
    "address2"?: string;
    "affiliate"?: Affiliate;
    "avatarUrl"?: string;
    "children"?: Array<UserRelationship>;
    "city"?: string;
    "country"?: Country;
    "currency"?: Currency;
    "dateCreated"?: number;
    "dateOfBirth"?: number;
    "dateUpdated"?: number;
    "description"?: string;
    "displayName"?: string;
    "email"?: string;
    "firstName"?: string;
    "fullname"?: string;
    "gender"?: string;
    "groups"?: Array<GroupMember>;
    "guest"?: boolean;
    "id"?: number;
    "inviteToken"?: string;
    "lang"?: Language;
    "lastActivity"?: number;
    "lastLogin"?: number;
    "lastName"?: string;
    "lockoutAttempts"?: number;
    "lockoutDate"?: number;
    "mobileNumber"?: string;
    "oldId"?: number;
    "parents"?: Array<UserRelationship>;
    "password"?: string;
    "postalCode"?: string;
    "propertiesString"?: string;
    "roles"?: Array<Role>;
    "state"?: string;
    "status"?: string;
    "tagStrings"?: Array<string>;
    "tags"?: Array<UserTag>;
    "template"?: string;
    "timezone"?: Timezone;
    "token"?: string;
    "typeHint"?: string;
    "username"?: string;
}

export interface UserAchievementGroupResource {
    /**
     * The list of achievements associated with the group
     */
    "achievements": Array<UserAchievementResource>;
    /**
     * The name of the group.  If used by Leveling, this will represent the level name
     */
    "groupName": string;
    /**
     * The id of the achievement progress
     */
    "id"?: string;
    /**
     * The current progress of the user on the group
     */
    "progress": number;
    /**
     * The id of the user whose progress is being tracked
     */
    "userId": number;
}

export interface UserAchievementResource {
    /**
     * Flag indicating whether the user has earned the achievement
     */
    "achieved"?: boolean;
    /**
     * The achievement being tracked.  If used for Leveling, this represents the tier name
     */
    "achievementName": string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The date/time the achievement was earned as a unix timestamp in seconds
     */
    "earnedDate"?: number;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface UserActionLog {
    /**
     * A description of the action taken
     */
    "actionDescription": string;
    /**
     * The name of the action taken
     */
    "actionName": string;
    /**
     * The date of the action, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A map of additional details such as the target of the action
     */
    "details"?: { [key: string]: string; };
    /**
     * The id of the log entry
     */
    "id"?: string;
    /**
     * The id of the api request that spawned the action, if generated internally
     */
    "requestId"?: string;
    /**
     * The id of the user that took the action, if any. Read-only if not posting with LOGS_ADMIN
     */
    "userId"?: number;
}

export interface UserActivityResultsResource {
    /**
     * Any currency rewarded to this user
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * Any items rewarded to this user
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The number of users tied at this rank, including this user. 1 means no tie
     */
    "ties"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface UserBaseResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

export interface UserInventoryAddRequest {
    /**
     * A note to be passed to the invoice or transaction
     */
    "note": string;
    /**
     * A list of behaviors to ignore explicitely.  Ex: 'limited_gettable'
     */
    "overrides"?: Array<string>;
    /**
     * If set to true will cause the endpoint to skip creation of cart and invoice to track the inventory change
     */
    "skipInvoice": boolean;
    /**
     * The specific SKU of the item to be added to the inventory
     */
    "sku": string;
}

export interface UserInventoryResource {
    /**
     * A map of data for behaviors
     */
    "behaviorData"?: any;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The date/time this resource exires in seconds since epoch. Null for no expiration. For subscriptions, this is the end of the 'grace period' if left unpaid
     */
    "expires"?: number;
    /**
     * The id of the inventory
     */
    "id"?: number;
    /**
     * The id of the invoice that resulted in this inventory, if any
     */
    "invoiceId"?: number;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The name of the item
     */
    "itemName"?: string;
    /**
     * The type hint of the item
     */
    "itemTypeHint"?: string;
    /**
     * The status of the inventory. Pending inventory is not yet ready for use. Inactive inventory has expired or been used up
     */
    "status"?: UserInventoryResourceStatusEnum;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The id of the user this inventory belongs to
     */
    "user"?: SimpleUserResource;
}

export type UserInventoryResourceStatusEnum = "pending" | "active" | "inactive";
export interface UserItemLogResource {
    /**
     * The log entry id
     */
    "id"?: number;
    /**
     * Additional information defined by the type
     */
    "info"?: string;
    /**
     * The item interacted with
     */
    "item"?: SimpleReferenceResourceint;
    /**
     * The date/time this event occurred in seconds since epoch
     */
    "logDate"?: number;
    /**
     * The type of event
     */
    "type"?: string;
    /**
     * The user making the interaction
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the inventory entry this event is related to, if any
     */
    "userInventory"?: number;
}

export interface UserLevelingResource {
    /**
     * The name of the last tier the user has qualified for
     */
    "lastTierName": string;
    /**
     * The progress level of the last tier the user has qualified for
     */
    "lastTierProgress": number;
    /**
     * The name of the level schema
     */
    "levelName": string;
    /**
     * The name of the next tier the user can qualify for
     */
    "nextTierName": string;
    /**
     * The progress needed to qualify for the next tier
     */
    "nextTierProgress": number;
    /**
     * The amount of progress the user has
     */
    "progress": number;
    /**
     * The names of the tiers the user has qualified for
     */
    "tierNames": Array<string>;
    /**
     * The ID of the user
     */
    "userId": number;
}

export interface UserRelationship {
    "child"?: User;
    "context"?: string;
    "id"?: number;
    "parent"?: User;
}

export interface UserRelationshipReferenceResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The context of the relationship
     */
    "context"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The id of the relationship
     */
    "relationshipId"?: number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface UserRelationshipResource {
    /**
     * The child in the relationship
     */
    "child": SimpleUserResource;
    /**
     * Context about the relationship or its type
     */
    "context"?: string;
    /**
     * A generated unique id. Read-Only
     */
    "id"?: number;
    /**
     * The parent in the relationship
     */
    "parent": SimpleUserResource;
}

export interface UserResource {
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The first line of the user's address (private)
     */
    "address"?: string;
    /**
     * The second line of user's address (private)
     */
    "address2"?: string;
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * Relationships where this user is the parent. Read-Only, manage through separate endpoints
     */
    "children"?: Array<UserRelationshipReferenceResource>;
    /**
     * The user's city (private)
     */
    "city"?: string;
    /**
     * The ISO3 code for the country from the user's address (private). Will be filled in based on GeoIP country at registration if not provided.
     */
    "countryCode"?: string;
    /**
     * The code for the user's real money currency (private)
     */
    "currencyCode"?: string;
    /**
     * The user's date of birth (private) as a unix timestamp
     */
    "dateOfBirth"?: number;
    /**
     * The user's self description (private)
     */
    "description"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's first name (private)
     */
    "firstName"?: string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The user's gender (private)
     */
    "gender"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The ISO3 code for the user's currency (private)
     */
    "languageCode"?: string;
    /**
     * The user's last name (private)
     */
    "lastName"?: string;
    /**
     * The user's mobile phone number (private)
     */
    "mobileNumber"?: string;
    /**
     * Relationships where this user is the child. Read-Only, manage through separate endpoints
     */
    "parents"?: Array<UserRelationshipReferenceResource>;
    /**
     * The plain text password for the new user account. Required for registration; ignored on profile update.  Use password specific endpoints for editing
     */
    "password"?: string;
    /**
     * The user's postal code (private)
     */
    "postalCode"?: string;
    /**
     * The user's state (private)
     */
    "state"?: string;
    /**
     * Tags on the user. Can only be set by admin. Max length per tag is 64 characters
     */
    "tags"?: Array<string>;
    /**
     * A user template this user is validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The code for the user's timezone (private)
     */
    "timezoneCode"?: string;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

export interface UserTag {
    "id"?: number;
    "tag"?: string;
    "user"?: User;
}

export interface VariableTypeResource {
    /**
     * The base class of the type
     */
    "base": VariableTypeResourceBaseEnum;
    /**
     * The name of the variable type. Used as the unique id
     */
    "name": string;
}

export type VariableTypeResourceBaseEnum = "NUMBER" | "INTEGER" | "STRING" | "DATE" | "BOOLEAN";
export interface VendorResource {
    /**
     * Whether the vendor is active.  Default = true
     */
    "active"?: boolean;
    /**
     * The date the vendor was added. Unix timestamp in seconds
     */
    "createDate"?: number;
    /**
     * A description of the vendor
     */
    "description"?: string;
    /**
     * The id of the vendor
     */
    "id"?: number;
    /**
     * The url of an image for the vendor
     */
    "imageUrl"?: string;
    /**
     * Whether the vendor needs to manually approve invoices before they are paid.  A separate checkout flow is required in this case.  Default: false
     */
    "manualApproval"?: boolean;
    /**
     * The name of the vendor
     */
    "name": string;
    /**
     * The primary email address for the vendor
     */
    "primaryContactEmail"?: string;
    /**
     * The name of the primary contact for the vendor
     */
    "primaryContactName"?: string;
    /**
     * The primary phone number for the vendor
     */
    "primaryContactPhone"?: string;
    /**
     * The email address for sale inquiries for the vendor
     */
    "salesEmail"?: string;
    /**
     * The email address for support inquiries for the vendor
     */
    "supportEmail"?: string;
    /**
     * The date the vendor was last updated. Unix timestamp in seconds
     */
    "updateDate"?: number;
    /**
     * The url for the vendor's site
     */
    "url"?: string;
}

export interface Version {
    "version"?: string;
}

export interface Video {
    "active"?: boolean;
    "author"?: Artist;
    "authored"?: number;
    "banned"?: boolean;
    "categoryId"?: string;
    "categoryName"?: string;
    "contributors"?: CollectionVideoContribution;
    "created"?: number;
    "embed"?: string;
    "extension"?: string;
    "height"?: number;
    "id"?: number;
    "length"?: number;
    "location"?: string;
    "longDescription"?: string;
    "mimeType"?: string;
    "name"?: string;
    "priority"?: number;
    "privacy"?: VideoPrivacyEnum;
    "published"?: boolean;
    "shortDescription"?: string;
    "size"?: number;
    "tags"?: Array<VideoTag>;
    "thumbnail"?: string;
    "updated"?: number;
    "uploader"?: User;
    "views"?: number;
    "whitelist"?: Array<User>;
    "width"?: number;
}

export type VideoPrivacyEnum = "private" | "friends" | "public";
export interface VideoContribution {
    "artist"?: Artist;
    "id"?: number;
    "media"?: Video;
    "role"?: string;
}

export interface VideoRelationshipResource {
    /**
     * The owner of the relationship
     */
    "from"?: SimpleReferenceResourcelong;
    /**
     * The id of the relationship
     */
    "id"?: number;
    /**
     * Details about the relationship such as type or other information. Max length 10 characters
     */
    "relationshipDetails": string;
    /**
     * The target of the relationship.
     */
    "to": SimpleReferenceResourcelong;
}

export interface VideoResource {
    /**
     * Whether the video is available, based on various factors
     */
    "active"?: boolean;
    /**
     * The original artist of the media
     */
    "author"?: SimpleReferenceResourcelong;
    /**
     * The date the media was created as a unix timestamp in seconds
     */
    "authored"?: number;
    /**
     * Whether the video has been banned or not
     */
    "banned"?: boolean;
    /**
     * The category of the video
     */
    "category": SimpleReferenceResourcestring;
    /**
     * The comments of the video
     */
    "comments"?: Array<CommentResource>;
    /**
     * Artists that contributed to the creation. See separate endpoint to add to list
     */
    "contributors"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The country of an embedable version
     */
    "embed"?: string;
    /**
     * The file extension of the media file. 1-5 characters
     */
    "extension": string;
    /**
     * The height of the video in px
     */
    "height": number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The length of the video in seconds
     */
    "length": number;
    /**
     * The country of the media. Typically a url. Cannot be blank
     */
    "location": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The mime-type of the media
     */
    "mimeType"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order of the video. default: 100
     */
    "priority"?: number;
    /**
     * The privacy setting. default: private
     */
    "privacy"?: VideoResourcePrivacyEnum;
    /**
     * Whether the video has been made public. Default true
     */
    "published"?: boolean;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The size of the media. Minimum 0 if supplied
     */
    "size"?: number;
    /**
     * The tags for the video
     */
    "tags"?: Array<string>;
    /**
     * The country of a thumbnail version. Typically a url
     */
    "thumbnail"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user the media was uploaded by. May be null for system uploaded media. May only be set to a user other than the current caller if VIDEOS_ADMIN permission. Null will mean the caller is the uploader unless the caller has VIDEOS_ADMIN permission, in which case it will be set to null
     */
    "uploader"?: SimpleUserResource;
    /**
     * The view count of the video
     */
    "views"?: number;
    /**
     * The width of the video in px
     */
    "width": number;
}

export type VideoResourcePrivacyEnum = "private" | "friends" | "public";
export interface VideoTag {
    "id"?: number;
    "tag"?: string;
    "video"?: Video;
}

export interface WalletAlterRequest {
    /**
     * The amount of currency to add/remove. positive to add, negative to remove
     */
    "delta": number;
    /**
     * The id of an invoice to attribute the transaction to
     */
    "invoiceId"?: number;
    /**
     * The admin entered or system generated reason
     */
    "reason": string;
    /**
     * The transaction type to allow for search/etc
     */
    "type"?: string;
}

export interface WalletTotalResponse {
    /**
     * The currency code
     */
    "currencyCode"?: string;
    /**
     * The sum of all wallets in the system for this currency
     */
    "total"?: number;
}

export interface WalletTransactionResource {
    /**
     * The new balance of the wallet after the transaction
     */
    "balance"?: number;
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: WalletTransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The owner of the wallet
     */
    "user"?: SimpleUserResource;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
    /**
     * The id of the wallet this transaction affected
     */
    "walletId"?: number;
}

export type WalletTransactionResourceSourceEnum = "digital" | "physical";
export interface XsollaPaymentRequest {
    /**
     * The id of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL xsolla should forward the user to after they pay
     */
    "returnUrl": string;
}



/**
 * AWSS3Api - fetch parameter creator
 */
export const AWSS3ApiFetchParamCreator = {
    /** 
     * Get a signed S3 URL
     * Requires the file name and file content type (i.e., &#39;video/mpeg&#39;)
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  "filename"?: string; "contentType"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/amazon/s3/signedposturl`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filename": params["filename"],
            "content_type": params["contentType"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AWSS3Api - functional programming interface
 */
export const AWSS3ApiFp = {
    /** 
     * Get a signed S3 URL
     * Requires the file name and file content type (i.e., &#39;video/mpeg&#39;)
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: { "filename"?: string; "contentType"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AmazonS3Activity> {
        const fetchArgs = AWSS3ApiFetchParamCreator.getSignedS3URL(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AWSS3Api - object-oriented interface
 */
export class AWSS3Api extends BaseAPI {
    /** 
     * Get a signed S3 URL
     * Requires the file name and file content type (i.e., &#39;video/mpeg&#39;)
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  "filename"?: string; "contentType"?: string; }, options?: any) {
        return AWSS3ApiFp.getSignedS3URL(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AWSS3Api - factory interface
 */
export const AWSS3ApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a signed S3 URL
         * Requires the file name and file content type (i.e., &#39;video/mpeg&#39;)
         * @param filename The file name
         * @param contentType The content type
         */
        getSignedS3URL(params: {  "filename"?: string; "contentType"?: string; }, options?: any) {
            return AWSS3ApiFp.getSignedS3URL(params, options)(fetch, basePath);
        },
    };
};


/**
 * ActivitiesApi - fetch parameter creator
 */
export const ActivitiesApiFetchParamCreator = {
    /** 
     * Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  "activityResource"?: ActivityResource; }, options?: any): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a new activity occurrence
     * Has to enforce extra rules if not used as an admin
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  "test"?: boolean; "activityOccurrenceResource"?: ActivityOccurrenceResource; }, options?: any): FetchArgs {
        const baseUrl = `/activity-occurrences`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "test": params["test"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResource"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  "filterTemplate"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_template": params["filterTemplate"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  "activityOccurrenceId": number; "activityOccurrenceResults"?: ActivityOccurrenceResults; }, options?: any): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling setActivityOccurrenceResults");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/results`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResults"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResults"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  "id": number; "activityResource"?: ActivityResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updated the status of an activity occurrence
     * If setting to &#39;FINISHED&#39; you must POST to /results instead to record the metrics and get synchronous reward results
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: {  "activityOccurrenceId": number; "activityCccurrenceStatus"?: string; }, options?: any): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling updateActivityOccurrence");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/status`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityCccurrenceStatus"]) {
            fetchOptions.body = JSON.stringify(params["activityCccurrenceStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ActivitiesApi - functional programming interface
 */
export const ActivitiesApiFp = {
    /** 
     * Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: { "activityResource"?: ActivityResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a new activity occurrence
     * Has to enforce extra rules if not used as an admin
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: { "test"?: boolean; "activityOccurrenceResource"?: ActivityOccurrenceResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivityOccurrence(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.deleteActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: { "filterTemplate"?: boolean; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBareActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivities(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: { "activityOccurrenceId": number; "activityOccurrenceResults"?: ActivityOccurrenceResults;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResults> {
        const fetchArgs = ActivitiesApiFetchParamCreator.setActivityOccurrenceResults(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: { "id": number; "activityResource"?: ActivityResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updated the status of an activity occurrence
     * If setting to &#39;FINISHED&#39; you must POST to /results instead to record the metrics and get synchronous reward results
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: { "activityOccurrenceId": number; "activityCccurrenceStatus"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivityOccurrence(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ActivitiesApi - object-oriented interface
 */
export class ActivitiesApi extends BaseAPI {
    /** 
     * Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  "activityResource"?: ActivityResource; }, options?: any) {
        return ActivitiesApiFp.createActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a new activity occurrence
     * Has to enforce extra rules if not used as an admin
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  "test"?: boolean; "activityOccurrenceResource"?: ActivityOccurrenceResource; }, options?: any) {
        return ActivitiesApiFp.createActivityOccurrence(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  "id": number; }, options?: any) {
        return ActivitiesApiFp.deleteActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  "filterTemplate"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ActivitiesApiFp.getActivities(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  "id": number; }, options?: any) {
        return ActivitiesApiFp.getActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  "activityOccurrenceId": number; "activityOccurrenceResults"?: ActivityOccurrenceResults; }, options?: any) {
        return ActivitiesApiFp.setActivityOccurrenceResults(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  "id": number; "activityResource"?: ActivityResource; }, options?: any) {
        return ActivitiesApiFp.updateActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updated the status of an activity occurrence
     * If setting to &#39;FINISHED&#39; you must POST to /results instead to record the metrics and get synchronous reward results
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: {  "activityOccurrenceId": number; "activityCccurrenceStatus"?: string; }, options?: any) {
        return ActivitiesApiFp.updateActivityOccurrence(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ActivitiesApi - factory interface
 */
export const ActivitiesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create an activity
         * @param activityResource The activity resource object
         */
        createActivity(params: {  "activityResource"?: ActivityResource; }, options?: any) {
            return ActivitiesApiFp.createActivity(params, options)(fetch, basePath);
        },
        /** 
         * Create a new activity occurrence
         * Has to enforce extra rules if not used as an admin
         * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
         * @param activityOccurrenceResource The activity occurrence object
         */
        createActivityOccurrence(params: {  "test"?: boolean; "activityOccurrenceResource"?: ActivityOccurrenceResource; }, options?: any) {
            return ActivitiesApiFp.createActivityOccurrence(params, options)(fetch, basePath);
        },
        /** 
         * Delete an activity
         * @param id The id of the activity
         */
        deleteActivity(params: {  "id": number; }, options?: any) {
            return ActivitiesApiFp.deleteActivity(params, options)(fetch, basePath);
        },
        /** 
         * List activity definitions
         * @param filterTemplate Filter for activities that are templates, or specifically not if false
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getActivities(params: {  "filterTemplate"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ActivitiesApiFp.getActivities(params, options)(fetch, basePath);
        },
        /** 
         * Get a single activity
         * @param id The id of the activity
         */
        getActivity(params: {  "id": number; }, options?: any) {
            return ActivitiesApiFp.getActivity(params, options)(fetch, basePath);
        },
        /** 
         * Sets the status of an activity occurrence to FINISHED and logs metrics
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityOccurrenceResults The activity occurrence object
         */
        setActivityOccurrenceResults(params: {  "activityOccurrenceId": number; "activityOccurrenceResults"?: ActivityOccurrenceResults; }, options?: any) {
            return ActivitiesApiFp.setActivityOccurrenceResults(params, options)(fetch, basePath);
        },
        /** 
         * Update an activity
         * @param id The id of the activity
         * @param activityResource The activity resource object
         */
        updateActivity(params: {  "id": number; "activityResource"?: ActivityResource; }, options?: any) {
            return ActivitiesApiFp.updateActivity(params, options)(fetch, basePath);
        },
        /** 
         * Updated the status of an activity occurrence
         * If setting to &#39;FINISHED&#39; you must POST to /results instead to record the metrics and get synchronous reward results
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityCccurrenceStatus The activity occurrence status object
         */
        updateActivityOccurrence(params: {  "activityOccurrenceId": number; "activityCccurrenceStatus"?: string; }, options?: any) {
            return ActivitiesApiFp.updateActivityOccurrence(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthClientsApi - fetch parameter creator
 */
export const AuthClientsApiFetchParamCreator = {
    /** 
     * Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  "clientResource"?: ClientResource; }, options?: any): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  "clientKey": string; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling deleteClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  "clientKey": string; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List available client grant types
     */
    getClientGrantTypes(options?: any): FetchArgs {
        const baseUrl = `/auth/clients/grant-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  "clientKey": string; "grantList"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientGrantTypes");
        }
        const baseUrl = `/auth/clients/{client_key}/grant-types`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantList"]) {
            fetchOptions.body = JSON.stringify(params["grantList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  "clientKey": string; "redirectList"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRedirectUris");
        }
        const baseUrl = `/auth/clients/{client_key}/redirect-uris`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redirectList"]) {
            fetchOptions.body = JSON.stringify(params["redirectList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  "clientKey": string; "clientResource"?: ClientResource; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling updateClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthClientsApi - functional programming interface
 */
export const AuthClientsApiFp = {
    /** 
     * Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: { "clientResource"?: ClientResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.createClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: { "clientKey": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.deleteClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: { "clientKey": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List available client grant types
     */
    getClientGrantTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GrantTypeResource>> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClientGrantTypes(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClients(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: { "clientKey": string; "grantList"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.setClientGrantTypes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: { "clientKey": string; "redirectList"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.setClientRedirectUris(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: { "clientKey": string; "clientResource"?: ClientResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.updateClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthClientsApi - object-oriented interface
 */
export class AuthClientsApi extends BaseAPI {
    /** 
     * Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  "clientResource"?: ClientResource; }, options?: any) {
        return AuthClientsApiFp.createClient(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  "clientKey": string; }, options?: any) {
        return AuthClientsApiFp.deleteClient(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  "clientKey": string; }, options?: any) {
        return AuthClientsApiFp.getClient(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List available client grant types
     */
    getClientGrantTypes(options?: any) {
        return AuthClientsApiFp.getClientGrantTypes(options)(this.fetch, this.basePath);
    }
    /** 
     * List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return AuthClientsApiFp.getClients(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  "clientKey": string; "grantList"?: Array<string>; }, options?: any) {
        return AuthClientsApiFp.setClientGrantTypes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  "clientKey": string; "redirectList"?: Array<string>; }, options?: any) {
        return AuthClientsApiFp.setClientRedirectUris(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  "clientKey": string; "clientResource"?: ClientResource; }, options?: any) {
        return AuthClientsApiFp.updateClient(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthClientsApi - factory interface
 */
export const AuthClientsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new client
         * @param clientResource The client resource object
         */
        createClient(params: {  "clientResource"?: ClientResource; }, options?: any) {
            return AuthClientsApiFp.createClient(params, options)(fetch, basePath);
        },
        /** 
         * Delete a client
         * @param clientKey The key of the client
         */
        deleteClient(params: {  "clientKey": string; }, options?: any) {
            return AuthClientsApiFp.deleteClient(params, options)(fetch, basePath);
        },
        /** 
         * Get a single client
         * @param clientKey The key of the client
         */
        getClient(params: {  "clientKey": string; }, options?: any) {
            return AuthClientsApiFp.getClient(params, options)(fetch, basePath);
        },
        /** 
         * List available client grant types
         */
        getClientGrantTypes(options?: any) {
            return AuthClientsApiFp.getClientGrantTypes(options)(fetch, basePath);
        },
        /** 
         * List and search clients
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getClients(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return AuthClientsApiFp.getClients(params, options)(fetch, basePath);
        },
        /** 
         * Set grant types for a client
         * @param clientKey The key of the client
         * @param grantList A list of unique grant types
         */
        setClientGrantTypes(params: {  "clientKey": string; "grantList"?: Array<string>; }, options?: any) {
            return AuthClientsApiFp.setClientGrantTypes(params, options)(fetch, basePath);
        },
        /** 
         * Set redirect uris for a client
         * @param clientKey The key of the client
         * @param redirectList A list of unique redirect uris
         */
        setClientRedirectUris(params: {  "clientKey": string; "redirectList"?: Array<string>; }, options?: any) {
            return AuthClientsApiFp.setClientRedirectUris(params, options)(fetch, basePath);
        },
        /** 
         * Update a client
         * @param clientKey The key of the client
         * @param clientResource The client resource object
         */
        updateClient(params: {  "clientKey": string; "clientResource"?: ClientResource; }, options?: any) {
            return AuthClientsApiFp.updateClient(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthPermissionsApi - fetch parameter creator
 */
export const AuthPermissionsApiFetchParamCreator = {
    /** 
     * Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  "permissionResource"?: PermissionResource; }, options?: any): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  "permission": string; "force"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling deletePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "force": params["force"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  "permission": string; }, options?: any): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling getPermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  "permission": string; "permissionResource"?: PermissionResource; }, options?: any): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling updatePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthPermissionsApi - functional programming interface
 */
export const AuthPermissionsApiFp = {
    /** 
     * Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: { "permissionResource"?: PermissionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.createPermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: { "permission": string; "force"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.deletePermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single permission
     * @param permission The permission value
     */
    getPermission(params: { "permission": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.getPermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourcePermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.getPermissions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: { "permission": string; "permissionResource"?: PermissionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.updatePermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthPermissionsApi - object-oriented interface
 */
export class AuthPermissionsApi extends BaseAPI {
    /** 
     * Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  "permissionResource"?: PermissionResource; }, options?: any) {
        return AuthPermissionsApiFp.createPermission(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  "permission": string; "force"?: boolean; }, options?: any) {
        return AuthPermissionsApiFp.deletePermission(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  "permission": string; }, options?: any) {
        return AuthPermissionsApiFp.getPermission(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return AuthPermissionsApiFp.getPermissions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  "permission": string; "permissionResource"?: PermissionResource; }, options?: any) {
        return AuthPermissionsApiFp.updatePermission(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthPermissionsApi - factory interface
 */
export const AuthPermissionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new permission
         * @param permissionResource The permission resource object
         */
        createPermission(params: {  "permissionResource"?: PermissionResource; }, options?: any) {
            return AuthPermissionsApiFp.createPermission(params, options)(fetch, basePath);
        },
        /** 
         * Delete a permission
         * @param permission The permission value
         * @param force If true, removes permission assigned to roles
         */
        deletePermission(params: {  "permission": string; "force"?: boolean; }, options?: any) {
            return AuthPermissionsApiFp.deletePermission(params, options)(fetch, basePath);
        },
        /** 
         * Get a single permission
         * @param permission The permission value
         */
        getPermission(params: {  "permission": string; }, options?: any) {
            return AuthPermissionsApiFp.getPermission(params, options)(fetch, basePath);
        },
        /** 
         * List and search permissions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPermissions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return AuthPermissionsApiFp.getPermissions(params, options)(fetch, basePath);
        },
        /** 
         * Update a permission
         * @param permission The permission value
         * @param permissionResource The permission resource object
         */
        updatePermission(params: {  "permission": string; "permissionResource"?: PermissionResource; }, options?: any) {
            return AuthPermissionsApiFp.updatePermission(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthRolesApi - fetch parameter creator
 */
export const AuthRolesApiFetchParamCreator = {
    /** 
     * Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  "roleResource"?: RoleResource; }, options?: any): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  "role": string; "force"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling deleteRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "force": params["force"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  "clientKey": string; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single role
     * @param role The role value
     */
    getRole(params: {  "role": string; }, options?: any): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling getRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search roles
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  "clientKey": string; "rolesList"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  "role": string; "permissionsList"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling setPermissionsForRole");
        }
        const baseUrl = `/auth/roles/{role}/permissions`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionsList"]) {
            fetchOptions.body = JSON.stringify(params["permissionsList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  "userId": number; "rolesList"?: Array<string>; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  "role": string; "roleResource"?: RoleResource; }, options?: any): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling updateRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthRolesApi - functional programming interface
 */
export const AuthRolesApiFp = {
    /** 
     * Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: { "roleResource"?: RoleResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.createRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: { "role": string; "force"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.deleteRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: { "clientKey": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getClientRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single role
     * @param role The role value
     */
    getRole(params: { "role": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search roles
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceRoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getUserRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: { "clientKey": string; "rolesList"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setClientRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: { "role": string; "permissionsList"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setPermissionsForRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: { "userId": number; "rolesList"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setUserRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: { "role": string; "roleResource"?: RoleResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.updateRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthRolesApi - object-oriented interface
 */
export class AuthRolesApi extends BaseAPI {
    /** 
     * Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  "roleResource"?: RoleResource; }, options?: any) {
        return AuthRolesApiFp.createRole(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  "role": string; "force"?: boolean; }, options?: any) {
        return AuthRolesApiFp.deleteRole(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  "clientKey": string; }, options?: any) {
        return AuthRolesApiFp.getClientRoles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single role
     * @param role The role value
     */
    getRole(params: {  "role": string; }, options?: any) {
        return AuthRolesApiFp.getRole(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search roles
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return AuthRolesApiFp.getRoles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  "userId": number; }, options?: any) {
        return AuthRolesApiFp.getUserRoles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  "clientKey": string; "rolesList"?: Array<string>; }, options?: any) {
        return AuthRolesApiFp.setClientRoles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  "role": string; "permissionsList"?: Array<string>; }, options?: any) {
        return AuthRolesApiFp.setPermissionsForRole(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  "userId": number; "rolesList"?: Array<string>; }, options?: any) {
        return AuthRolesApiFp.setUserRoles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  "role": string; "roleResource"?: RoleResource; }, options?: any) {
        return AuthRolesApiFp.updateRole(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthRolesApi - factory interface
 */
export const AuthRolesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new role
         * @param roleResource The role resource object
         */
        createRole(params: {  "roleResource"?: RoleResource; }, options?: any) {
            return AuthRolesApiFp.createRole(params, options)(fetch, basePath);
        },
        /** 
         * Delete a role
         * @param role The role value
         * @param force If true, removes role from users/clients
         */
        deleteRole(params: {  "role": string; "force"?: boolean; }, options?: any) {
            return AuthRolesApiFp.deleteRole(params, options)(fetch, basePath);
        },
        /** 
         * Get roles for a client
         * @param clientKey The client key
         */
        getClientRoles(params: {  "clientKey": string; }, options?: any) {
            return AuthRolesApiFp.getClientRoles(params, options)(fetch, basePath);
        },
        /** 
         * Get a single role
         * @param role The role value
         */
        getRole(params: {  "role": string; }, options?: any) {
            return AuthRolesApiFp.getRole(params, options)(fetch, basePath);
        },
        /** 
         * List and search roles
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRoles(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return AuthRolesApiFp.getRoles(params, options)(fetch, basePath);
        },
        /** 
         * Get roles for a user
         * @param userId The user&#39;s id
         */
        getUserRoles(params: {  "userId": number; }, options?: any) {
            return AuthRolesApiFp.getUserRoles(params, options)(fetch, basePath);
        },
        /** 
         * Set roles for a client
         * @param clientKey The client key
         * @param rolesList The list of unique roles
         */
        setClientRoles(params: {  "clientKey": string; "rolesList"?: Array<string>; }, options?: any) {
            return AuthRolesApiFp.setClientRoles(params, options)(fetch, basePath);
        },
        /** 
         * Set permissions for a role
         * @param role The role value
         * @param permissionsList The list of unique permissions
         */
        setPermissionsForRole(params: {  "role": string; "permissionsList"?: Array<string>; }, options?: any) {
            return AuthRolesApiFp.setPermissionsForRole(params, options)(fetch, basePath);
        },
        /** 
         * Set roles for a user
         * @param userId The user&#39;s id
         * @param rolesList The list of unique roles
         */
        setUserRoles(params: {  "userId": number; "rolesList"?: Array<string>; }, options?: any) {
            return AuthRolesApiFp.setUserRoles(params, options)(fetch, basePath);
        },
        /** 
         * Update a role
         * @param role The role value
         * @param roleResource The role resource object
         */
        updateRole(params: {  "role": string; "roleResource"?: RoleResource; }, options?: any) {
            return AuthRolesApiFp.updateRole(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthTokensApi - fetch parameter creator
 */
export const AuthTokensApiFetchParamCreator = {
    /** 
     * Delete a token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteToken(params: {  "username": string; "clientId": string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling deleteToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling deleteToken");
        }
        const baseUrl = `/auth/tokens/{username}/{client_id}`
            .replace(`{${"username"}}`, `${ params["username"] }`)
            .replace(`{${"client_id"}}`, `${ params["clientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete all tokens by username
     * @param username The username of the user
     */
    deleteTokens(params: {  "username": string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling deleteTokens");
        }
        const baseUrl = `/auth/tokens/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  "username": string; "clientId": string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling getToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling getToken");
        }
        const baseUrl = `/auth/tokens/{username}/{client_id}`
            .replace(`{${"username"}}`, `${ params["username"] }`)
            .replace(`{${"client_id"}}`, `${ params["clientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List usernames and client ids
     * Token value not shown
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  "filterClientId"?: string; "filterUsername"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/auth/tokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_client_id": params["filterClientId"],
            "filter_username": params["filterUsername"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthTokensApi - functional programming interface
 */
export const AuthTokensApiFp = {
    /** 
     * Delete a token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteToken(params: { "username": string; "clientId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthTokensApiFetchParamCreator.deleteToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete all tokens by username
     * @param username The username of the user
     */
    deleteTokens(params: { "username": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthTokensApiFetchParamCreator.deleteTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: { "username": string; "clientId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OauthAccessTokenResource> {
        const fetchArgs = AuthTokensApiFetchParamCreator.getToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List usernames and client ids
     * Token value not shown
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: { "filterClientId"?: string; "filterUsername"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceOauthAccessTokenResource> {
        const fetchArgs = AuthTokensApiFetchParamCreator.getTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthTokensApi - object-oriented interface
 */
export class AuthTokensApi extends BaseAPI {
    /** 
     * Delete a token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteToken(params: {  "username": string; "clientId": string; }, options?: any) {
        return AuthTokensApiFp.deleteToken(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete all tokens by username
     * @param username The username of the user
     */
    deleteTokens(params: {  "username": string; }, options?: any) {
        return AuthTokensApiFp.deleteTokens(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  "username": string; "clientId": string; }, options?: any) {
        return AuthTokensApiFp.getToken(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List usernames and client ids
     * Token value not shown
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  "filterClientId"?: string; "filterUsername"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return AuthTokensApiFp.getTokens(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthTokensApi - factory interface
 */
export const AuthTokensApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Delete a token by username and client id
         * @param username The username of the user
         * @param clientId The id of the client
         */
        deleteToken(params: {  "username": string; "clientId": string; }, options?: any) {
            return AuthTokensApiFp.deleteToken(params, options)(fetch, basePath);
        },
        /** 
         * Delete all tokens by username
         * @param username The username of the user
         */
        deleteTokens(params: {  "username": string; }, options?: any) {
            return AuthTokensApiFp.deleteTokens(params, options)(fetch, basePath);
        },
        /** 
         * Get a single token by username and client id
         * @param username The username of the user
         * @param clientId The id of the client
         */
        getToken(params: {  "username": string; "clientId": string; }, options?: any) {
            return AuthTokensApiFp.getToken(params, options)(fetch, basePath);
        },
        /** 
         * List usernames and client ids
         * Token value not shown
         * @param filterClientId Filters for token whose client id matches provided string
         * @param filterUsername Filters for token whose username matches provided string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTokens(params: {  "filterClientId"?: string; "filterUsername"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return AuthTokensApiFp.getTokens(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineActionsApi - fetch parameter creator
 */
export const BRERuleEngineActionsApiFetchParamCreator = {
    /** 
     * Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     */
    getBREActions(params: {  "filterCategory"?: string; "filterName"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/bre/actions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_category": params["filterCategory"],
            "filter_name": params["filterName"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineActionsApi - functional programming interface
 */
export const BRERuleEngineActionsApiFp = {
    /** 
     * Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     */
    getBREActions(params: { "filterCategory"?: string; "filterName"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActionResource>> {
        const fetchArgs = BRERuleEngineActionsApiFetchParamCreator.getBREActions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineActionsApi - object-oriented interface
 */
export class BRERuleEngineActionsApi extends BaseAPI {
    /** 
     * Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     */
    getBREActions(params: {  "filterCategory"?: string; "filterName"?: string; }, options?: any) {
        return BRERuleEngineActionsApiFp.getBREActions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineActionsApi - factory interface
 */
export const BRERuleEngineActionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of available actions
         * @param filterCategory Filter for actions that are within a specific category
         * @param filterName Filter for actions that have names containing the given string
         */
        getBREActions(params: {  "filterCategory"?: string; "filterName"?: string; }, options?: any) {
            return BRERuleEngineActionsApiFp.getBREActions(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineCategoriesApi - fetch parameter creator
 */
export const BRERuleEngineCategoriesApiFetchParamCreator = {
    /** 
     * Create a BRE category template
     * Templates define a type of BRE category and the properties they have
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/bre/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a BRE category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: {  "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/bre/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single category
     * @param name The category name
     */
    getBRECategory(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getBRECategory");
        }
        const baseUrl = `/bre/categories/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/bre/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: {  "name": string; "category"?: BreCategoryResource; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateBRECategory");
        }
        const baseUrl = `/bre/categories/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineCategoriesApi - functional programming interface
 */
export const BRERuleEngineCategoriesApiFp = {
    /** 
     * Create a BRE category template
     * Templates define a type of BRE category and the properties they have
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: { "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.createBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a BRE category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.deleteBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: { "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBreCategoryResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single category
     * @param name The category name
     */
    getBRECategory(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreCategoryResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategoryTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: { "name": string; "category"?: BreCategoryResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.updateBRECategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: { "id": string; "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.updateBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineCategoriesApi - object-oriented interface
 */
export class BRERuleEngineCategoriesApi extends BaseAPI {
    /** 
     * Create a BRE category template
     * Templates define a type of BRE category and the properties they have
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.createBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a BRE category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.deleteBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: {  "size"?: number; "page"?: number; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.getBRECategories(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single category
     * @param name The category name
     */
    getBRECategory(params: {  "name": string; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.getBRECategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: {  "id": string; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.getBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.getBRECategoryTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: {  "name": string; "category"?: BreCategoryResource; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.updateBRECategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
        return BRERuleEngineCategoriesApiFp.updateBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineCategoriesApi - factory interface
 */
export const BRERuleEngineCategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a BRE category template
         * Templates define a type of BRE category and the properties they have
         * @param template The category template to create
         */
        createBRECategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.createBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a BRE category template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteBRECategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.deleteBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List categories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRECategories(params: {  "size"?: number; "page"?: number; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.getBRECategories(params, options)(fetch, basePath);
        },
        /** 
         * Get a single category
         * @param name The category name
         */
        getBRECategory(params: {  "name": string; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.getBRECategory(params, options)(fetch, basePath);
        },
        /** 
         * Get a single BRE category template
         * @param id The id of the template
         */
        getBRECategoryTemplate(params: {  "id": string; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.getBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search BRE category templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBRECategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.getBRECategoryTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Update a category
         * @param name The category name
         * @param category The updated BRE category information
         */
        updateBRECategory(params: {  "name": string; "category"?: BreCategoryResource; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.updateBRECategory(params, options)(fetch, basePath);
        },
        /** 
         * Update a BRE category template
         * @param id The id of the template
         * @param template The updated category template definition
         */
        updateBRECategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
            return BRERuleEngineCategoriesApiFp.updateBRECategoryTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineEventsApi - fetch parameter creator
 */
export const BRERuleEngineEventsApiFetchParamCreator = {
    /** 
     * Fire a new event, based on an existing trigger
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  "breEvent"?: BreEvent; }, options?: any): FetchArgs {
        const baseUrl = `/bre/events`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breEvent"]) {
            fetchOptions.body = JSON.stringify(params["breEvent"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineEventsApi - functional programming interface
 */
export const BRERuleEngineEventsApiFp = {
    /** 
     * Fire a new event, based on an existing trigger
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: { "breEvent"?: BreEvent;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineEventsApiFetchParamCreator.sendBREEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineEventsApi - object-oriented interface
 */
export class BRERuleEngineEventsApi extends BaseAPI {
    /** 
     * Fire a new event, based on an existing trigger
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  "breEvent"?: BreEvent; }, options?: any) {
        return BRERuleEngineEventsApiFp.sendBREEvent(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineEventsApi - factory interface
 */
export const BRERuleEngineEventsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Fire a new event, based on an existing trigger
         * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.
         * @param breEvent The BRE event object
         */
        sendBREEvent(params: {  "breEvent"?: BreEvent; }, options?: any) {
            return BRERuleEngineEventsApiFp.sendBREEvent(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineExpressionsApi - fetch parameter creator
 */
export const BRERuleEngineExpressionsApiFetchParamCreator = {
    /** 
     * Get a list of &#39;lookup&#39; type expressions
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     */
    getBREExpressions(options?: any): FetchArgs {
        const baseUrl = `/bre/expressions/lookup`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineExpressionsApi - functional programming interface
 */
export const BRERuleEngineExpressionsApiFp = {
    /** 
     * Get a list of &#39;lookup&#39; type expressions
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     */
    getBREExpressions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LookupTypeResource>> {
        const fetchArgs = BRERuleEngineExpressionsApiFetchParamCreator.getBREExpressions(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineExpressionsApi - object-oriented interface
 */
export class BRERuleEngineExpressionsApi extends BaseAPI {
    /** 
     * Get a list of &#39;lookup&#39; type expressions
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     */
    getBREExpressions(options?: any) {
        return BRERuleEngineExpressionsApiFp.getBREExpressions(options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineExpressionsApi - factory interface
 */
export const BRERuleEngineExpressionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of &#39;lookup&#39; type expressions
         * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
         */
        getBREExpressions(options?: any) {
            return BRERuleEngineExpressionsApiFp.getBREExpressions(options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineGlobalsApi - fetch parameter creator
 */
export const BRERuleEngineGlobalsApiFetchParamCreator = {
    /** 
     * Create a global definition
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  "breGlobalResource"?: BreGlobalResource; }, options?: any): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a global
     * May fail if there are existing rules against it. Cannot delete core globals
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  "filterSystem"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_system": params["filterSystem"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a global definition
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  "id": string; "breGlobalResource"?: BreGlobalResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineGlobalsApi - functional programming interface
 */
export const BRERuleEngineGlobalsApiFp = {
    /** 
     * Create a global definition
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: { "breGlobalResource"?: BreGlobalResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.createBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a global
     * May fail if there are existing rules against it. Cannot delete core globals
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.deleteBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.getBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: { "filterSystem"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.getBREGlobals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a global definition
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: { "id": string; "breGlobalResource"?: BreGlobalResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.updateBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineGlobalsApi - object-oriented interface
 */
export class BRERuleEngineGlobalsApi extends BaseAPI {
    /** 
     * Create a global definition
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  "breGlobalResource"?: BreGlobalResource; }, options?: any) {
        return BRERuleEngineGlobalsApiFp.createBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a global
     * May fail if there are existing rules against it. Cannot delete core globals
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  "id": string; }, options?: any) {
        return BRERuleEngineGlobalsApiFp.deleteBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  "id": string; }, options?: any) {
        return BRERuleEngineGlobalsApiFp.getBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  "filterSystem"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return BRERuleEngineGlobalsApiFp.getBREGlobals(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a global definition
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  "id": string; "breGlobalResource"?: BreGlobalResource; }, options?: any) {
        return BRERuleEngineGlobalsApiFp.updateBREGlobal(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineGlobalsApi - factory interface
 */
export const BRERuleEngineGlobalsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a global definition
         * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
         * @param breGlobalResource The BRE global resource object
         */
        createBREGlobal(params: {  "breGlobalResource"?: BreGlobalResource; }, options?: any) {
            return BRERuleEngineGlobalsApiFp.createBREGlobal(params, options)(fetch, basePath);
        },
        /** 
         * Delete a global
         * May fail if there are existing rules against it. Cannot delete core globals
         * @param id The id of the global definition
         */
        deleteBREGlobal(params: {  "id": string; }, options?: any) {
            return BRERuleEngineGlobalsApiFp.deleteBREGlobal(params, options)(fetch, basePath);
        },
        /** 
         * Get a single global definition
         * @param id The id of the global definition
         */
        getBREGlobal(params: {  "id": string; }, options?: any) {
            return BRERuleEngineGlobalsApiFp.getBREGlobal(params, options)(fetch, basePath);
        },
        /** 
         * List global definitions
         * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBREGlobals(params: {  "filterSystem"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return BRERuleEngineGlobalsApiFp.getBREGlobals(params, options)(fetch, basePath);
        },
        /** 
         * Update a global definition
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
         * @param id The id of the global definition
         * @param breGlobalResource The BRE global resource object
         */
        updateBREGlobal(params: {  "id": string; "breGlobalResource"?: BreGlobalResource; }, options?: any) {
            return BRERuleEngineGlobalsApiFp.updateBREGlobal(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineRulesApi - fetch parameter creator
 */
export const BRERuleEngineRulesApiFetchParamCreator = {
    /** 
     * Create a rule
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...&lt;h1&gt;Boolean Operators&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IS_NULL&lt;/li&gt; &lt;li&gt;IS_NOT_NULL&lt;/li&gt; &lt;li&gt;STRING_IS_EMPTY&lt;/li&gt; &lt;li&gt;NOT &lt;/li&gt; &lt;li&gt;MAP_IS_EMPTY&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;EQ&lt;/li&gt; &lt;li&gt;NE (Not Equals)&lt;/li&gt; &lt;li&gt;GT (Greater Than)&lt;/li&gt; &lt;li&gt;GOE (Greater Or Equals)&lt;/li&gt; &lt;li&gt;LT (Lesser Than)&lt;/li&gt; &lt;li&gt;LOE (Lesser Or Equals)&lt;/li&gt; &lt;li&gt;OR&lt;/li&gt; &lt;li&gt;AND&lt;/li&gt; &lt;li&gt;XNOR&lt;/li&gt; &lt;li&gt;XOR&lt;/li&gt; &lt;li&gt;CONTAINS_KEY (for maps only)&lt;/li&gt; &lt;li&gt;CONTAINS_VALUE (for maps only)&lt;/li&gt; &lt;li&gt;MATCHES (regex)&lt;/li&gt; &lt;li&gt;MATCHES_IC (regex ignore case)&lt;/li&gt; &lt;li&gt;STARTS_WITH&lt;/li&gt; &lt;li&gt;STARTS_WITH_IC&lt;/li&gt; &lt;li&gt;EQ_IGNORE_CASE&lt;/li&gt; &lt;li&gt;ENDS_WITH&lt;/li&gt; &lt;li&gt;ENDS_WITH_IC&lt;/li&gt; &lt;li&gt;STRING_CONTAINS&lt;/li&gt; &lt;li&gt;STRING_CONTAINS_IC&lt;/li&gt; &lt;li&gt;LIKE (SQL like)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3 args exceptions:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;BETWEEN&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;n args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IN&lt;/li&gt; &lt;li&gt;NOT_INT&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Math Operators&lt;/h1&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;NEGATE&lt;/li&gt; &lt;li&gt;MAP_SIZE&lt;/li&gt; &lt;li&gt;STRING_LENGTH&lt;/li&gt; &lt;li&gt;CEIL&lt;/li&gt; &lt;li&gt;ABS&lt;/li&gt; &lt;li&gt;FLOOR&lt;/li&gt; &lt;li&gt;ROUND&lt;/li&gt; &lt;li&gt;RANDOM (no arg)&lt;/li&gt; &lt;li&gt;RANDOM2 (seed arg)&lt;/li&gt; &lt;li&gt;NUMCAST&lt;/li&gt; &lt;li&gt;HOUR&lt;/li&gt; &lt;li&gt;MINUTE&lt;/li&gt; &lt;li&gt;SECOND&lt;/li&gt; &lt;li&gt;MILLISECOND&lt;/li&gt; &lt;li&gt;YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;YEAR_MONTH&lt;/li&gt; &lt;li&gt;YEAR_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_MONTH&lt;/li&gt; &lt;li&gt;DAY_OF_YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;ADD&lt;/li&gt; &lt;li&gt;DIV&lt;/li&gt; &lt;li&gt;MULT&lt;/li&gt; &lt;li&gt;SUB&lt;/li&gt; &lt;li&gt;POWER&lt;/li&gt; &lt;li&gt;MOD&lt;/li&gt; &lt;li&gt;LOCATE (index of (string, char))&lt;/li&gt; &lt;li&gt;DIFF_YEARS&lt;/li&gt; &lt;li&gt;DIFF_MONTHS&lt;/li&gt; &lt;li&gt;DIFF_WEEKS&lt;/li&gt; &lt;li&gt;DIFF_DAYS&lt;/li&gt; &lt;li&gt;DIFF_HOURS&lt;/li&gt; &lt;li&gt;DIFF_MINUTES&lt;/li&gt; &lt;li&gt;DIFF_SECONDS&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;MIN&lt;/li&gt; &lt;li&gt;MAX&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;String Operators&lt;/h1&gt;0 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt; &lt;li&gt;LOWER&lt;/li&gt; &lt;li&gt;UPPER&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CHAR_AT&lt;/li&gt; &lt;li&gt;SUBSTR_1ARG (substr(string, start))&lt;/li&gt; &lt;li&gt;CONCAT&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;3 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;SUBSTR_2ARGS (substr(string, start, length))&lt;/li&gt;&lt;/ul&gt;
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  "breRule"?: BreRule; }, options?: any): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a rule
     * May fail if there are existing rules against it. Cannot delete core rules
     * @param id The id of the rule
     */
    deleteBRERule(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  "expression"?: Expressionobject; }, options?: any): FetchArgs {
        const baseUrl = `/bre/rules/expression-as-string`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["expression"]) {
            fetchOptions.body = JSON.stringify(params["expression"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  "filterName"?: string; "filterEnabled"?: boolean; "filterSystem"?: boolean; "filterTrigger"?: string; "filterAction"?: string; "filterCondition"?: string; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_name": params["filterName"],
            "filter_enabled": params["filterEnabled"],
            "filter_system": params["filterSystem"],
            "filter_trigger": params["filterTrigger"],
            "filter_action": params["filterAction"],
            "filter_condition": params["filterCondition"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Enable or disable a rule
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  "id": string; "enabled"?: BooleanResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setBRERule");
        }
        const baseUrl = `/bre/rules/{id}/enabled`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["enabled"]) {
            fetchOptions.body = JSON.stringify(params["enabled"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a rule
     * Cannot update system rules
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  "id": string; "breRule"?: BreRule; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineRulesApi - functional programming interface
 */
export const BRERuleEngineRulesApiFp = {
    /** 
     * Create a rule
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...&lt;h1&gt;Boolean Operators&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IS_NULL&lt;/li&gt; &lt;li&gt;IS_NOT_NULL&lt;/li&gt; &lt;li&gt;STRING_IS_EMPTY&lt;/li&gt; &lt;li&gt;NOT &lt;/li&gt; &lt;li&gt;MAP_IS_EMPTY&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;EQ&lt;/li&gt; &lt;li&gt;NE (Not Equals)&lt;/li&gt; &lt;li&gt;GT (Greater Than)&lt;/li&gt; &lt;li&gt;GOE (Greater Or Equals)&lt;/li&gt; &lt;li&gt;LT (Lesser Than)&lt;/li&gt; &lt;li&gt;LOE (Lesser Or Equals)&lt;/li&gt; &lt;li&gt;OR&lt;/li&gt; &lt;li&gt;AND&lt;/li&gt; &lt;li&gt;XNOR&lt;/li&gt; &lt;li&gt;XOR&lt;/li&gt; &lt;li&gt;CONTAINS_KEY (for maps only)&lt;/li&gt; &lt;li&gt;CONTAINS_VALUE (for maps only)&lt;/li&gt; &lt;li&gt;MATCHES (regex)&lt;/li&gt; &lt;li&gt;MATCHES_IC (regex ignore case)&lt;/li&gt; &lt;li&gt;STARTS_WITH&lt;/li&gt; &lt;li&gt;STARTS_WITH_IC&lt;/li&gt; &lt;li&gt;EQ_IGNORE_CASE&lt;/li&gt; &lt;li&gt;ENDS_WITH&lt;/li&gt; &lt;li&gt;ENDS_WITH_IC&lt;/li&gt; &lt;li&gt;STRING_CONTAINS&lt;/li&gt; &lt;li&gt;STRING_CONTAINS_IC&lt;/li&gt; &lt;li&gt;LIKE (SQL like)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3 args exceptions:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;BETWEEN&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;n args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IN&lt;/li&gt; &lt;li&gt;NOT_INT&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Math Operators&lt;/h1&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;NEGATE&lt;/li&gt; &lt;li&gt;MAP_SIZE&lt;/li&gt; &lt;li&gt;STRING_LENGTH&lt;/li&gt; &lt;li&gt;CEIL&lt;/li&gt; &lt;li&gt;ABS&lt;/li&gt; &lt;li&gt;FLOOR&lt;/li&gt; &lt;li&gt;ROUND&lt;/li&gt; &lt;li&gt;RANDOM (no arg)&lt;/li&gt; &lt;li&gt;RANDOM2 (seed arg)&lt;/li&gt; &lt;li&gt;NUMCAST&lt;/li&gt; &lt;li&gt;HOUR&lt;/li&gt; &lt;li&gt;MINUTE&lt;/li&gt; &lt;li&gt;SECOND&lt;/li&gt; &lt;li&gt;MILLISECOND&lt;/li&gt; &lt;li&gt;YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;YEAR_MONTH&lt;/li&gt; &lt;li&gt;YEAR_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_MONTH&lt;/li&gt; &lt;li&gt;DAY_OF_YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;ADD&lt;/li&gt; &lt;li&gt;DIV&lt;/li&gt; &lt;li&gt;MULT&lt;/li&gt; &lt;li&gt;SUB&lt;/li&gt; &lt;li&gt;POWER&lt;/li&gt; &lt;li&gt;MOD&lt;/li&gt; &lt;li&gt;LOCATE (index of (string, char))&lt;/li&gt; &lt;li&gt;DIFF_YEARS&lt;/li&gt; &lt;li&gt;DIFF_MONTHS&lt;/li&gt; &lt;li&gt;DIFF_WEEKS&lt;/li&gt; &lt;li&gt;DIFF_DAYS&lt;/li&gt; &lt;li&gt;DIFF_HOURS&lt;/li&gt; &lt;li&gt;DIFF_MINUTES&lt;/li&gt; &lt;li&gt;DIFF_SECONDS&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;MIN&lt;/li&gt; &lt;li&gt;MAX&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;String Operators&lt;/h1&gt;0 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt; &lt;li&gt;LOWER&lt;/li&gt; &lt;li&gt;UPPER&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CHAR_AT&lt;/li&gt; &lt;li&gt;SUBSTR_1ARG (substr(string, start))&lt;/li&gt; &lt;li&gt;CONCAT&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;3 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;SUBSTR_2ARGS (substr(string, start, length))&lt;/li&gt;&lt;/ul&gt;
     * @param breRule The BRE rule object
     */
    createBRERule(params: { "breRule"?: BreRule;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.createBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a rule
     * May fail if there are existing rules against it. Cannot delete core rules
     * @param id The id of the rule
     */
    deleteBRERule(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.deleteBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: { "expression"?: Expressionobject;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBREExpressionAsString(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: { "filterName"?: string; "filterEnabled"?: boolean; "filterSystem"?: boolean; "filterTrigger"?: string; "filterAction"?: string; "filterCondition"?: string; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBRERules(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Enable or disable a rule
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: { "id": string; "enabled"?: BooleanResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.setBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a rule
     * Cannot update system rules
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: { "id": string; "breRule"?: BreRule;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.updateBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineRulesApi - object-oriented interface
 */
export class BRERuleEngineRulesApi extends BaseAPI {
    /** 
     * Create a rule
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...&lt;h1&gt;Boolean Operators&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IS_NULL&lt;/li&gt; &lt;li&gt;IS_NOT_NULL&lt;/li&gt; &lt;li&gt;STRING_IS_EMPTY&lt;/li&gt; &lt;li&gt;NOT &lt;/li&gt; &lt;li&gt;MAP_IS_EMPTY&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;EQ&lt;/li&gt; &lt;li&gt;NE (Not Equals)&lt;/li&gt; &lt;li&gt;GT (Greater Than)&lt;/li&gt; &lt;li&gt;GOE (Greater Or Equals)&lt;/li&gt; &lt;li&gt;LT (Lesser Than)&lt;/li&gt; &lt;li&gt;LOE (Lesser Or Equals)&lt;/li&gt; &lt;li&gt;OR&lt;/li&gt; &lt;li&gt;AND&lt;/li&gt; &lt;li&gt;XNOR&lt;/li&gt; &lt;li&gt;XOR&lt;/li&gt; &lt;li&gt;CONTAINS_KEY (for maps only)&lt;/li&gt; &lt;li&gt;CONTAINS_VALUE (for maps only)&lt;/li&gt; &lt;li&gt;MATCHES (regex)&lt;/li&gt; &lt;li&gt;MATCHES_IC (regex ignore case)&lt;/li&gt; &lt;li&gt;STARTS_WITH&lt;/li&gt; &lt;li&gt;STARTS_WITH_IC&lt;/li&gt; &lt;li&gt;EQ_IGNORE_CASE&lt;/li&gt; &lt;li&gt;ENDS_WITH&lt;/li&gt; &lt;li&gt;ENDS_WITH_IC&lt;/li&gt; &lt;li&gt;STRING_CONTAINS&lt;/li&gt; &lt;li&gt;STRING_CONTAINS_IC&lt;/li&gt; &lt;li&gt;LIKE (SQL like)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3 args exceptions:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;BETWEEN&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;n args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IN&lt;/li&gt; &lt;li&gt;NOT_INT&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Math Operators&lt;/h1&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;NEGATE&lt;/li&gt; &lt;li&gt;MAP_SIZE&lt;/li&gt; &lt;li&gt;STRING_LENGTH&lt;/li&gt; &lt;li&gt;CEIL&lt;/li&gt; &lt;li&gt;ABS&lt;/li&gt; &lt;li&gt;FLOOR&lt;/li&gt; &lt;li&gt;ROUND&lt;/li&gt; &lt;li&gt;RANDOM (no arg)&lt;/li&gt; &lt;li&gt;RANDOM2 (seed arg)&lt;/li&gt; &lt;li&gt;NUMCAST&lt;/li&gt; &lt;li&gt;HOUR&lt;/li&gt; &lt;li&gt;MINUTE&lt;/li&gt; &lt;li&gt;SECOND&lt;/li&gt; &lt;li&gt;MILLISECOND&lt;/li&gt; &lt;li&gt;YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;YEAR_MONTH&lt;/li&gt; &lt;li&gt;YEAR_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_MONTH&lt;/li&gt; &lt;li&gt;DAY_OF_YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;ADD&lt;/li&gt; &lt;li&gt;DIV&lt;/li&gt; &lt;li&gt;MULT&lt;/li&gt; &lt;li&gt;SUB&lt;/li&gt; &lt;li&gt;POWER&lt;/li&gt; &lt;li&gt;MOD&lt;/li&gt; &lt;li&gt;LOCATE (index of (string, char))&lt;/li&gt; &lt;li&gt;DIFF_YEARS&lt;/li&gt; &lt;li&gt;DIFF_MONTHS&lt;/li&gt; &lt;li&gt;DIFF_WEEKS&lt;/li&gt; &lt;li&gt;DIFF_DAYS&lt;/li&gt; &lt;li&gt;DIFF_HOURS&lt;/li&gt; &lt;li&gt;DIFF_MINUTES&lt;/li&gt; &lt;li&gt;DIFF_SECONDS&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;MIN&lt;/li&gt; &lt;li&gt;MAX&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;String Operators&lt;/h1&gt;0 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt; &lt;li&gt;LOWER&lt;/li&gt; &lt;li&gt;UPPER&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CHAR_AT&lt;/li&gt; &lt;li&gt;SUBSTR_1ARG (substr(string, start))&lt;/li&gt; &lt;li&gt;CONCAT&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;3 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;SUBSTR_2ARGS (substr(string, start, length))&lt;/li&gt;&lt;/ul&gt;
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  "breRule"?: BreRule; }, options?: any) {
        return BRERuleEngineRulesApiFp.createBRERule(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a rule
     * May fail if there are existing rules against it. Cannot delete core rules
     * @param id The id of the rule
     */
    deleteBRERule(params: {  "id": string; }, options?: any) {
        return BRERuleEngineRulesApiFp.deleteBRERule(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  "expression"?: Expressionobject; }, options?: any) {
        return BRERuleEngineRulesApiFp.getBREExpressionAsString(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  "id": string; }, options?: any) {
        return BRERuleEngineRulesApiFp.getBRERule(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  "filterName"?: string; "filterEnabled"?: boolean; "filterSystem"?: boolean; "filterTrigger"?: string; "filterAction"?: string; "filterCondition"?: string; "size"?: number; "page"?: number; }, options?: any) {
        return BRERuleEngineRulesApiFp.getBRERules(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Enable or disable a rule
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  "id": string; "enabled"?: BooleanResource; }, options?: any) {
        return BRERuleEngineRulesApiFp.setBRERule(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a rule
     * Cannot update system rules
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  "id": string; "breRule"?: BreRule; }, options?: any) {
        return BRERuleEngineRulesApiFp.updateBRERule(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineRulesApi - factory interface
 */
export const BRERuleEngineRulesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a rule
         * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...&lt;h1&gt;Boolean Operators&lt;/h1&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IS_NULL&lt;/li&gt; &lt;li&gt;IS_NOT_NULL&lt;/li&gt; &lt;li&gt;STRING_IS_EMPTY&lt;/li&gt; &lt;li&gt;NOT &lt;/li&gt; &lt;li&gt;MAP_IS_EMPTY&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;EQ&lt;/li&gt; &lt;li&gt;NE (Not Equals)&lt;/li&gt; &lt;li&gt;GT (Greater Than)&lt;/li&gt; &lt;li&gt;GOE (Greater Or Equals)&lt;/li&gt; &lt;li&gt;LT (Lesser Than)&lt;/li&gt; &lt;li&gt;LOE (Lesser Or Equals)&lt;/li&gt; &lt;li&gt;OR&lt;/li&gt; &lt;li&gt;AND&lt;/li&gt; &lt;li&gt;XNOR&lt;/li&gt; &lt;li&gt;XOR&lt;/li&gt; &lt;li&gt;CONTAINS_KEY (for maps only)&lt;/li&gt; &lt;li&gt;CONTAINS_VALUE (for maps only)&lt;/li&gt; &lt;li&gt;MATCHES (regex)&lt;/li&gt; &lt;li&gt;MATCHES_IC (regex ignore case)&lt;/li&gt; &lt;li&gt;STARTS_WITH&lt;/li&gt; &lt;li&gt;STARTS_WITH_IC&lt;/li&gt; &lt;li&gt;EQ_IGNORE_CASE&lt;/li&gt; &lt;li&gt;ENDS_WITH&lt;/li&gt; &lt;li&gt;ENDS_WITH_IC&lt;/li&gt; &lt;li&gt;STRING_CONTAINS&lt;/li&gt; &lt;li&gt;STRING_CONTAINS_IC&lt;/li&gt; &lt;li&gt;LIKE (SQL like)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;3 args exceptions:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;BETWEEN&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;n args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;IN&lt;/li&gt; &lt;li&gt;NOT_INT&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;Math Operators&lt;/h1&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;NEGATE&lt;/li&gt; &lt;li&gt;MAP_SIZE&lt;/li&gt; &lt;li&gt;STRING_LENGTH&lt;/li&gt; &lt;li&gt;CEIL&lt;/li&gt; &lt;li&gt;ABS&lt;/li&gt; &lt;li&gt;FLOOR&lt;/li&gt; &lt;li&gt;ROUND&lt;/li&gt; &lt;li&gt;RANDOM (no arg)&lt;/li&gt; &lt;li&gt;RANDOM2 (seed arg)&lt;/li&gt; &lt;li&gt;NUMCAST&lt;/li&gt; &lt;li&gt;HOUR&lt;/li&gt; &lt;li&gt;MINUTE&lt;/li&gt; &lt;li&gt;SECOND&lt;/li&gt; &lt;li&gt;MILLISECOND&lt;/li&gt; &lt;li&gt;YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;YEAR_MONTH&lt;/li&gt; &lt;li&gt;YEAR_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_WEEK&lt;/li&gt; &lt;li&gt;DAY_OF_MONTH&lt;/li&gt; &lt;li&gt;DAY_OF_YEAR&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt; &lt;li&gt;WEEK&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;ADD&lt;/li&gt; &lt;li&gt;DIV&lt;/li&gt; &lt;li&gt;MULT&lt;/li&gt; &lt;li&gt;SUB&lt;/li&gt; &lt;li&gt;POWER&lt;/li&gt; &lt;li&gt;MOD&lt;/li&gt; &lt;li&gt;LOCATE (index of (string, char))&lt;/li&gt; &lt;li&gt;DIFF_YEARS&lt;/li&gt; &lt;li&gt;DIFF_MONTHS&lt;/li&gt; &lt;li&gt;DIFF_WEEKS&lt;/li&gt; &lt;li&gt;DIFF_DAYS&lt;/li&gt; &lt;li&gt;DIFF_HOURS&lt;/li&gt; &lt;li&gt;DIFF_MINUTES&lt;/li&gt; &lt;li&gt;DIFF_SECONDS&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;MIN&lt;/li&gt; &lt;li&gt;MAX&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;String Operators&lt;/h1&gt;0 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;1 arg:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CURRENT_TIME&lt;/li&gt; &lt;li&gt;LOWER&lt;/li&gt; &lt;li&gt;UPPER&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;2 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;CHAR_AT&lt;/li&gt; &lt;li&gt;SUBSTR_1ARG (substr(string, start))&lt;/li&gt; &lt;li&gt;CONCAT&lt;/li&gt; &lt;li&gt;TRIM&lt;/li&gt; &lt;li&gt;STRING_CAST&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;3 args:&lt;br /&gt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&lt;br /&gt;&lt;br /&gt;&lt;ul&gt; &lt;li&gt;SUBSTR_2ARGS (substr(string, start, length))&lt;/li&gt;&lt;/ul&gt;
         * @param breRule The BRE rule object
         */
        createBRERule(params: {  "breRule"?: BreRule; }, options?: any) {
            return BRERuleEngineRulesApiFp.createBRERule(params, options)(fetch, basePath);
        },
        /** 
         * Delete a rule
         * May fail if there are existing rules against it. Cannot delete core rules
         * @param id The id of the rule
         */
        deleteBRERule(params: {  "id": string; }, options?: any) {
            return BRERuleEngineRulesApiFp.deleteBRERule(params, options)(fetch, basePath);
        },
        /** 
         * Returns a string representation of the provided expression
         * @param expression The expression
         */
        getBREExpressionAsString(params: {  "expression"?: Expressionobject; }, options?: any) {
            return BRERuleEngineRulesApiFp.getBREExpressionAsString(params, options)(fetch, basePath);
        },
        /** 
         * Get a single rule
         * @param id The id of the rule
         */
        getBRERule(params: {  "id": string; }, options?: any) {
            return BRERuleEngineRulesApiFp.getBRERule(params, options)(fetch, basePath);
        },
        /** 
         * List rules
         * @param filterName Filter for rules containing the given name
         * @param filterEnabled Filter for rules by active status, null for both
         * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
         * @param filterTrigger Filter for rules that are for the trigger with the given name
         * @param filterAction Filter for rules that use the action with the given name
         * @param filterCondition Filter for rules that have a condition containing the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRERules(params: {  "filterName"?: string; "filterEnabled"?: boolean; "filterSystem"?: boolean; "filterTrigger"?: string; "filterAction"?: string; "filterCondition"?: string; "size"?: number; "page"?: number; }, options?: any) {
            return BRERuleEngineRulesApiFp.getBRERules(params, options)(fetch, basePath);
        },
        /** 
         * Enable or disable a rule
         * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
         * @param id The id of the rule
         * @param enabled The boolean value
         */
        setBRERule(params: {  "id": string; "enabled"?: BooleanResource; }, options?: any) {
            return BRERuleEngineRulesApiFp.setBRERule(params, options)(fetch, basePath);
        },
        /** 
         * Update a rule
         * Cannot update system rules
         * @param id The id of the rule
         * @param breRule The BRE rule object
         */
        updateBRERule(params: {  "id": string; "breRule"?: BreRule; }, options?: any) {
            return BRERuleEngineRulesApiFp.updateBRERule(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineTriggersApi - fetch parameter creator
 */
export const BRERuleEngineTriggersApiFetchParamCreator = {
    /** 
     * Create a trigger
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  "breTriggerResource"?: BreTriggerResource; }, options?: any): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a trigger
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  "eventName": string; }, options?: any): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling deleteBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  "eventName": string; }, options?: any): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling getBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterName Filter for triggers that have names containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  "filterSystem"?: boolean; "filterCategory"?: string; "filterName"?: string; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_system": params["filterSystem"],
            "filter_category": params["filterCategory"],
            "filter_name": params["filterName"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a trigger
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  "eventName": string; "breTriggerResource"?: BreTriggerResource; }, options?: any): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling updateBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineTriggersApi - functional programming interface
 */
export const BRERuleEngineTriggersApiFp = {
    /** 
     * Create a trigger
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: { "breTriggerResource"?: BreTriggerResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.createBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a trigger
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: { "eventName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.deleteBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: { "eventName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.getBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterName Filter for triggers that have names containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: { "filterSystem"?: boolean; "filterCategory"?: string; "filterName"?: string; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.getBRETriggers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a trigger
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: { "eventName": string; "breTriggerResource"?: BreTriggerResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.updateBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineTriggersApi - object-oriented interface
 */
export class BRERuleEngineTriggersApi extends BaseAPI {
    /** 
     * Create a trigger
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  "breTriggerResource"?: BreTriggerResource; }, options?: any) {
        return BRERuleEngineTriggersApiFp.createBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a trigger
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  "eventName": string; }, options?: any) {
        return BRERuleEngineTriggersApiFp.deleteBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  "eventName": string; }, options?: any) {
        return BRERuleEngineTriggersApiFp.getBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterName Filter for triggers that have names containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  "filterSystem"?: boolean; "filterCategory"?: string; "filterName"?: string; "size"?: number; "page"?: number; }, options?: any) {
        return BRERuleEngineTriggersApiFp.getBRETriggers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a trigger
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  "eventName": string; "breTriggerResource"?: BreTriggerResource; }, options?: any) {
        return BRERuleEngineTriggersApiFp.updateBRETrigger(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineTriggersApi - factory interface
 */
export const BRERuleEngineTriggersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a trigger
         * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
         * @param breTriggerResource The BRE trigger resource object
         */
        createBRETrigger(params: {  "breTriggerResource"?: BreTriggerResource; }, options?: any) {
            return BRERuleEngineTriggersApiFp.createBRETrigger(params, options)(fetch, basePath);
        },
        /** 
         * Delete a trigger
         * May fail if there are existing rules against it. Cannot delete core triggers
         * @param eventName The trigger event name
         */
        deleteBRETrigger(params: {  "eventName": string; }, options?: any) {
            return BRERuleEngineTriggersApiFp.deleteBRETrigger(params, options)(fetch, basePath);
        },
        /** 
         * Get a single trigger
         * @param eventName The trigger event name
         */
        getBRETrigger(params: {  "eventName": string; }, options?: any) {
            return BRERuleEngineTriggersApiFp.getBRETrigger(params, options)(fetch, basePath);
        },
        /** 
         * List triggers
         * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
         * @param filterCategory Filter for triggers that are within a specific category
         * @param filterName Filter for triggers that have names containing the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRETriggers(params: {  "filterSystem"?: boolean; "filterCategory"?: string; "filterName"?: string; "size"?: number; "page"?: number; }, options?: any) {
            return BRERuleEngineTriggersApiFp.getBRETriggers(params, options)(fetch, basePath);
        },
        /** 
         * Update a trigger
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
         * @param eventName The trigger event name
         * @param breTriggerResource The BRE trigger resource object
         */
        updateBRETrigger(params: {  "eventName": string; "breTriggerResource"?: BreTriggerResource; }, options?: any) {
            return BRERuleEngineTriggersApiFp.updateBRETrigger(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineVariablesApi - fetch parameter creator
 */
export const BRERuleEngineVariablesApiFetchParamCreator = {
    /** 
     * Get a list of variable types available
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     */
    getBREVariableTypes(options?: any): FetchArgs {
        const baseUrl = `/bre/variable-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineVariablesApi - functional programming interface
 */
export const BRERuleEngineVariablesApiFp = {
    /** 
     * Get a list of variable types available
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     */
    getBREVariableTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<VariableTypeResource>> {
        const fetchArgs = BRERuleEngineVariablesApiFetchParamCreator.getBREVariableTypes(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineVariablesApi - object-oriented interface
 */
export class BRERuleEngineVariablesApi extends BaseAPI {
    /** 
     * Get a list of variable types available
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     */
    getBREVariableTypes(options?: any) {
        return BRERuleEngineVariablesApiFp.getBREVariableTypes(options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineVariablesApi - factory interface
 */
export const BRERuleEngineVariablesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of variable types available
         * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
         */
        getBREVariableTypes(options?: any) {
            return BRERuleEngineVariablesApiFp.getBREVariableTypes(options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsApi - fetch parameter creator
 */
export const CampaignsApiFetchParamCreator = {
    /** 
     * Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  "id": number; "challengeId"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addChallengeToCampaign");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeId"]) {
            fetchOptions.body = JSON.stringify(params["challengeId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  "campaignResource"?: CampaignResource; }, options?: any): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a campaign template
     * Campaign Templates define a type of campaign and the properties they have
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  "campaignTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a campaign template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the challenges associated with a campaign
     * @param id The campaign id
     */
    getCampaignChallenges(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignChallenges");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_active": params["filterActive"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  "campaignId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling removeChallengeFromCampaign");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeChallengeFromCampaign");
        }
        const baseUrl = `/campaigns/{campaign_id}/challenges/{id}`
            .replace(`{${"campaign_id"}}`, `${ params["campaignId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  "id": number; "campaignResource"?: CampaignResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  "id": string; "campaignTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsApi - functional programming interface
 */
export const CampaignsApiFp = {
    /** 
     * Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: { "id": number; "challengeId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.addChallengeToCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: { "campaignResource"?: CampaignResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a campaign template
     * Campaign Templates define a type of campaign and the properties they have
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: { "campaignTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a campaign template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the challenges associated with a campaign
     * @param id The campaign id
     */
    getCampaignChallenges(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignChallenges(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: { "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaigns(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: { "campaignId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.removeChallengeFromCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: { "id": number; "campaignResource"?: CampaignResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: { "id": string; "campaignTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsApi - object-oriented interface
 */
export class CampaignsApi extends BaseAPI {
    /** 
     * Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  "id": number; "challengeId"?: number; }, options?: any) {
        return CampaignsApiFp.addChallengeToCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  "campaignResource"?: CampaignResource; }, options?: any) {
        return CampaignsApiFp.createCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a campaign template
     * Campaign Templates define a type of campaign and the properties they have
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  "campaignTemplateResource"?: TemplateResource; }, options?: any) {
        return CampaignsApiFp.createCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  "id": number; }, options?: any) {
        return CampaignsApiFp.deleteCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a campaign template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return CampaignsApiFp.deleteCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  "id": number; }, options?: any) {
        return CampaignsApiFp.getCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the challenges associated with a campaign
     * @param id The campaign id
     */
    getCampaignChallenges(params: {  "id": number; }, options?: any) {
        return CampaignsApiFp.getCampaignChallenges(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  "id": string; }, options?: any) {
        return CampaignsApiFp.getCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsApiFp.getCampaignTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsApiFp.getCampaigns(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  "campaignId": number; "id": number; }, options?: any) {
        return CampaignsApiFp.removeChallengeFromCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  "id": number; "campaignResource"?: CampaignResource; }, options?: any) {
        return CampaignsApiFp.updateCampaign(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  "id": string; "campaignTemplateResource"?: TemplateResource; }, options?: any) {
        return CampaignsApiFp.updateCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsApi - factory interface
 */
export const CampaignsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a challenge to a campaign
         * @param id The id of the campaign
         * @param challengeId The id of the challenge
         */
        addChallengeToCampaign(params: {  "id": number; "challengeId"?: number; }, options?: any) {
            return CampaignsApiFp.addChallengeToCampaign(params, options)(fetch, basePath);
        },
        /** 
         * Create a campaign
         * @param campaignResource The campaign resource object
         */
        createCampaign(params: {  "campaignResource"?: CampaignResource; }, options?: any) {
            return CampaignsApiFp.createCampaign(params, options)(fetch, basePath);
        },
        /** 
         * Create a campaign template
         * Campaign Templates define a type of campaign and the properties they have
         * @param campaignTemplateResource The campaign template resource object
         */
        createCampaignTemplate(params: {  "campaignTemplateResource"?: TemplateResource; }, options?: any) {
            return CampaignsApiFp.createCampaignTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a campaign
         * @param id The campaign id
         */
        deleteCampaign(params: {  "id": number; }, options?: any) {
            return CampaignsApiFp.deleteCampaign(params, options)(fetch, basePath);
        },
        /** 
         * Delete a campaign template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCampaignTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return CampaignsApiFp.deleteCampaignTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Returns a single campaign
         * @param id The campaign id
         */
        getCampaign(params: {  "id": number; }, options?: any) {
            return CampaignsApiFp.getCampaign(params, options)(fetch, basePath);
        },
        /** 
         * List the challenges associated with a campaign
         * @param id The campaign id
         */
        getCampaignChallenges(params: {  "id": number; }, options?: any) {
            return CampaignsApiFp.getCampaignChallenges(params, options)(fetch, basePath);
        },
        /** 
         * Get a single campaign template
         * @param id The id of the template
         */
        getCampaignTemplate(params: {  "id": string; }, options?: any) {
            return CampaignsApiFp.getCampaignTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search campaign templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaignTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsApiFp.getCampaignTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List and search campaigns
         * @param filterActive Filter for campaigns that are active
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaigns(params: {  "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsApiFp.getCampaigns(params, options)(fetch, basePath);
        },
        /** 
         * Remove a challenge from a campaign
         * @param campaignId The campaign id
         * @param id The challenge id
         */
        removeChallengeFromCampaign(params: {  "campaignId": number; "id": number; }, options?: any) {
            return CampaignsApiFp.removeChallengeFromCampaign(params, options)(fetch, basePath);
        },
        /** 
         * Update a campaign
         * @param id The campaign id
         * @param campaignResource The campaign resource object
         */
        updateCampaign(params: {  "id": number; "campaignResource"?: CampaignResource; }, options?: any) {
            return CampaignsApiFp.updateCampaign(params, options)(fetch, basePath);
        },
        /** 
         * Update an campaign template
         * @param id The id of the template
         * @param campaignTemplateResource The campaign template resource object
         */
        updateCampaignTemplate(params: {  "id": string; "campaignTemplateResource"?: TemplateResource; }, options?: any) {
            return CampaignsApiFp.updateCampaignTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsChallengesApi - fetch parameter creator
 */
export const CampaignsChallengesApiFetchParamCreator = {
    /** 
     * Create a challenge
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  "challengeResource"?: ChallengeResource; }, options?: any): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; "validateSettings"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling createChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "validateSettings": params["validateSettings"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a challenge template
     * Challenge Templates define a type of challenge and the properties they have
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  "challengeTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  "activityId": number; "challengeId": number; }, options?: any): FetchArgs {
        // verify required parameter "activityId" is set
        if (params["activityId"] == null) {
            throw new Error("Missing required parameter activityId when calling deleteChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling deleteChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{activity_id}`
            .replace(`{${"activity_id"}}`, `${ params["activityId"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a challenge template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  "challengeId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling getChallengeActivities");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single challenge activity
     * @param activityId The activity id
     */
    getChallengeActivity(params: {  "activityId": number; }, options?: any): FetchArgs {
        // verify required parameter "activityId" is set
        if (params["activityId"] == null) {
            throw new Error("Missing required parameter activityId when calling getChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{activity_id}`
            .replace(`{${"activity_id"}}`, `${ params["activityId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterCampaigns"?: boolean; "filterChallenge"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/challenges/events`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_start_date": params["filterStartDate"],
            "filter_end_date": params["filterEndDate"],
            "filter_campaigns": params["filterCampaigns"],
            "filter_challenge": params["filterChallenge"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     */
    getChallenges(params: {  "filterTemplate"?: boolean; "filterActiveCampaign"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_template": params["filterTemplate"],
            "filter_active_campaign": params["filterActiveCampaign"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a challenge
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  "id": number; "challengeResource"?: ChallengeResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: {  "activityId": number; "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; }, options?: any): FetchArgs {
        // verify required parameter "activityId" is set
        if (params["activityId"] == null) {
            throw new Error("Missing required parameter activityId when calling updateChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling updateChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{activity_id}`
            .replace(`{${"activity_id"}}`, `${ params["activityId"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  "id": string; "challengeTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsChallengesApi - functional programming interface
 */
export const CampaignsChallengesApiFp = {
    /** 
     * Create a challenge
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: { "challengeResource"?: ChallengeResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: { "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; "validateSettings"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a challenge template
     * Challenge Templates define a type of challenge and the properties they have
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: { "challengeTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: { "activityId": number; "challengeId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a challenge template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: { "challengeId": number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBareChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivities(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single challenge activity
     * @param activityId The activity id
     */
    getChallengeActivity(params: { "activityId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeEventResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: { "filterStartDate"?: string; "filterEndDate"?: string; "filterCampaigns"?: boolean; "filterChallenge"?: number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeEvents(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     */
    getChallenges(params: { "filterTemplate"?: boolean; "filterActiveCampaign"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallenges(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a challenge
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: { "id": number; "challengeResource"?: ChallengeResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: { "activityId": number; "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: { "id": string; "challengeTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsChallengesApi - object-oriented interface
 */
export class CampaignsChallengesApi extends BaseAPI {
    /** 
     * Create a challenge
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  "challengeResource"?: ChallengeResource; }, options?: any) {
        return CampaignsChallengesApiFp.createChallenge(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; "validateSettings"?: boolean; }, options?: any) {
        return CampaignsChallengesApiFp.createChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a challenge template
     * Challenge Templates define a type of challenge and the properties they have
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  "challengeTemplateResource"?: TemplateResource; }, options?: any) {
        return CampaignsChallengesApiFp.createChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  "id": number; }, options?: any) {
        return CampaignsChallengesApiFp.deleteChallenge(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  "activityId": number; "challengeId": number; }, options?: any) {
        return CampaignsChallengesApiFp.deleteChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  "id": number; }, options?: any) {
        return CampaignsChallengesApiFp.deleteChallengeEvent(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a challenge template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return CampaignsChallengesApiFp.deleteChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  "id": number; }, options?: any) {
        return CampaignsChallengesApiFp.getChallenge(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  "challengeId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeActivities(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single challenge activity
     * @param activityId The activity id
     */
    getChallengeActivity(params: {  "activityId": number; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  "id": number; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeEvent(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterCampaigns"?: boolean; "filterChallenge"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeEvents(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  "id": string; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsChallengesApiFp.getChallengeTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     */
    getChallenges(params: {  "filterTemplate"?: boolean; "filterActiveCampaign"?: boolean; }, options?: any) {
        return CampaignsChallengesApiFp.getChallenges(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a challenge
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  "id": number; "challengeResource"?: ChallengeResource; }, options?: any) {
        return CampaignsChallengesApiFp.updateChallenge(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a challenge activity
     * @param activityId The activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: {  "activityId": number; "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; }, options?: any) {
        return CampaignsChallengesApiFp.updateChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  "id": string; "challengeTemplateResource"?: TemplateResource; }, options?: any) {
        return CampaignsChallengesApiFp.updateChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsChallengesApi - factory interface
 */
export const CampaignsChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a challenge
         * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
         * @param challengeResource The challenge resource object
         */
        createChallenge(params: {  "challengeResource"?: ChallengeResource; }, options?: any) {
            return CampaignsChallengesApiFp.createChallenge(params, options)(fetch, basePath);
        },
        /** 
         * Create a challenge activity
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
         */
        createChallengeActivity(params: {  "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; "validateSettings"?: boolean; }, options?: any) {
            return CampaignsChallengesApiFp.createChallengeActivity(params, options)(fetch, basePath);
        },
        /** 
         * Create a challenge template
         * Challenge Templates define a type of challenge and the properties they have
         * @param challengeTemplateResource The challenge template resource object
         */
        createChallengeTemplate(params: {  "challengeTemplateResource"?: TemplateResource; }, options?: any) {
            return CampaignsChallengesApiFp.createChallengeTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a challenge
         * @param id The challenge id
         */
        deleteChallenge(params: {  "id": number; }, options?: any) {
            return CampaignsChallengesApiFp.deleteChallenge(params, options)(fetch, basePath);
        },
        /** 
         * Delete a challenge activity
         * @param activityId The activity id
         * @param challengeId The challenge id
         */
        deleteChallengeActivity(params: {  "activityId": number; "challengeId": number; }, options?: any) {
            return CampaignsChallengesApiFp.deleteChallengeActivity(params, options)(fetch, basePath);
        },
        /** 
         * Delete a challenge event
         * @param id The challenge event id
         */
        deleteChallengeEvent(params: {  "id": number; }, options?: any) {
            return CampaignsChallengesApiFp.deleteChallengeEvent(params, options)(fetch, basePath);
        },
        /** 
         * Delete a challenge template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteChallengeTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return CampaignsChallengesApiFp.deleteChallengeTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a challenge
         * @param id The challenge id
         */
        getChallenge(params: {  "id": number; }, options?: any) {
            return CampaignsChallengesApiFp.getChallenge(params, options)(fetch, basePath);
        },
        /** 
         * List and search challenge activities
         * @param challengeId The challenge id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeActivities(params: {  "challengeId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeActivities(params, options)(fetch, basePath);
        },
        /** 
         * Get a single challenge activity
         * @param activityId The activity id
         */
        getChallengeActivity(params: {  "activityId": number; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeActivity(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a single challenge event details
         * @param id The challenge event id
         */
        getChallengeEvent(params: {  "id": number; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeEvent(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a list of challenge events
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterCampaigns check only for events from currently running campaigns
         * @param filterChallenge check only for events from the challenge specified by id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEvents(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterCampaigns"?: boolean; "filterChallenge"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeEvents(params, options)(fetch, basePath);
        },
        /** 
         * Get a single challenge template
         * @param id The id of the template
         */
        getChallengeTemplate(params: {  "id": string; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search challenge templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsChallengesApiFp.getChallengeTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a list of challenges
         * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
         * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
         */
        getChallenges(params: {  "filterTemplate"?: boolean; "filterActiveCampaign"?: boolean; }, options?: any) {
            return CampaignsChallengesApiFp.getChallenges(params, options)(fetch, basePath);
        },
        /** 
         * Update a challenge
         * If the challenge is a copy, changes will propagate to all the related challenges
         * @param id The challenge id
         * @param challengeResource The challenge resource object
         */
        updateChallenge(params: {  "id": number; "challengeResource"?: ChallengeResource; }, options?: any) {
            return CampaignsChallengesApiFp.updateChallenge(params, options)(fetch, basePath);
        },
        /** 
         * Update a challenge activity
         * @param activityId The activity id
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         */
        updateChallengeActivity(params: {  "activityId": number; "challengeId": number; "challengeActivityResource"?: ChallengeActivityResource; }, options?: any) {
            return CampaignsChallengesApiFp.updateChallengeActivity(params, options)(fetch, basePath);
        },
        /** 
         * Update a challenge template
         * @param id The id of the template
         * @param challengeTemplateResource The challenge template resource object
         */
        updateChallengeTemplate(params: {  "id": string; "challengeTemplateResource"?: TemplateResource; }, options?: any) {
            return CampaignsChallengesApiFp.updateChallengeTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsRewardsApi - fetch parameter creator
 */
export const CampaignsRewardsApiFetchParamCreator = {
    /** 
     * Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  "rewardSetResource"?: RewardSetResource; }, options?: any): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  "id": number; "rewardSetResource"?: RewardSetResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsRewardsApi - functional programming interface
 */
export const CampaignsRewardsApiFp = {
    /** 
     * Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: { "rewardSetResource"?: RewardSetResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.createRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.deleteRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.getRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceRewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.getRewardSets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: { "id": number; "rewardSetResource"?: RewardSetResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.updateRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsRewardsApi - object-oriented interface
 */
export class CampaignsRewardsApi extends BaseAPI {
    /** 
     * Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  "rewardSetResource"?: RewardSetResource; }, options?: any) {
        return CampaignsRewardsApiFp.createRewardSet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  "id": number; }, options?: any) {
        return CampaignsRewardsApiFp.deleteRewardSet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  "id": number; }, options?: any) {
        return CampaignsRewardsApiFp.getRewardSet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CampaignsRewardsApiFp.getRewardSets(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  "id": number; "rewardSetResource"?: RewardSetResource; }, options?: any) {
        return CampaignsRewardsApiFp.updateRewardSet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsRewardsApi - factory interface
 */
export const CampaignsRewardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a reward set
         * @param rewardSetResource The reward set resource object
         */
        createRewardSet(params: {  "rewardSetResource"?: RewardSetResource; }, options?: any) {
            return CampaignsRewardsApiFp.createRewardSet(params, options)(fetch, basePath);
        },
        /** 
         * Delete a reward set
         * @param id The reward id
         */
        deleteRewardSet(params: {  "id": number; }, options?: any) {
            return CampaignsRewardsApiFp.deleteRewardSet(params, options)(fetch, basePath);
        },
        /** 
         * Get a single reward set
         * @param id The reward id
         */
        getRewardSet(params: {  "id": number; }, options?: any) {
            return CampaignsRewardsApiFp.getRewardSet(params, options)(fetch, basePath);
        },
        /** 
         * List and search reward sets
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRewardSets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CampaignsRewardsApiFp.getRewardSets(params, options)(fetch, basePath);
        },
        /** 
         * Update a reward set
         * @param id The reward id
         * @param rewardSetResource The reward set resource object
         */
        updateRewardSet(params: {  "id": number; "rewardSetResource"?: RewardSetResource; }, options?: any) {
            return CampaignsRewardsApiFp.updateRewardSet(params, options)(fetch, basePath);
        },
    };
};


/**
 * CategoriesApi - fetch parameter creator
 */
export const CategoriesApiFetchParamCreator = {
    /** 
     * Create a new category
     * @param category The category to create
     */
    createCategory(params: {  "category"?: CategoryResource; }, options?: any): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a category template
     * Templates define a type of category and the properties they have
     * @param template The template to create
     */
    createCategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  "filterSearch"?: string; "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_active": params["filterActive"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  "id": string; "category"?: CategoryResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = {
    /** 
     * Create a new category
     * @param category The category to create
     */
    createCategory(params: { "category"?: CategoryResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a category template
     * Templates define a type of category and the properties they have
     * @param template The template to create
     */
    createCategoryTemplate(params: { "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: { "filterSearch"?: string; "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: { "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourcestring> {
        const fetchArgs = CategoriesApiFetchParamCreator.getTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: { "id": string; "category"?: CategoryResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: { "id": string; "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /** 
     * Create a new category
     * @param category The category to create
     */
    createCategory(params: {  "category"?: CategoryResource; }, options?: any) {
        return CategoriesApiFp.createCategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a category template
     * Templates define a type of category and the properties they have
     * @param template The template to create
     */
    createCategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
        return CategoriesApiFp.createCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  "id": string; }, options?: any) {
        return CategoriesApiFp.deleteCategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a category template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return CategoriesApiFp.deleteCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  "filterSearch"?: string; "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CategoriesApiFp.getCategories(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  "id": string; }, options?: any) {
        return CategoriesApiFp.getCategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  "id": string; }, options?: any) {
        return CategoriesApiFp.getCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CategoriesApiFp.getCategoryTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  "size"?: number; "page"?: number; }, options?: any) {
        return CategoriesApiFp.getTags(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  "id": string; "category"?: CategoryResource; }, options?: any) {
        return CategoriesApiFp.updateCategory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
        return CategoriesApiFp.updateCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new category
         * @param category The category to create
         */
        createCategory(params: {  "category"?: CategoryResource; }, options?: any) {
            return CategoriesApiFp.createCategory(params, options)(fetch, basePath);
        },
        /** 
         * Create a category template
         * Templates define a type of category and the properties they have
         * @param template The template to create
         */
        createCategoryTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
            return CategoriesApiFp.createCategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing category
         * @param id The id of the category to be deleted
         */
        deleteCategory(params: {  "id": string; }, options?: any) {
            return CategoriesApiFp.deleteCategory(params, options)(fetch, basePath);
        },
        /** 
         * Delete a category template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCategoryTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return CategoriesApiFp.deleteCategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search categories with optional filters
         * @param filterSearch Filter for categories whose names begin with provided string
         * @param filterActive Filter for categories that are specifically active or inactive
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategories(params: {  "filterSearch"?: string; "filterActive"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CategoriesApiFp.getCategories(params, options)(fetch, basePath);
        },
        /** 
         * Get a single category
         * @param id The id of the category to retrieve
         */
        getCategory(params: {  "id": string; }, options?: any) {
            return CategoriesApiFp.getCategory(params, options)(fetch, basePath);
        },
        /** 
         * Get a single category template
         * @param id The id of the template
         */
        getCategoryTemplate(params: {  "id": string; }, options?: any) {
            return CategoriesApiFp.getCategoryTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search category templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategoryTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CategoriesApiFp.getCategoryTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List all trivia tags in the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getTags(params: {  "size"?: number; "page"?: number; }, options?: any) {
            return CategoriesApiFp.getTags(params, options)(fetch, basePath);
        },
        /** 
         * Update an existing category
         * @param id The id of the category
         * @param category The category to update
         */
        updateCategory(params: {  "id": string; "category"?: CategoryResource; }, options?: any) {
            return CategoriesApiFp.updateCategory(params, options)(fetch, basePath);
        },
        /** 
         * Update a category template
         * @param id The id of the template
         * @param template The updated template information
         */
        updateCategoryTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
            return CategoriesApiFp.updateCategoryTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * ConfigsApi - fetch parameter creator
 */
export const ConfigsApiFetchParamCreator = {
    /** 
     * Create a new config
     * @param config The config object
     */
    createConfig(params: {  "config"?: Config; }, options?: any): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single config
     * Only configs that are public readable will be shown without admin access
     * @param name The config name
     */
    getConfig(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  "filterSearch"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  "name": string; "config"?: Config; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ConfigsApi - functional programming interface
 */
export const ConfigsApiFp = {
    /** 
     * Create a new config
     * @param config The config object
     */
    createConfig(params: { "config"?: Config;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.createConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.deleteConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single config
     * Only configs that are public readable will be shown without admin access
     * @param name The config name
     */
    getConfig(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: { "filterSearch"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceConfig> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfigs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: { "name": string; "config"?: Config;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.updateConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ConfigsApi - object-oriented interface
 */
export class ConfigsApi extends BaseAPI {
    /** 
     * Create a new config
     * @param config The config object
     */
    createConfig(params: {  "config"?: Config; }, options?: any) {
        return ConfigsApiFp.createConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  "name": string; }, options?: any) {
        return ConfigsApiFp.deleteConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single config
     * Only configs that are public readable will be shown without admin access
     * @param name The config name
     */
    getConfig(params: {  "name": string; }, options?: any) {
        return ConfigsApiFp.getConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  "filterSearch"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ConfigsApiFp.getConfigs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  "name": string; "config"?: Config; }, options?: any) {
        return ConfigsApiFp.updateConfig(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ConfigsApi - factory interface
 */
export const ConfigsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new config
         * @param config The config object
         */
        createConfig(params: {  "config"?: Config; }, options?: any) {
            return ConfigsApiFp.createConfig(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing config
         * @param name The config name
         */
        deleteConfig(params: {  "name": string; }, options?: any) {
            return ConfigsApiFp.deleteConfig(params, options)(fetch, basePath);
        },
        /** 
         * Get a single config
         * Only configs that are public readable will be shown without admin access
         * @param name The config name
         */
        getConfig(params: {  "name": string; }, options?: any) {
            return ConfigsApiFp.getConfig(params, options)(fetch, basePath);
        },
        /** 
         * List and search configs
         * @param filterSearch Filter for configs whose name contains the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getConfigs(params: {  "filterSearch"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ConfigsApiFp.getConfigs(params, options)(fetch, basePath);
        },
        /** 
         * Update an existing config
         * @param name The config name
         * @param config The config object
         */
        updateConfig(params: {  "name": string; "config"?: Config; }, options?: any) {
            return ConfigsApiFp.updateConfig(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentArticlesApi - fetch parameter creator
 */
export const ContentArticlesApiFetchParamCreator = {
    /** 
     * Create a new article
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param articleResource The new article
     */
    createArticle(params: {  "articleResource"?: ArticleResource; }, options?: any): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an article template
     * Article Templates define a type of article and the properties they have
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  "articleTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an article template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single article
     * @param id The article id
     */
    getArticle(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search articles
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single article&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with specified tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterTitle"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_category": params["filterCategory"],
            "filter_tagset": params["filterTagset"],
            "filter_title": params["filterTitle"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  "id": string; "articleResource"?: ArticleResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  "id": string; "articleTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentArticlesApi - functional programming interface
 */
export const ContentArticlesApiFp = {
    /** 
     * Create a new article
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param articleResource The new article
     */
    createArticle(params: { "articleResource"?: ArticleResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.createArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an article template
     * Article Templates define a type of article and the properties they have
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: { "articleTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.createArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.deleteArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an article template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.deleteArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single article
     * @param id The article id
     */
    getArticle(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticleTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search articles
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single article&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with specified tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: { "filterCategory"?: string; "filterTagset"?: string; "filterTitle"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: { "id": string; "articleResource"?: ArticleResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.updateArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: { "id": string; "articleTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.updateArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentArticlesApi - object-oriented interface
 */
export class ContentArticlesApi extends BaseAPI {
    /** 
     * Create a new article
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param articleResource The new article
     */
    createArticle(params: {  "articleResource"?: ArticleResource; }, options?: any) {
        return ContentArticlesApiFp.createArticle(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an article template
     * Article Templates define a type of article and the properties they have
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  "articleTemplateResource"?: TemplateResource; }, options?: any) {
        return ContentArticlesApiFp.createArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  "id": string; }, options?: any) {
        return ContentArticlesApiFp.deleteArticle(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an article template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return ContentArticlesApiFp.deleteArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single article
     * @param id The article id
     */
    getArticle(params: {  "id": string; }, options?: any) {
        return ContentArticlesApiFp.getArticle(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  "id": string; }, options?: any) {
        return ContentArticlesApiFp.getArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ContentArticlesApiFp.getArticleTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search articles
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single article&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with specified tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterTitle"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ContentArticlesApiFp.getArticles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  "id": string; "articleResource"?: ArticleResource; }, options?: any) {
        return ContentArticlesApiFp.updateArticle(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  "id": string; "articleTemplateResource"?: TemplateResource; }, options?: any) {
        return ContentArticlesApiFp.updateArticleTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentArticlesApi - factory interface
 */
export const ContentArticlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new article
         * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
         * @param articleResource The new article
         */
        createArticle(params: {  "articleResource"?: ArticleResource; }, options?: any) {
            return ContentArticlesApiFp.createArticle(params, options)(fetch, basePath);
        },
        /** 
         * Create an article template
         * Article Templates define a type of article and the properties they have
         * @param articleTemplateResource The article template resource object
         */
        createArticleTemplate(params: {  "articleTemplateResource"?: TemplateResource; }, options?: any) {
            return ContentArticlesApiFp.createArticleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing article
         * @param id The article id
         */
        deleteArticle(params: {  "id": string; }, options?: any) {
            return ContentArticlesApiFp.deleteArticle(params, options)(fetch, basePath);
        },
        /** 
         * Delete an article template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArticleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return ContentArticlesApiFp.deleteArticleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single article
         * @param id The article id
         */
        getArticle(params: {  "id": string; }, options?: any) {
            return ContentArticlesApiFp.getArticle(params, options)(fetch, basePath);
        },
        /** 
         * Get a single article template
         * @param id The id of the template
         */
        getArticleTemplate(params: {  "id": string; }, options?: any) {
            return ContentArticlesApiFp.getArticleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search article templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ContentArticlesApiFp.getArticleTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List and search articles
         * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single article&#39; to retrieve the full resource with assets for a given item as needed.
         * @param filterCategory Filter for articles from a specific category by id
         * @param filterTagset Filter for articles with specified tags (separated by comma)
         * @param filterTitle Filter for articles whose title contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticles(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterTitle"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ContentArticlesApiFp.getArticles(params, options)(fetch, basePath);
        },
        /** 
         * Update an existing article
         * @param id The article id
         * @param articleResource The article object
         */
        updateArticle(params: {  "id": string; "articleResource"?: ArticleResource; }, options?: any) {
            return ContentArticlesApiFp.updateArticle(params, options)(fetch, basePath);
        },
        /** 
         * Update an article template
         * @param id The id of the template
         * @param articleTemplateResource The article template resource object
         */
        updateArticleTemplate(params: {  "id": string; "articleTemplateResource"?: TemplateResource; }, options?: any) {
            return ContentArticlesApiFp.updateArticleTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentCommentsApi - fetch parameter creator
 */
export const ContentCommentsApiFetchParamCreator = {
    /** 
     * Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  "commentResource"?: CommentResource; }, options?: any): FetchArgs {
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Return a comment
     * @param id The comment id
     */
    getComment(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  "context": string; "contextId": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "context" is set
        if (params["context"] == null) {
            throw new Error("Missing required parameter context when calling getComments");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getComments");
        }
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "context": params["context"],
            "context_id": params["contextId"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Search the comment index
     * The body is an ElasticSearch query json. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: {  "query"?: any; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/comments/search`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  "id": number; "content"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateComment");
        }
        const baseUrl = `/comments/{id}/content`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentCommentsApi - functional programming interface
 */
export const ContentCommentsApiFp = {
    /** 
     * Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: { "commentResource"?: CommentResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.addComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a comment
     * @param id The comment id
     */
    deleteComment(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.deleteComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Return a comment
     * @param id The comment id
     */
    getComment(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.getComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: { "context": string; "contextId": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.getComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Search the comment index
     * The body is an ElasticSearch query json. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: { "query"?: any; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentSearch> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.searchComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: { "id": number; "content"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.updateComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentCommentsApi - object-oriented interface
 */
export class ContentCommentsApi extends BaseAPI {
    /** 
     * Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  "commentResource"?: CommentResource; }, options?: any) {
        return ContentCommentsApiFp.addComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  "id": number; }, options?: any) {
        return ContentCommentsApiFp.deleteComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Return a comment
     * @param id The comment id
     */
    getComment(params: {  "id": number; }, options?: any) {
        return ContentCommentsApiFp.getComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  "context": string; "contextId": number; "size"?: number; "page"?: number; }, options?: any) {
        return ContentCommentsApiFp.getComments(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Search the comment index
     * The body is an ElasticSearch query json. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: {  "query"?: any; "size"?: number; "page"?: number; }, options?: any) {
        return ContentCommentsApiFp.searchComments(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  "id": number; "content"?: string; }, options?: any) {
        return ContentCommentsApiFp.updateComment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentCommentsApi - factory interface
 */
export const ContentCommentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a new comment
         * @param commentResource The comment to be added
         */
        addComment(params: {  "commentResource"?: CommentResource; }, options?: any) {
            return ContentCommentsApiFp.addComment(params, options)(fetch, basePath);
        },
        /** 
         * Delete a comment
         * @param id The comment id
         */
        deleteComment(params: {  "id": number; }, options?: any) {
            return ContentCommentsApiFp.deleteComment(params, options)(fetch, basePath);
        },
        /** 
         * Return a comment
         * @param id The comment id
         */
        getComment(params: {  "id": number; }, options?: any) {
            return ContentCommentsApiFp.getComment(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of comments
         * @param context Get comments by context type
         * @param contextId Get comments by context id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getComments(params: {  "context": string; "contextId": number; "size"?: number; "page"?: number; }, options?: any) {
            return ContentCommentsApiFp.getComments(params, options)(fetch, basePath);
        },
        /** 
         * Search the comment index
         * The body is an ElasticSearch query json. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options
         * @param query The search query
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        searchComments(params: {  "query"?: any; "size"?: number; "page"?: number; }, options?: any) {
            return ContentCommentsApiFp.searchComments(params, options)(fetch, basePath);
        },
        /** 
         * Update a comment
         * @param id The comment id
         * @param content The comment content
         */
        updateComment(params: {  "id": number; "content"?: string; }, options?: any) {
            return ContentCommentsApiFp.updateComment(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentPollsApi - fetch parameter creator
 */
export const ContentPollsApiFetchParamCreator = {
    /** 
     * Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  "id": string; "answerKey"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling answerPoll");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answerKey"]) {
            fetchOptions.body = JSON.stringify(params["answerKey"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a new poll
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param pollResource The poll object
     */
    createPoll(params: {  "pollResource"?: PollResource; }, options?: any): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a poll template
     * Poll templates define a type of poll and the properties they have
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  "pollTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a poll template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollAnswer");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search polls
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterText"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_category": params["filterCategory"],
            "filter_tagset": params["filterTagset"],
            "filter_text": params["filterText"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  "id": string; "pollResource"?: PollResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  "id": string; "pollTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentPollsApi - functional programming interface
 */
export const ContentPollsApiFp = {
    /** 
     * Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: { "id": string; "answerKey"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.answerPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a new poll
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param pollResource The poll object
     */
    createPoll(params: { "pollResource"?: PollResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.createPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a poll template
     * Poll templates define a type of poll and the properties they have
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: { "pollTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.createPollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.deletePoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a poll template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.deletePollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single poll
     * @param id The poll id
     */
    getPoll(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search polls
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: { "filterCategory"?: string; "filterTagset"?: string; "filterText"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourcePollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPolls(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: { "id": string; "pollResource"?: PollResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.updatePoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: { "id": string; "pollTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.updatePollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentPollsApi - object-oriented interface
 */
export class ContentPollsApi extends BaseAPI {
    /** 
     * Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  "id": string; "answerKey"?: string; }, options?: any) {
        return ContentPollsApiFp.answerPoll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a new poll
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @param pollResource The poll object
     */
    createPoll(params: {  "pollResource"?: PollResource; }, options?: any) {
        return ContentPollsApiFp.createPoll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a poll template
     * Poll templates define a type of poll and the properties they have
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  "pollTemplateResource"?: TemplateResource; }, options?: any) {
        return ContentPollsApiFp.createPollTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  "id": string; }, options?: any) {
        return ContentPollsApiFp.deletePoll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a poll template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return ContentPollsApiFp.deletePollTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  "id": string; }, options?: any) {
        return ContentPollsApiFp.getPoll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  "id": string; }, options?: any) {
        return ContentPollsApiFp.getPollAnswer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  "id": string; }, options?: any) {
        return ContentPollsApiFp.getPollTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ContentPollsApiFp.getPollTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search polls
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterText"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return ContentPollsApiFp.getPolls(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  "id": string; "pollResource"?: PollResource; }, options?: any) {
        return ContentPollsApiFp.updatePoll(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  "id": string; "pollTemplateResource"?: TemplateResource; }, options?: any) {
        return ContentPollsApiFp.updatePollTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentPollsApi - factory interface
 */
export const ContentPollsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add your vote to a poll
         * @param id The poll id
         * @param answerKey The answer key
         */
        answerPoll(params: {  "id": string; "answerKey"?: string; }, options?: any) {
            return ContentPollsApiFp.answerPoll(params, options)(fetch, basePath);
        },
        /** 
         * Create a new poll
         * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
         * @param pollResource The poll object
         */
        createPoll(params: {  "pollResource"?: PollResource; }, options?: any) {
            return ContentPollsApiFp.createPoll(params, options)(fetch, basePath);
        },
        /** 
         * Create a poll template
         * Poll templates define a type of poll and the properties they have
         * @param pollTemplateResource The poll template resource object
         */
        createPollTemplate(params: {  "pollTemplateResource"?: TemplateResource; }, options?: any) {
            return ContentPollsApiFp.createPollTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing poll
         * @param id The poll id
         */
        deletePoll(params: {  "id": string; }, options?: any) {
            return ContentPollsApiFp.deletePoll(params, options)(fetch, basePath);
        },
        /** 
         * Delete a poll template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deletePollTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return ContentPollsApiFp.deletePollTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single poll
         * @param id The poll id
         */
        getPoll(params: {  "id": string; }, options?: any) {
            return ContentPollsApiFp.getPoll(params, options)(fetch, basePath);
        },
        /** 
         * Get poll answer
         * @param id The poll id
         */
        getPollAnswer(params: {  "id": string; }, options?: any) {
            return ContentPollsApiFp.getPollAnswer(params, options)(fetch, basePath);
        },
        /** 
         * Get a single poll template
         * @param id The id of the template
         */
        getPollTemplate(params: {  "id": string; }, options?: any) {
            return ContentPollsApiFp.getPollTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search poll templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPollTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ContentPollsApiFp.getPollTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List and search polls
         * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
         * @param filterCategory Filter for polls from a specific category by id
         * @param filterTagset Filter for polls with specified tags (separated by comma)
         * @param filterText Filter for polls whose text contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPolls(params: {  "filterCategory"?: string; "filterTagset"?: string; "filterText"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return ContentPollsApiFp.getPolls(params, options)(fetch, basePath);
        },
        /** 
         * Update an existing poll
         * @param id The poll id
         * @param pollResource The poll object
         */
        updatePoll(params: {  "id": string; "pollResource"?: PollResource; }, options?: any) {
            return ContentPollsApiFp.updatePoll(params, options)(fetch, basePath);
        },
        /** 
         * Update a poll template
         * @param id The id of the template
         * @param pollTemplateResource The poll template resource object
         */
        updatePollTemplate(params: {  "id": string; "pollTemplateResource"?: TemplateResource; }, options?: any) {
            return ContentPollsApiFp.updatePollTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CurrenciesApi - fetch parameter creator
 */
export const CurrenciesApiFetchParamCreator = {
    /** 
     * Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  "currency"?: CurrencyResource; }, options?: any): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  "filterEnabledCurrencies"?: boolean; "filterType"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_enabled_currencies": params["filterEnabledCurrencies"],
            "filter_type": params["filterType"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  "code": string; "currency"?: CurrencyResource; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CurrenciesApi - functional programming interface
 */
export const CurrenciesApiFp = {
    /** 
     * Create a currency
     * @param currency The currency object
     */
    createCurrency(params: { "currency"?: CurrencyResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.createCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: { "code": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.deleteCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: { "filterEnabledCurrencies"?: boolean; "filterType"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrencies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single currency
     * @param code The currency code
     */
    getCurrency(params: { "code": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: { "code": string; "currency"?: CurrencyResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.updateCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CurrenciesApi - object-oriented interface
 */
export class CurrenciesApi extends BaseAPI {
    /** 
     * Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  "currency"?: CurrencyResource; }, options?: any) {
        return CurrenciesApiFp.createCurrency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  "code": string; }, options?: any) {
        return CurrenciesApiFp.deleteCurrency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  "filterEnabledCurrencies"?: boolean; "filterType"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return CurrenciesApiFp.getCurrencies(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  "code": string; }, options?: any) {
        return CurrenciesApiFp.getCurrency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  "code": string; "currency"?: CurrencyResource; }, options?: any) {
        return CurrenciesApiFp.updateCurrency(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CurrenciesApi - factory interface
 */
export const CurrenciesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a currency
         * @param currency The currency object
         */
        createCurrency(params: {  "currency"?: CurrencyResource; }, options?: any) {
            return CurrenciesApiFp.createCurrency(params, options)(fetch, basePath);
        },
        /** 
         * Delete a currency
         * @param code The currency code
         */
        deleteCurrency(params: {  "code": string; }, options?: any) {
            return CurrenciesApiFp.deleteCurrency(params, options)(fetch, basePath);
        },
        /** 
         * List and search currencies
         * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
         * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCurrencies(params: {  "filterEnabledCurrencies"?: boolean; "filterType"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return CurrenciesApiFp.getCurrencies(params, options)(fetch, basePath);
        },
        /** 
         * Get a single currency
         * @param code The currency code
         */
        getCurrency(params: {  "code": string; }, options?: any) {
            return CurrenciesApiFp.getCurrency(params, options)(fetch, basePath);
        },
        /** 
         * Update a currency
         * @param code The currency code
         * @param currency The currency object
         */
        updateCurrency(params: {  "code": string; "currency"?: CurrencyResource; }, options?: any) {
            return CurrenciesApiFp.updateCurrency(params, options)(fetch, basePath);
        },
    };
};


/**
 * DevicesApi - fetch parameter creator
 */
export const DevicesApiFetchParamCreator = {
    /** 
     * Create a device
     * @param device device
     */
    createDevice(params: {  "device": DeviceResource; }, options?: any): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling createDevice");
        }
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a device
     * @param id id
     */
    deleteDevice(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single device
     * @param id id
     */
    getDevice(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search devices
     * Get a list of devices with optional filtering
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  "filterMake"?: string; "filterModel"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_make": params["filterMake"],
            "filter_model": params["filterModel"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  "device": DeviceResource; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling updateDevice");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = {
    /** 
     * Create a device
     * @param device device
     */
    createDevice(params: { "device": DeviceResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.createDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a device
     * @param id id
     */
    deleteDevice(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single device
     * @param id id
     */
    getDevice(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search devices
     * Get a list of devices with optional filtering
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: { "filterMake"?: string; "filterModel"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceDeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevices(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: { "device": DeviceResource; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.updateDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /** 
     * Create a device
     * @param device device
     */
    createDevice(params: {  "device": DeviceResource; }, options?: any) {
        return DevicesApiFp.createDevice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a device
     * @param id id
     */
    deleteDevice(params: {  "id": number; }, options?: any) {
        return DevicesApiFp.deleteDevice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single device
     * @param id id
     */
    getDevice(params: {  "id": number; }, options?: any) {
        return DevicesApiFp.getDevice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search devices
     * Get a list of devices with optional filtering
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  "filterMake"?: string; "filterModel"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return DevicesApiFp.getDevices(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  "device": DeviceResource; "id": number; }, options?: any) {
        return DevicesApiFp.updateDevice(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a device
         * @param device device
         */
        createDevice(params: {  "device": DeviceResource; }, options?: any) {
            return DevicesApiFp.createDevice(params, options)(fetch, basePath);
        },
        /** 
         * Delete a device
         * @param id id
         */
        deleteDevice(params: {  "id": number; }, options?: any) {
            return DevicesApiFp.deleteDevice(params, options)(fetch, basePath);
        },
        /** 
         * Get a single device
         * @param id id
         */
        getDevice(params: {  "id": number; }, options?: any) {
            return DevicesApiFp.getDevice(params, options)(fetch, basePath);
        },
        /** 
         * List and search devices
         * Get a list of devices with optional filtering
         * @param filterMake Filter for devices with specified make
         * @param filterModel Filter for devices with specified model
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDevices(params: {  "filterMake"?: string; "filterModel"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return DevicesApiFp.getDevices(params, options)(fetch, basePath);
        },
        /** 
         * Update a device
         * @param device device
         * @param id id
         */
        updateDevice(params: {  "device": DeviceResource; "id": number; }, options?: any) {
            return DevicesApiFp.updateDevice(params, options)(fetch, basePath);
        },
    };
};


/**
 * DispositionsApi - fetch parameter creator
 */
export const DispositionsApiFetchParamCreator = {
    /** 
     * Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  "disposition"?: DispositionResource; }, options?: any): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["disposition"]) {
            fetchOptions.body = JSON.stringify(params["disposition"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  "filterContext"?: string; "filterOwner"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/dispositions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_context": params["filterContext"],
            "filter_owner": params["filterOwner"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  "filterContext"?: string; "filterOwner"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_context": params["filterContext"],
            "filter_owner": params["filterOwner"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DispositionsApi - functional programming interface
 */
export const DispositionsApiFp = {
    /** 
     * Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: { "disposition"?: DispositionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.addDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DispositionsApiFetchParamCreator.deleteDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: { "filterContext"?: string; "filterOwner"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DispositionCount>> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositionCounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: { "filterContext"?: string; "filterOwner"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DispositionsApi - object-oriented interface
 */
export class DispositionsApi extends BaseAPI {
    /** 
     * Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  "disposition"?: DispositionResource; }, options?: any) {
        return DispositionsApiFp.addDisposition(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  "id": number; }, options?: any) {
        return DispositionsApiFp.deleteDisposition(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  "id": number; }, options?: any) {
        return DispositionsApiFp.getDisposition(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  "filterContext"?: string; "filterOwner"?: string; }, options?: any) {
        return DispositionsApiFp.getDispositionCounts(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  "filterContext"?: string; "filterOwner"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return DispositionsApiFp.getDispositions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DispositionsApi - factory interface
 */
export const DispositionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a new disposition
         * @param disposition The new disposition record
         */
        addDisposition(params: {  "disposition"?: DispositionResource; }, options?: any) {
            return DispositionsApiFp.addDisposition(params, options)(fetch, basePath);
        },
        /** 
         * Delete a disposition
         * @param id The id of the disposition record
         */
        deleteDisposition(params: {  "id": number; }, options?: any) {
            return DispositionsApiFp.deleteDisposition(params, options)(fetch, basePath);
        },
        /** 
         * Returns a disposition
         * @param id The id of the disposition record
         */
        getDisposition(params: {  "id": number; }, options?: any) {
            return DispositionsApiFp.getDisposition(params, options)(fetch, basePath);
        },
        /** 
         * Returns a list of disposition counts
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         */
        getDispositionCounts(params: {  "filterContext"?: string; "filterOwner"?: string; }, options?: any) {
            return DispositionsApiFp.getDispositionCounts(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of dispositions
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDispositions(params: {  "filterContext"?: string; "filterOwner"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return DispositionsApiFp.getDispositions(params, options)(fetch, basePath);
        },
    };
};


/**
 * FulfillmentApi - fetch parameter creator
 */
export const FulfillmentApiFetchParamCreator = {
    /** 
     * Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  "type"?: FulfillmentType; }, options?: any): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["type"]) {
            fetchOptions.body = JSON.stringify(params["type"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  "id": number; "fulfillmentType"?: FulfillmentType; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["fulfillmentType"]) {
            fetchOptions.body = JSON.stringify(params["fulfillmentType"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FulfillmentApi - functional programming interface
 */
export const FulfillmentApiFp = {
    /** 
     * Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: { "type"?: FulfillmentType;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.createFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.deleteFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceFulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentTypes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: { "id": number; "fulfillmentType"?: FulfillmentType;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.updateFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FulfillmentApi - object-oriented interface
 */
export class FulfillmentApi extends BaseAPI {
    /** 
     * Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  "type"?: FulfillmentType; }, options?: any) {
        return FulfillmentApiFp.createFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  "id": number; }, options?: any) {
        return FulfillmentApiFp.deleteFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  "id": number; }, options?: any) {
        return FulfillmentApiFp.getFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return FulfillmentApiFp.getFulfillmentTypes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  "id": number; "fulfillmentType"?: FulfillmentType; }, options?: any) {
        return FulfillmentApiFp.updateFulfillmentType(params, options)(this.fetch, this.basePath);
    }
};

/**
 * FulfillmentApi - factory interface
 */
export const FulfillmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a fulfillment type
         * @param type The fulfillment type
         */
        createFulfillmentType(params: {  "type"?: FulfillmentType; }, options?: any) {
            return FulfillmentApiFp.createFulfillmentType(params, options)(fetch, basePath);
        },
        /** 
         * Delete a fulfillment type
         * @param id The id
         */
        deleteFulfillmentType(params: {  "id": number; }, options?: any) {
            return FulfillmentApiFp.deleteFulfillmentType(params, options)(fetch, basePath);
        },
        /** 
         * Get a single fulfillment type
         * @param id The id
         */
        getFulfillmentType(params: {  "id": number; }, options?: any) {
            return FulfillmentApiFp.getFulfillmentType(params, options)(fetch, basePath);
        },
        /** 
         * List and search fulfillment types
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getFulfillmentTypes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return FulfillmentApiFp.getFulfillmentTypes(params, options)(fetch, basePath);
        },
        /** 
         * Update a fulfillment type
         * @param id The id
         * @param fulfillmentType The fulfillment type
         */
        updateFulfillmentType(params: {  "id": number; "fulfillmentType"?: FulfillmentType; }, options?: any) {
            return FulfillmentApiFp.updateFulfillmentType(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationAchievementsApi - fetch parameter creator
 */
export const GamificationAchievementsApiFetchParamCreator = {
    /** 
     * Create a new achievement definition
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
     * @param achievement The achievement definition
     */
    createAchievement(params: {  "achievement"?: AchievementDefinitionResource; }, options?: any): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an achievement template
     * Achievement templates define a type of achievement and the properties they have
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  "template"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an achievement definition
     * Will also disable the associated generated rule, if any.
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an achievement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options?: any): FetchArgs {
        const baseUrl = `/achievements/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param filterDerived Filter for achievements that are derived from other services
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievements(params: {  "filterTagset"?: string; "filterName"?: string; "filterHidden"?: boolean; "filterDerived"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_tagset": params["filterTagset"],
            "filter_name": params["filterName"],
            "filter_hidden": params["filterHidden"],
            "filter_derived": params["filterDerived"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of derived achievements
     * Used by other services that depend on achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getDerivedAchievements");
        }
        const baseUrl = `/achievements/derived/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve progress on a given achievement for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  "userId": number; "achievementName": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUserAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve progress on achievements for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  "userId": number; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementsProgress");
        }
        const baseUrl = `/users/{user_id}/achievements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_achievement_derived": params["filterAchievementDerived"],
            "filter_achievement_tagset": params["filterAchievementTagset"],
            "filter_achievement_name": params["filterAchievementName"],
            "filter_achievement_hidden": params["filterAchievementHidden"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve progress on a given achievement for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  "achievementName": string; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUsersAchievementProgress");
        }
        const baseUrl = `/users/achievements/{achievement_name}`
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_achievement_derived": params["filterAchievementDerived"],
            "filter_achievement_tagset": params["filterAchievementTagset"],
            "filter_achievement_hidden": params["filterAchievementHidden"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve progress on achievements for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/users/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_achievement_derived": params["filterAchievementDerived"],
            "filter_achievement_tagset": params["filterAchievementTagset"],
            "filter_achievement_name": params["filterAchievementName"],
            "filter_achievement_hidden": params["filterAchievementHidden"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an achievement definition
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  "name": string; "achievement"?: AchievementDefinitionResource; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update or create an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param request The progress update details
     */
    updateAchievementProgress(params: {  "userId": number; "achievementName": string; "request"?: AchievementProgressUpdateRequest; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling updateAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationAchievementsApi - functional programming interface
 */
export const GamificationAchievementsApiFp = {
    /** 
     * Create a new achievement definition
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
     * @param achievement The achievement definition
     */
    createAchievement(params: { "achievement"?: AchievementDefinitionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.createAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an achievement template
     * Achievement templates define a type of achievement and the properties they have
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: { "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.createAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an achievement definition
     * Will also disable the associated generated rule, if any.
     * @param name The name of the achievement
     */
    deleteAchievement(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.deleteAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an achievement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.deleteAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTriggers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param filterDerived Filter for achievements that are derived from other services
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievements(params: { "filterTagset"?: string; "filterName"?: string; "filterHidden"?: boolean; "filterDerived"?: boolean; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceAchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievements(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of derived achievements
     * Used by other services that depend on achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AchievementDefinitionResource>> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getDerivedAchievements(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve progress on a given achievement for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: { "userId": number; "achievementName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUserAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve progress on achievements for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: { "userId": number; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUserAchievementsProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve progress on a given achievement for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: { "achievementName": string; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUsersAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve progress on achievements for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: { "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUsersAchievementsProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an achievement definition
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: { "name": string; "achievement"?: AchievementDefinitionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.updateAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update or create an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param request The progress update details
     */
    updateAchievementProgress(params: { "userId": number; "achievementName": string; "request"?: AchievementProgressUpdateRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.updateAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: { "id": string; "template"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.updateAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationAchievementsApi - object-oriented interface
 */
export class GamificationAchievementsApi extends BaseAPI {
    /** 
     * Create a new achievement definition
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
     * @param achievement The achievement definition
     */
    createAchievement(params: {  "achievement"?: AchievementDefinitionResource; }, options?: any) {
        return GamificationAchievementsApiFp.createAchievement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an achievement template
     * Achievement templates define a type of achievement and the properties they have
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
        return GamificationAchievementsApiFp.createAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an achievement definition
     * Will also disable the associated generated rule, if any.
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  "name": string; }, options?: any) {
        return GamificationAchievementsApiFp.deleteAchievement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an achievement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return GamificationAchievementsApiFp.deleteAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  "name": string; }, options?: any) {
        return GamificationAchievementsApiFp.getAchievement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  "id": string; }, options?: any) {
        return GamificationAchievementsApiFp.getAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return GamificationAchievementsApiFp.getAchievementTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options?: any) {
        return GamificationAchievementsApiFp.getAchievementTriggers(options)(this.fetch, this.basePath);
    }
    /** 
     * Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param filterDerived Filter for achievements that are derived from other services
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievements(params: {  "filterTagset"?: string; "filterName"?: string; "filterHidden"?: boolean; "filterDerived"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return GamificationAchievementsApiFp.getAchievements(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of derived achievements
     * Used by other services that depend on achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  "name": string; }, options?: any) {
        return GamificationAchievementsApiFp.getDerivedAchievements(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve progress on a given achievement for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  "userId": number; "achievementName": string; }, options?: any) {
        return GamificationAchievementsApiFp.getUserAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve progress on achievements for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  "userId": number; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return GamificationAchievementsApiFp.getUserAchievementsProgress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve progress on a given achievement for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  "achievementName": string; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return GamificationAchievementsApiFp.getUsersAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve progress on achievements for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param filterAchievementHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return GamificationAchievementsApiFp.getUsersAchievementsProgress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an achievement definition
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  "name": string; "achievement"?: AchievementDefinitionResource; }, options?: any) {
        return GamificationAchievementsApiFp.updateAchievement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update or create an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param request The progress update details
     */
    updateAchievementProgress(params: {  "userId": number; "achievementName": string; "request"?: AchievementProgressUpdateRequest; }, options?: any) {
        return GamificationAchievementsApiFp.updateAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
        return GamificationAchievementsApiFp.updateAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationAchievementsApi - factory interface
 */
export const GamificationAchievementsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new achievement definition
         * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
         * @param achievement The achievement definition
         */
        createAchievement(params: {  "achievement"?: AchievementDefinitionResource; }, options?: any) {
            return GamificationAchievementsApiFp.createAchievement(params, options)(fetch, basePath);
        },
        /** 
         * Create an achievement template
         * Achievement templates define a type of achievement and the properties they have
         * @param template The achievement template to be created
         */
        createAchievementTemplate(params: {  "template"?: TemplateResource; }, options?: any) {
            return GamificationAchievementsApiFp.createAchievementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an achievement definition
         * Will also disable the associated generated rule, if any.
         * @param name The name of the achievement
         */
        deleteAchievement(params: {  "name": string; }, options?: any) {
            return GamificationAchievementsApiFp.deleteAchievement(params, options)(fetch, basePath);
        },
        /** 
         * Delete an achievement template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteAchievementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return GamificationAchievementsApiFp.deleteAchievementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single achievement definition
         * @param name The name of the achievement
         */
        getAchievement(params: {  "name": string; }, options?: any) {
            return GamificationAchievementsApiFp.getAchievement(params, options)(fetch, basePath);
        },
        /** 
         * Get a single achievement template
         * @param id The id of the template
         */
        getAchievementTemplate(params: {  "id": string; }, options?: any) {
            return GamificationAchievementsApiFp.getAchievementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search achievement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAchievementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return GamificationAchievementsApiFp.getAchievementTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Get the list of triggers that can be used to trigger an achievement progress update
         */
        getAchievementTriggers(options?: any) {
            return GamificationAchievementsApiFp.getAchievementTriggers(options)(fetch, basePath);
        },
        /** 
         * Get all achievement definitions in the system
         * @param filterTagset Filter for achievements with specified tags (separated by comma)
         * @param filterName Filter for achievements whose name contains a string
         * @param filterHidden Filter for achievements that are hidden or not
         * @param filterDerived Filter for achievements that are derived from other services
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAchievements(params: {  "filterTagset"?: string; "filterName"?: string; "filterHidden"?: boolean; "filterDerived"?: boolean; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return GamificationAchievementsApiFp.getAchievements(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of derived achievements
         * Used by other services that depend on achievements
         * @param name The name of the derived achievement
         */
        getDerivedAchievements(params: {  "name": string; }, options?: any) {
            return GamificationAchievementsApiFp.getDerivedAchievements(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve progress on a given achievement for a given user
         * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         */
        getUserAchievementProgress(params: {  "userId": number; "achievementName": string; }, options?: any) {
            return GamificationAchievementsApiFp.getUserAchievementProgress(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve progress on achievements for a given user
         * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
         * @param userId The user&#39;s id
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param filterAchievementHidden Filter for achievements that are hidden or not
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserAchievementsProgress(params: {  "userId": number; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return GamificationAchievementsApiFp.getUserAchievementsProgress(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve progress on a given achievement for all users
         * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
         * @param achievementName The achievement&#39;s name
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementHidden Filter for achievements that are hidden or not
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementProgress(params: {  "achievementName": string; "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return GamificationAchievementsApiFp.getUsersAchievementProgress(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve progress on achievements for all users
         * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param filterAchievementHidden Filter for achievements that are hidden or not
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementsProgress(params: {  "filterAchievementDerived"?: boolean; "filterAchievementTagset"?: string; "filterAchievementName"?: string; "filterAchievementHidden"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return GamificationAchievementsApiFp.getUsersAchievementsProgress(params, options)(fetch, basePath);
        },
        /** 
         * Update an achievement definition
         * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
         * @param name The name of the achievement
         * @param achievement The achievement definition
         */
        updateAchievement(params: {  "name": string; "achievement"?: AchievementDefinitionResource; }, options?: any) {
            return GamificationAchievementsApiFp.updateAchievement(params, options)(fetch, basePath);
        },
        /** 
         * Update or create an achievement progress record for a user
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         * @param request The progress update details
         */
        updateAchievementProgress(params: {  "userId": number; "achievementName": string; "request"?: AchievementProgressUpdateRequest; }, options?: any) {
            return GamificationAchievementsApiFp.updateAchievementProgress(params, options)(fetch, basePath);
        },
        /** 
         * Update an achievement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateAchievementTemplate(params: {  "id": string; "template"?: TemplateResource; }, options?: any) {
            return GamificationAchievementsApiFp.updateAchievementTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationLeaderboardsApi - fetch parameter creator
 */
export const GamificationLeaderboardsApiFetchParamCreator = {
    /** 
     * Retrieves leaderboard details and paginated entries
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard.
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getLeaderboard(params: {  "contextType": string; "contextId": string; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboard");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboard");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieves a specific user entry with rank
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  "contextType": string; "contextId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboardRank");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboardRank");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getLeaderboardRank");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}/users/{id}/rank`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options?: any): FetchArgs {
        const baseUrl = `/leaderboards/strategies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationLeaderboardsApi - functional programming interface
 */
export const GamificationLeaderboardsApiFp = {
    /** 
     * Retrieves leaderboard details and paginated entries
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard.
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getLeaderboard(params: { "contextType": string; "contextId": string; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardResource> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieves a specific user entry with rank
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: { "contextType": string; "contextId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardEntryResource> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboardRank(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboardStrategies(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationLeaderboardsApi - object-oriented interface
 */
export class GamificationLeaderboardsApi extends BaseAPI {
    /** 
     * Retrieves leaderboard details and paginated entries
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard.
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getLeaderboard(params: {  "contextType": string; "contextId": string; "size"?: number; "page"?: number; }, options?: any) {
        return GamificationLeaderboardsApiFp.getLeaderboard(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieves a specific user entry with rank
     * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  "contextType": string; "contextId": string; "id": string; }, options?: any) {
        return GamificationLeaderboardsApiFp.getLeaderboardRank(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options?: any) {
        return GamificationLeaderboardsApiFp.getLeaderboardStrategies(options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationLeaderboardsApi - factory interface
 */
export const GamificationLeaderboardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieves leaderboard details and paginated entries
         * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard.
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getLeaderboard(params: {  "contextType": string; "contextId": string; "size"?: number; "page"?: number; }, options?: any) {
            return GamificationLeaderboardsApiFp.getLeaderboard(params, options)(fetch, basePath);
        },
        /** 
         * Retrieves a specific user entry with rank
         * The context type identifies the type of entity (i.e., &#39;activity&#39;) being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param id The id of a user
         */
        getLeaderboardRank(params: {  "contextType": string; "contextId": string; "id": string; }, options?: any) {
            return GamificationLeaderboardsApiFp.getLeaderboardRank(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of available leaderboard strategy names
         */
        getLeaderboardStrategies(options?: any) {
            return GamificationLeaderboardsApiFp.getLeaderboardStrategies(options)(fetch, basePath);
        },
    };
};


/**
 * GamificationLevelingApi - fetch parameter creator
 */
export const GamificationLevelingApiFetchParamCreator = {
    /** 
     * Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  "level"?: LevelingResource; }, options?: any): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["level"]) {
            fetchOptions.body = JSON.stringify(params["level"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options?: any): FetchArgs {
        const baseUrl = `/leveling/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search levels
     * Get a list of levels schemas with optional filtering
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_name": params["filterName"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a user&#39;s progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: {  "userId": number; "name": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevel");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getUserLevel");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a user&#39;s progress for all level schemas
     * @param userId The id of the user
     */
    getUserLevels(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevels");
        }
        const baseUrl = `/users/{user_id}/leveling`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  "name": string; "newLevel"?: LevelingResource; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newLevel"]) {
            fetchOptions.body = JSON.stringify(params["newLevel"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update or create a leveling progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the level&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The current progress amount
     */
    updateUserLevel(params: {  "userId": number; "name": string; "progress"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserLevel");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateUserLevel");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationLevelingApi - functional programming interface
 */
export const GamificationLevelingApiFp = {
    /** 
     * Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: { "level"?: LevelingResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.createLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.deleteLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevelTriggers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search levels
     * Get a list of levels schemas with optional filtering
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: { "filterName"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a user&#39;s progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: { "userId": number; "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getUserLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a user&#39;s progress for all level schemas
     * @param userId The id of the user
     */
    getUserLevels(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getUserLevels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: { "name": string; "newLevel"?: LevelingResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.updateLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update or create a leveling progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the level&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The current progress amount
     */
    updateUserLevel(params: { "userId": number; "name": string; "progress"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.updateUserLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationLevelingApi - object-oriented interface
 */
export class GamificationLevelingApi extends BaseAPI {
    /** 
     * Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  "level"?: LevelingResource; }, options?: any) {
        return GamificationLevelingApiFp.createLevel(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  "name": string; }, options?: any) {
        return GamificationLevelingApiFp.deleteLevel(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  "name": string; }, options?: any) {
        return GamificationLevelingApiFp.getLevel(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options?: any) {
        return GamificationLevelingApiFp.getLevelTriggers(options)(this.fetch, this.basePath);
    }
    /** 
     * List and search levels
     * Get a list of levels schemas with optional filtering
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return GamificationLevelingApiFp.getLevels(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a user&#39;s progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: {  "userId": number; "name": string; }, options?: any) {
        return GamificationLevelingApiFp.getUserLevel(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a user&#39;s progress for all level schemas
     * @param userId The id of the user
     */
    getUserLevels(params: {  "userId": number; }, options?: any) {
        return GamificationLevelingApiFp.getUserLevels(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  "name": string; "newLevel"?: LevelingResource; }, options?: any) {
        return GamificationLevelingApiFp.updateLevel(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update or create a leveling progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the level&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The current progress amount
     */
    updateUserLevel(params: {  "userId": number; "name": string; "progress"?: number; }, options?: any) {
        return GamificationLevelingApiFp.updateUserLevel(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationLevelingApi - factory interface
 */
export const GamificationLevelingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a level schema
         * @param level The level schema definition
         */
        createLevel(params: {  "level"?: LevelingResource; }, options?: any) {
            return GamificationLevelingApiFp.createLevel(params, options)(fetch, basePath);
        },
        /** 
         * Delete a level
         * @param name The level schema name
         */
        deleteLevel(params: {  "name": string; }, options?: any) {
            return GamificationLevelingApiFp.deleteLevel(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a level
         * @param name The level schema name
         */
        getLevel(params: {  "name": string; }, options?: any) {
            return GamificationLevelingApiFp.getLevel(params, options)(fetch, basePath);
        },
        /** 
         * Get the list of triggers that can be used to trigger a leveling progress update
         */
        getLevelTriggers(options?: any) {
            return GamificationLevelingApiFp.getLevelTriggers(options)(fetch, basePath);
        },
        /** 
         * List and search levels
         * Get a list of levels schemas with optional filtering
         * @param filterName Filter for level schemas whose name contains a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getLevels(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return GamificationLevelingApiFp.getLevels(params, options)(fetch, basePath);
        },
        /** 
         * Get a user&#39;s progress for a given level schema
         * @param userId The id of the user
         * @param name The level schema name
         */
        getUserLevel(params: {  "userId": number; "name": string; }, options?: any) {
            return GamificationLevelingApiFp.getUserLevel(params, options)(fetch, basePath);
        },
        /** 
         * Get a user&#39;s progress for all level schemas
         * @param userId The id of the user
         */
        getUserLevels(params: {  "userId": number; }, options?: any) {
            return GamificationLevelingApiFp.getUserLevels(params, options)(fetch, basePath);
        },
        /** 
         * Update a level
         * @param name The level schema name
         * @param newLevel The level schema definition
         */
        updateLevel(params: {  "name": string; "newLevel"?: LevelingResource; }, options?: any) {
            return GamificationLevelingApiFp.updateLevel(params, options)(fetch, basePath);
        },
        /** 
         * Update or create a leveling progress record for a user
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated. If progress meets or exceeds the level&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
         * @param userId The id of the user
         * @param name The level schema name
         * @param progress The current progress amount
         */
        updateUserLevel(params: {  "userId": number; "name": string; "progress"?: number; }, options?: any) {
            return GamificationLevelingApiFp.updateUserLevel(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationMetricsApi - fetch parameter creator
 */
export const GamificationMetricsApiFetchParamCreator = {
    /** 
     * Add a metric
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @param metric The new metric
     */
    addMetric(params: {  "metric"?: MetricResource; }, options?: any): FetchArgs {
        const baseUrl = `/metrics`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["metric"]) {
            fetchOptions.body = JSON.stringify(params["metric"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationMetricsApi - functional programming interface
 */
export const GamificationMetricsApiFp = {
    /** 
     * Add a metric
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @param metric The new metric
     */
    addMetric(params: { "metric"?: MetricResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationMetricsApiFetchParamCreator.addMetric(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationMetricsApi - object-oriented interface
 */
export class GamificationMetricsApi extends BaseAPI {
    /** 
     * Add a metric
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @param metric The new metric
     */
    addMetric(params: {  "metric"?: MetricResource; }, options?: any) {
        return GamificationMetricsApiFp.addMetric(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationMetricsApi - factory interface
 */
export const GamificationMetricsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a metric
         * Post a new score/stat for an activity occurrence without ending the occurrence itself
         * @param metric The new metric
         */
        addMetric(params: {  "metric"?: MetricResource; }, options?: any) {
            return GamificationMetricsApiFp.addMetric(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationTriviaApi - fetch parameter creator
 */
export const GamificationTriviaApiFetchParamCreator = {
    /** 
     * Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  "questionId": string; "answer"?: AnswerResource; }, options?: any): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling addQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  "id": string; "tag"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  "tag"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_idset": params["filterIdset"],
            "filter_category": params["filterCategory"],
            "filter_tag": params["filterTag"],
            "filter_tagset": params["filterTagset"],
            "filter_type": params["filterType"],
            "filter_published": params["filterPublished"],
            "filter_import_id": params["filterImportId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    createImportJob(params: {  "request"?: ImportJobResource; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a question
     * @param question The new question
     */
    createQuestion(params: {  "question"?: QuestionResource; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  "questionTemplateResource"?: QuestionTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    deleteImportJob(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  "questionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling deleteQuestionAnswers");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  "filterVendor"?: string; "filterCategory"?: string; "filterName"?: string; "filterStatus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_vendor": params["filterVendor"],
            "filter_category": params["filterCategory"],
            "filter_name": params["filterName"],
            "filter_status": params["filterStatus"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  "questionId": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  "questionId": string; }, options?: any): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  "since"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions/delta`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "since": params["since"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTags");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  "size"?: number; "page"?: number; "order"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
            "filter_search": params["filterSearch"],
            "filter_idset": params["filterIdset"],
            "filter_category": params["filterCategory"],
            "filter_tagset": params["filterTagset"],
            "filter_type": params["filterType"],
            "filter_published": params["filterPublished"],
            "filter_import_id": params["filterImportId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Count questions based on filters
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_idset": params["filterIdset"],
            "filter_category": params["filterCategory"],
            "filter_tag": params["filterTag"],
            "filter_tagset": params["filterTagset"],
            "filter_type": params["filterType"],
            "filter_published": params["filterPublished"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  "id": number; "publishNow": boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling processImportJob");
        }
        // verify required parameter "publishNow" is set
        if (params["publishNow"] == null) {
            throw new Error("Missing required parameter publishNow when calling processImportJob");
        }
        const baseUrl = `/trivia/import/{id}/process`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "publish_now": params["publishNow"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  "id": string; "tag": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeQuestionTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags/{tag}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  "tag": string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any): FetchArgs {
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeTagToQuestionsBatch");
        }
        const baseUrl = `/trivia/questions/tags/{tag}`
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_idset": params["filterIdset"],
            "filter_category": params["filterCategory"],
            "filter_tag": params["filterTag"],
            "filter_tagset": params["filterTagset"],
            "filter_type": params["filterType"],
            "filter_published": params["filterPublished"],
            "filter_import_id": params["filterImportId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  "filterSearch"?: string; "filterCategory"?: string; "filterImportId"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_category": params["filterCategory"],
            "filter_import_id": params["filterImportId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  "id": number; "request"?: ImportJobResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  "id": string; "question"?: QuestionResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  "questionId": string; "id": string; "answer"?: AnswerResource; }, options?: any): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling updateQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  "id": string; "questionTemplateResource"?: QuestionTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  "question"?: QuestionResource; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_search": params["filterSearch"],
            "filter_idset": params["filterIdset"],
            "filter_category": params["filterCategory"],
            "filter_tagset": params["filterTagset"],
            "filter_type": params["filterType"],
            "filter_published": params["filterPublished"],
            "filter_import_id": params["filterImportId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationTriviaApi - functional programming interface
 */
export const GamificationTriviaApiFp = {
    /** 
     * Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: { "questionId": string; "answer"?: AnswerResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: { "id": string; "tag"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addQuestionTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: { "tag"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addTagToQuestionsBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    createImportJob(params: { "request"?: ImportJobResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a question
     * @param question The new question
     */
    createQuestion(params: { "question"?: QuestionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: { "questionTemplateResource"?: QuestionTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    deleteImportJob(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: { "questionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an import job
     * @param id The id of the job
     */
    getImportJob(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: { "filterVendor"?: string; "filterCategory"?: string; "filterName"?: string; "filterStatus"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getImportJobs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single question
     * @param id The id of the question
     */
    getQuestion(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: { "questionId": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: { "questionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AnswerResource>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: { "since"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeltaResource>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionDeltas(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceQuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: { "size"?: number; "page"?: number; "order"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceQuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Count questions based on filters
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: { "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionsCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: { "id": number; "publishNow": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.processImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: { "id": string; "tag": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.removeQuestionTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: { "tag": string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.removeTagToQuestionsBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: { "filterSearch"?: string; "filterCategory"?: string; "filterImportId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Collectionstring> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.searchQuestionTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: { "id": number; "request"?: ImportJobResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: { "id": string; "question"?: QuestionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: { "questionId": string; "id": string; "answer"?: AnswerResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: { "id": string; "questionTemplateResource"?: QuestionTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: { "question"?: QuestionResource; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionsInBulk(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationTriviaApi - object-oriented interface
 */
export class GamificationTriviaApi extends BaseAPI {
    /** 
     * Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  "questionId": string; "answer"?: AnswerResource; }, options?: any) {
        return GamificationTriviaApiFp.addQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  "id": string; "tag"?: string; }, options?: any) {
        return GamificationTriviaApiFp.addQuestionTag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  "tag"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
        return GamificationTriviaApiFp.addTagToQuestionsBatch(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    createImportJob(params: {  "request"?: ImportJobResource; }, options?: any) {
        return GamificationTriviaApiFp.createImportJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a question
     * @param question The new question
     */
    createQuestion(params: {  "question"?: QuestionResource; }, options?: any) {
        return GamificationTriviaApiFp.createQuestion(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  "questionTemplateResource"?: QuestionTemplateResource; }, options?: any) {
        return GamificationTriviaApiFp.createQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    deleteImportJob(params: {  "id": number; }, options?: any) {
        return GamificationTriviaApiFp.deleteImportJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  "id": string; }, options?: any) {
        return GamificationTriviaApiFp.deleteQuestion(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  "questionId": string; "id": string; }, options?: any) {
        return GamificationTriviaApiFp.deleteQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return GamificationTriviaApiFp.deleteQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  "id": number; }, options?: any) {
        return GamificationTriviaApiFp.getImportJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  "filterVendor"?: string; "filterCategory"?: string; "filterName"?: string; "filterStatus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return GamificationTriviaApiFp.getImportJobs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  "id": string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestion(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  "questionId": string; "id": string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionAnswer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  "questionId": string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  "since"?: number; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionDeltas(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  "id": string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionTags(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  "id": string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  "size"?: number; "page"?: number; "order"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
        return GamificationTriviaApiFp.getQuestions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Count questions based on filters
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; }, options?: any) {
        return GamificationTriviaApiFp.getQuestionsCount(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  "id": number; "publishNow": boolean; }, options?: any) {
        return GamificationTriviaApiFp.processImportJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  "id": string; "tag": string; }, options?: any) {
        return GamificationTriviaApiFp.removeQuestionTag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  "tag": string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
        return GamificationTriviaApiFp.removeTagToQuestionsBatch(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  "filterSearch"?: string; "filterCategory"?: string; "filterImportId"?: number; }, options?: any) {
        return GamificationTriviaApiFp.searchQuestionTags(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  "id": number; "request"?: ImportJobResource; }, options?: any) {
        return GamificationTriviaApiFp.updateImportJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  "id": string; "question"?: QuestionResource; }, options?: any) {
        return GamificationTriviaApiFp.updateQuestion(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  "questionId": string; "id": string; "answer"?: AnswerResource; }, options?: any) {
        return GamificationTriviaApiFp.updateQuestionAnswer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  "id": string; "questionTemplateResource"?: QuestionTemplateResource; }, options?: any) {
        return GamificationTriviaApiFp.updateQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  "question"?: QuestionResource; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
        return GamificationTriviaApiFp.updateQuestionsInBulk(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationTriviaApi - factory interface
 */
export const GamificationTriviaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add an answer to a question
         * @param questionId The id of the question
         * @param answer The new answer
         */
        addQuestionAnswers(params: {  "questionId": string; "answer"?: AnswerResource; }, options?: any) {
            return GamificationTriviaApiFp.addQuestionAnswers(params, options)(fetch, basePath);
        },
        /** 
         * Add a tag to a question
         * @param id The id of the question
         * @param tag The new tag
         */
        addQuestionTag(params: {  "id": string; "tag"?: string; }, options?: any) {
            return GamificationTriviaApiFp.addQuestionTag(params, options)(fetch, basePath);
        },
        /** 
         * Add a tag to a batch of questions
         * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
         * @param tag The tag to add
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        addTagToQuestionsBatch(params: {  "tag"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
            return GamificationTriviaApiFp.addTagToQuestionsBatch(params, options)(fetch, basePath);
        },
        /** 
         * Create an import job
         * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
         * @param request The new import job
         */
        createImportJob(params: {  "request"?: ImportJobResource; }, options?: any) {
            return GamificationTriviaApiFp.createImportJob(params, options)(fetch, basePath);
        },
        /** 
         * Create a question
         * @param question The new question
         */
        createQuestion(params: {  "question"?: QuestionResource; }, options?: any) {
            return GamificationTriviaApiFp.createQuestion(params, options)(fetch, basePath);
        },
        /** 
         * Create a question template
         * Question templates define a type of question and the properties they have
         * @param questionTemplateResource The question template resource object
         */
        createQuestionTemplate(params: {  "questionTemplateResource"?: QuestionTemplateResource; }, options?: any) {
            return GamificationTriviaApiFp.createQuestionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an import job
         * Also deletes all questions that were imported by it
         * @param id The id of the job
         */
        deleteImportJob(params: {  "id": number; }, options?: any) {
            return GamificationTriviaApiFp.deleteImportJob(params, options)(fetch, basePath);
        },
        /** 
         * Delete a question
         * @param id The id of the question
         */
        deleteQuestion(params: {  "id": string; }, options?: any) {
            return GamificationTriviaApiFp.deleteQuestion(params, options)(fetch, basePath);
        },
        /** 
         * Remove an answer from a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        deleteQuestionAnswers(params: {  "questionId": string; "id": string; }, options?: any) {
            return GamificationTriviaApiFp.deleteQuestionAnswers(params, options)(fetch, basePath);
        },
        /** 
         * Delete a question template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteQuestionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return GamificationTriviaApiFp.deleteQuestionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get an import job
         * @param id The id of the job
         */
        getImportJob(params: {  "id": number; }, options?: any) {
            return GamificationTriviaApiFp.getImportJob(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of import job
         * @param filterVendor Filter for jobs by vendor id
         * @param filterCategory Filter for jobs by category id
         * @param filterName Filter for jobs which name *STARTS* with the given string
         * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getImportJobs(params: {  "filterVendor"?: string; "filterCategory"?: string; "filterName"?: string; "filterStatus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return GamificationTriviaApiFp.getImportJobs(params, options)(fetch, basePath);
        },
        /** 
         * Get a single question
         * @param id The id of the question
         */
        getQuestion(params: {  "id": string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestion(params, options)(fetch, basePath);
        },
        /** 
         * Get an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        getQuestionAnswer(params: {  "questionId": string; "id": string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionAnswer(params, options)(fetch, basePath);
        },
        /** 
         * List the answers available for a question
         * @param questionId The id of the question
         */
        getQuestionAnswers(params: {  "questionId": string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionAnswers(params, options)(fetch, basePath);
        },
        /** 
         * List question deltas in ascending order of updated date
         * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
         * @param since Timestamp in seconds
         */
        getQuestionDeltas(params: {  "since"?: number; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionDeltas(params, options)(fetch, basePath);
        },
        /** 
         * List the tags for a question
         * @param id The id of the question
         */
        getQuestionTags(params: {  "id": string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionTags(params, options)(fetch, basePath);
        },
        /** 
         * Get a single question template
         * @param id The id of the template
         */
        getQuestionTemplate(params: {  "id": string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search question templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getQuestionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List and search questions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        getQuestions(params: {  "size"?: number; "page"?: number; "order"?: string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
            return GamificationTriviaApiFp.getQuestions(params, options)(fetch, basePath);
        },
        /** 
         * Count questions based on filters
         * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         */
        getQuestionsCount(params: {  "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; }, options?: any) {
            return GamificationTriviaApiFp.getQuestionsCount(params, options)(fetch, basePath);
        },
        /** 
         * Start processing an import job
         * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
         * @param id The id of the job
         * @param publishNow Whether the new questions should be published live immediately
         */
        processImportJob(params: {  "id": number; "publishNow": boolean; }, options?: any) {
            return GamificationTriviaApiFp.processImportJob(params, options)(fetch, basePath);
        },
        /** 
         * Remove a tag from a question
         * @param id The id of the question
         * @param tag The tag to remove
         */
        removeQuestionTag(params: {  "id": string; "tag": string; }, options?: any) {
            return GamificationTriviaApiFp.removeQuestionTag(params, options)(fetch, basePath);
        },
        /** 
         * Remove a tag from a batch of questions
         * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
         * @param tag The tag to remove
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        removeTagToQuestionsBatch(params: {  "tag": string; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTag"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
            return GamificationTriviaApiFp.removeTagToQuestionsBatch(params, options)(fetch, basePath);
        },
        /** 
         * List and search tags by the beginning of the string
         * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
         * @param filterSearch Filter for tags starting with the given text
         * @param filterCategory Filter for tags on questions from a specific category
         * @param filterImportId Filter for tags on questions from a specific import job
         */
        searchQuestionTags(params: {  "filterSearch"?: string; "filterCategory"?: string; "filterImportId"?: number; }, options?: any) {
            return GamificationTriviaApiFp.searchQuestionTags(params, options)(fetch, basePath);
        },
        /** 
         * Update an import job
         * Changes should be made before process is started for there to be any effect.
         * @param id The id of the job
         * @param request The updated job
         */
        updateImportJob(params: {  "id": number; "request"?: ImportJobResource; }, options?: any) {
            return GamificationTriviaApiFp.updateImportJob(params, options)(fetch, basePath);
        },
        /** 
         * Update a question
         * @param id The id of the question
         * @param question The updated question
         */
        updateQuestion(params: {  "id": string; "question"?: QuestionResource; }, options?: any) {
            return GamificationTriviaApiFp.updateQuestion(params, options)(fetch, basePath);
        },
        /** 
         * Update an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         * @param answer The updated answer
         */
        updateQuestionAnswer(params: {  "questionId": string; "id": string; "answer"?: AnswerResource; }, options?: any) {
            return GamificationTriviaApiFp.updateQuestionAnswer(params, options)(fetch, basePath);
        },
        /** 
         * Update a question template
         * @param id The id of the template
         * @param questionTemplateResource The question template resource object
         */
        updateQuestionTemplate(params: {  "id": string; "questionTemplateResource"?: QuestionTemplateResource; }, options?: any) {
            return GamificationTriviaApiFp.updateQuestionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Bulk update questions
         * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
         * @param question New values for a set of question fields
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        updateQuestionsInBulk(params: {  "question"?: QuestionResource; "filterSearch"?: string; "filterIdset"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterType"?: string; "filterPublished"?: boolean; "filterImportId"?: number; }, options?: any) {
            return GamificationTriviaApiFp.updateQuestionsInBulk(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoicesApi - fetch parameter creator
 */
export const InvoicesApiFetchParamCreator = {
    /** 
     * Create an invoice
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @param req Invoice to be created
     */
    createInvoice(params: {  "req"?: InvoiceCreateRequest; }, options?: any): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options?: any): FetchArgs {
        const baseUrl = `/invoices/fulfillment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoice");
        }
        const baseUrl = `/invoices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  "id": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoiceLogs");
        }
        const baseUrl = `/invoices/{id}/logs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve invoices
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  "filterUser"?: number; "filterEmail"?: string; "filterFulfillmentStatus"?: string; "filterPaymentStatus"?: string; "filterItemName"?: string; "filterExternalRef"?: string; "filterCreatedDate"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_user": params["filterUser"],
            "filter_email": params["filterEmail"],
            "filter_fulfillment_status": params["filterFulfillmentStatus"],
            "filter_payment_status": params["filterPaymentStatus"],
            "filter_item_name": params["filterItemName"],
            "filter_external_ref": params["filterExternalRef"],
            "filter_created_date": params["filterCreatedDate"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Lists available payment statuses
     */
    getPaymentStatuses(options?: any): FetchArgs {
        const baseUrl = `/invoices/payment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Trigger payment of an invoice
     * @param id The id of the invoice
     * @param request Payment info
     */
    payInvoice(params: {  "id": number; "request"?: PayBySavedMethodRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payInvoice");
        }
        const baseUrl = `/invoices/{id}/payments`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  "id": number; "externalRef"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setExternalRef");
        }
        const baseUrl = `/invoices/{id}/external-ref`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["externalRef"]) {
            fetchOptions.body = JSON.stringify(params["externalRef"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the fulfillment status of an invoice item
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  "id": number; "sku": string; "status": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setInvoiceItemFulfillmentStatus");
        }
        const baseUrl = `/invoices/{id}/items/{sku}/fulfillment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  "id": number; "orderNotes"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setOrderNotes");
        }
        const baseUrl = `/invoices/{id}/order-notes`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["orderNotes"]) {
            fetchOptions.body = JSON.stringify(params["orderNotes"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the payment status of an invoice
     * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  "id": number; "request"?: InvoicePaymentStatusRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPaymentStatus");
        }
        const baseUrl = `/invoices/{id}/payment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  "id": number; "billingInfoRequest"?: AddressResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBillingInfo");
        }
        const baseUrl = `/invoices/{id}/billing-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billingInfoRequest"]) {
            fetchOptions.body = JSON.stringify(params["billingInfoRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoicesApi - functional programming interface
 */
export const InvoicesApiFp = {
    /** 
     * Create an invoice
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @param req Invoice to be created
     */
    createInvoice(params: { "req"?: InvoiceCreateRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvoiceResource>> {
        const fetchArgs = InvoicesApiFetchParamCreator.createInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getFulFillmentStatuses(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: { "id": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceLogEntry> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoiceLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve invoices
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: { "filterUser"?: number; "filterEmail"?: string; "filterFulfillmentStatus"?: string; "filterPaymentStatus"?: string; "filterItemName"?: string; "filterExternalRef"?: string; "filterCreatedDate"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoices(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Lists available payment statuses
     */
    getPaymentStatuses(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getPaymentStatuses(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Trigger payment of an invoice
     * @param id The id of the invoice
     * @param request Payment info
     */
    payInvoice(params: { "id": number; "request"?: PayBySavedMethodRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.payInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: { "id": number; "externalRef"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setExternalRef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the fulfillment status of an invoice item
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: { "id": number; "sku": string; "status": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setInvoiceItemFulfillmentStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: { "id": number; "orderNotes"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setOrderNotes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the payment status of an invoice
     * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: { "id": number; "request"?: InvoicePaymentStatusRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setPaymentStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: { "id": number; "billingInfoRequest"?: AddressResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.updateBillingInfo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoicesApi - object-oriented interface
 */
export class InvoicesApi extends BaseAPI {
    /** 
     * Create an invoice
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @param req Invoice to be created
     */
    createInvoice(params: {  "req"?: InvoiceCreateRequest; }, options?: any) {
        return InvoicesApiFp.createInvoice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options?: any) {
        return InvoicesApiFp.getFulFillmentStatuses(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  "id": number; }, options?: any) {
        return InvoicesApiFp.getInvoice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  "id": number; "size"?: number; "page"?: number; }, options?: any) {
        return InvoicesApiFp.getInvoiceLogs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve invoices
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  "filterUser"?: number; "filterEmail"?: string; "filterFulfillmentStatus"?: string; "filterPaymentStatus"?: string; "filterItemName"?: string; "filterExternalRef"?: string; "filterCreatedDate"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return InvoicesApiFp.getInvoices(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Lists available payment statuses
     */
    getPaymentStatuses(options?: any) {
        return InvoicesApiFp.getPaymentStatuses(options)(this.fetch, this.basePath);
    }
    /** 
     * Trigger payment of an invoice
     * @param id The id of the invoice
     * @param request Payment info
     */
    payInvoice(params: {  "id": number; "request"?: PayBySavedMethodRequest; }, options?: any) {
        return InvoicesApiFp.payInvoice(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  "id": number; "externalRef"?: string; }, options?: any) {
        return InvoicesApiFp.setExternalRef(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the fulfillment status of an invoice item
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  "id": number; "sku": string; "status": string; }, options?: any) {
        return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  "id": number; "orderNotes"?: string; }, options?: any) {
        return InvoicesApiFp.setOrderNotes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the payment status of an invoice
     * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  "id": number; "request"?: InvoicePaymentStatusRequest; }, options?: any) {
        return InvoicesApiFp.setPaymentStatus(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  "id": number; "billingInfoRequest"?: AddressResource; }, options?: any) {
        return InvoicesApiFp.updateBillingInfo(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoicesApi - factory interface
 */
export const InvoicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create an invoice
         * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
         * @param req Invoice to be created
         */
        createInvoice(params: {  "req"?: InvoiceCreateRequest; }, options?: any) {
            return InvoicesApiFp.createInvoice(params, options)(fetch, basePath);
        },
        /** 
         * Lists available fulfillment statuses
         */
        getFulFillmentStatuses(options?: any) {
            return InvoicesApiFp.getFulFillmentStatuses(options)(fetch, basePath);
        },
        /** 
         * Retrieve an invoice
         * @param id The id of the invoice
         */
        getInvoice(params: {  "id": number; }, options?: any) {
            return InvoicesApiFp.getInvoice(params, options)(fetch, basePath);
        },
        /** 
         * List invoice logs
         * @param id The id of the invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getInvoiceLogs(params: {  "id": number; "size"?: number; "page"?: number; }, options?: any) {
            return InvoicesApiFp.getInvoiceLogs(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve invoices
         * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user&#39;s invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
         * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
         * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
         * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
         * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
         * @param filterItemName Filters invoices by item name containing the given string
         * @param filterExternalRef Filters invoices by external reference.
         * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getInvoices(params: {  "filterUser"?: number; "filterEmail"?: string; "filterFulfillmentStatus"?: string; "filterPaymentStatus"?: string; "filterItemName"?: string; "filterExternalRef"?: string; "filterCreatedDate"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return InvoicesApiFp.getInvoices(params, options)(fetch, basePath);
        },
        /** 
         * Lists available payment statuses
         */
        getPaymentStatuses(options?: any) {
            return InvoicesApiFp.getPaymentStatuses(options)(fetch, basePath);
        },
        /** 
         * Trigger payment of an invoice
         * @param id The id of the invoice
         * @param request Payment info
         */
        payInvoice(params: {  "id": number; "request"?: PayBySavedMethodRequest; }, options?: any) {
            return InvoicesApiFp.payInvoice(params, options)(fetch, basePath);
        },
        /** 
         * Set the external reference of an invoice
         * @param id The id of the invoice
         * @param externalRef External reference info
         */
        setExternalRef(params: {  "id": number; "externalRef"?: string; }, options?: any) {
            return InvoicesApiFp.setExternalRef(params, options)(fetch, basePath);
        },
        /** 
         * Set the fulfillment status of an invoice item
         * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
         * @param id The id of the invoice
         * @param sku The sku of an item in the invoice
         * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
         */
        setInvoiceItemFulfillmentStatus(params: {  "id": number; "sku": string; "status": string; }, options?: any) {
            return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, options)(fetch, basePath);
        },
        /** 
         * Set the order notes of an invoice
         * @param id The id of the invoice
         * @param orderNotes Payment status info
         */
        setOrderNotes(params: {  "id": number; "orderNotes"?: string; }, options?: any) {
            return InvoicesApiFp.setOrderNotes(params, options)(fetch, basePath);
        },
        /** 
         * Set the payment status of an invoice
         * This may trigger fulfillment if setting the status to &#39;paid&#39;. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
         * @param id The id of the invoice
         * @param request Payment status info
         */
        setPaymentStatus(params: {  "id": number; "request"?: InvoicePaymentStatusRequest; }, options?: any) {
            return InvoicesApiFp.setPaymentStatus(params, options)(fetch, basePath);
        },
        /** 
         * Set or update billing info
         * @param id The id of the invoice
         * @param billingInfoRequest Address info
         */
        updateBillingInfo(params: {  "id": number; "billingInfoRequest"?: AddressResource; }, options?: any) {
            return InvoicesApiFp.updateBillingInfo(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationsApi - fetch parameter creator
 */
export const LocationsApiFetchParamCreator = {
    /** 
     * Get a list of countries
     */
    getCountries(options?: any): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the iso3 code of your country
     * Determined by geo ip location
     */
    getCountryByGeoLocation(options?: any): FetchArgs {
        const baseUrl = `/location/geolocation/country`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of a country&#39;s states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  "countryCodeIso3": string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryStates");
        }
        const baseUrl = `/location/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the currency information of your country
     * Determined by geo ip location, currency to country mapping and a fallback setting
     */
    getCurrencyByGeoLocation(options?: any): FetchArgs {
        const baseUrl = `/location/geolocation/currency`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationsApi - functional programming interface
 */
export const LocationsApiFp = {
    /** 
     * Get a list of countries
     */
    getCountries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CountryResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountries(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the iso3 code of your country
     * Determined by geo ip location
     */
    getCountryByGeoLocation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryByGeoLocation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of a country&#39;s states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: { "countryCodeIso3": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<StateResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryStates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the currency information of your country
     * Determined by geo ip location, currency to country mapping and a fallback setting
     */
    getCurrencyByGeoLocation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = LocationsApiFetchParamCreator.getCurrencyByGeoLocation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LocationsApi - object-oriented interface
 */
export class LocationsApi extends BaseAPI {
    /** 
     * Get a list of countries
     */
    getCountries(options?: any) {
        return LocationsApiFp.getCountries(options)(this.fetch, this.basePath);
    }
    /** 
     * Get the iso3 code of your country
     * Determined by geo ip location
     */
    getCountryByGeoLocation(options?: any) {
        return LocationsApiFp.getCountryByGeoLocation(options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of a country&#39;s states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  "countryCodeIso3": string; }, options?: any) {
        return LocationsApiFp.getCountryStates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the currency information of your country
     * Determined by geo ip location, currency to country mapping and a fallback setting
     */
    getCurrencyByGeoLocation(options?: any) {
        return LocationsApiFp.getCurrencyByGeoLocation(options)(this.fetch, this.basePath);
    }
};

/**
 * LocationsApi - factory interface
 */
export const LocationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of countries
         */
        getCountries(options?: any) {
            return LocationsApiFp.getCountries(options)(fetch, basePath);
        },
        /** 
         * Get the iso3 code of your country
         * Determined by geo ip location
         */
        getCountryByGeoLocation(options?: any) {
            return LocationsApiFp.getCountryByGeoLocation(options)(fetch, basePath);
        },
        /** 
         * Get a list of a country&#39;s states
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryStates(params: {  "countryCodeIso3": string; }, options?: any) {
            return LocationsApiFp.getCountryStates(params, options)(fetch, basePath);
        },
        /** 
         * Get the currency information of your country
         * Determined by geo ip location, currency to country mapping and a fallback setting
         */
        getCurrencyByGeoLocation(options?: any) {
            return LocationsApiFp.getCurrencyByGeoLocation(options)(fetch, basePath);
        },
    };
};


/**
 * LogsApi - fetch parameter creator
 */
export const LogsApiFetchParamCreator = {
    /** 
     * Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  "logEntry"?: UserActionLog; }, options?: any): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["logEntry"]) {
            fetchOptions.body = JSON.stringify(params["logEntry"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREEventLog");
        }
        const baseUrl = `/bre/logs/event-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: {  "filterStartDate"?: string; "filterEventName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/bre/logs/event-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_start_date": params["filterStartDate"],
            "filter_event_name": params["filterEventName"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREForwardLog");
        }
        const baseUrl = `/bre/logs/forward-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterStatusCode"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/bre/logs/forward-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_start_date": params["filterStartDate"],
            "filter_end_date": params["filterEndDate"],
            "filter_status_code": params["filterStatusCode"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserLog");
        }
        const baseUrl = `/audit/logs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserLogs(params: {  "filterUser"?: number; "filterActionName"?: string; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_user": params["filterUser"],
            "filter_action_name": params["filterActionName"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LogsApi - functional programming interface
 */
export const LogsApiFp = {
    /** 
     * Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: { "logEntry"?: UserActionLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LogsApiFetchParamCreator.addUserLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: { "filterStartDate"?: string; "filterEventName"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: { "filterStartDate"?: string; "filterEndDate"?: string; "filterStatusCode"?: number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserLogs(params: { "filterUser"?: number; "filterActionName"?: string; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LogsApi - object-oriented interface
 */
export class LogsApi extends BaseAPI {
    /** 
     * Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  "logEntry"?: UserActionLog; }, options?: any) {
        return LogsApiFp.addUserLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  "id": string; }, options?: any) {
        return LogsApiFp.getBREEventLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: {  "filterStartDate"?: string; "filterEventName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return LogsApiFp.getBREEventLogs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  "id": string; }, options?: any) {
        return LogsApiFp.getBREForwardLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterStatusCode"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return LogsApiFp.getBREForwardLogs(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  "id": string; }, options?: any) {
        return LogsApiFp.getUserLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserLogs(params: {  "filterUser"?: number; "filterActionName"?: string; "size"?: number; "page"?: number; }, options?: any) {
        return LogsApiFp.getUserLogs(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LogsApi - factory interface
 */
export const LogsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a user log entry
         * @param logEntry The user log entry to be added
         */
        addUserLog(params: {  "logEntry"?: UserActionLog; }, options?: any) {
            return LogsApiFp.addUserLog(params, options)(fetch, basePath);
        },
        /** 
         * Get an existing BRE event log entry by id
         * @param id The BRE event log entry id
         */
        getBREEventLog(params: {  "id": string; }, options?: any) {
            return LogsApiFp.getBREEventLog(params, options)(fetch, basePath);
        },
        /** 
         * Returns a list of BRE event log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEventName Filter event logs by event name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBREEventLogs(params: {  "filterStartDate"?: string; "filterEventName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return LogsApiFp.getBREEventLogs(params, options)(fetch, basePath);
        },
        /** 
         * Get an existing forward log entry by id
         * @param id The forward log entry id
         */
        getBREForwardLog(params: {  "id": string; }, options?: any) {
            return LogsApiFp.getBREForwardLog(params, options)(fetch, basePath);
        },
        /** 
         * Returns a list of forward log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterStatusCode Filter forward logs by http status code
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBREForwardLogs(params: {  "filterStartDate"?: string; "filterEndDate"?: string; "filterStatusCode"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return LogsApiFp.getBREForwardLogs(params, options)(fetch, basePath);
        },
        /** 
         * Returns a user log entry by id
         * @param id The user log entry id
         */
        getUserLog(params: {  "id": string; }, options?: any) {
            return LogsApiFp.getUserLog(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of user logs entries
         * @param filterUser Filter for actions taken by a specific user by id
         * @param filterActionName Filter for actions of a specific name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserLogs(params: {  "filterUser"?: number; "filterActionName"?: string; "size"?: number; "page"?: number; }, options?: any) {
            return LogsApiFp.getUserLogs(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaArtistsApi - fetch parameter creator
 */
export const MediaArtistsApiFetchParamCreator = {
    /** 
     * Adds a new artist in the system
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @param artistResource The new artist
     */
    addArtist(params: {  "artistResource"?: ArtistResource; }, options?: any): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an artist template
     * Artist Templates define a type of artist and the properties they have
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  "artistTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an artist template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  "id": number; "showContributions"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "show_contributions": params["showContributions"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  "filterArtistsByName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_artists_by_name": params["filterArtistsByName"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  "id": number; "artistResource"?: ArtistResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  "id": string; "artistTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaArtistsApi - functional programming interface
 */
export const MediaArtistsApiFp = {
    /** 
     * Adds a new artist in the system
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @param artistResource The new artist
     */
    addArtist(params: { "artistResource"?: ArtistResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.addArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an artist template
     * Artist Templates define a type of artist and the properties they have
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: { "artistTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.createArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.deleteArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an artist template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.deleteArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: { "id": number; "showContributions"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtistTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: { "filterArtistsByName"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: { "id": number; "artistResource"?: ArtistResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.updateArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: { "id": string; "artistTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.updateArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaArtistsApi - object-oriented interface
 */
export class MediaArtistsApi extends BaseAPI {
    /** 
     * Adds a new artist in the system
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @param artistResource The new artist
     */
    addArtist(params: {  "artistResource"?: ArtistResource; }, options?: any) {
        return MediaArtistsApiFp.addArtist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an artist template
     * Artist Templates define a type of artist and the properties they have
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  "artistTemplateResource"?: TemplateResource; }, options?: any) {
        return MediaArtistsApiFp.createArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  "id": number; }, options?: any) {
        return MediaArtistsApiFp.deleteArtist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an artist template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return MediaArtistsApiFp.deleteArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  "id": number; "showContributions"?: number; }, options?: any) {
        return MediaArtistsApiFp.getArtist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  "id": string; }, options?: any) {
        return MediaArtistsApiFp.getArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return MediaArtistsApiFp.getArtistTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  "filterArtistsByName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return MediaArtistsApiFp.getArtists(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  "id": number; "artistResource"?: ArtistResource; }, options?: any) {
        return MediaArtistsApiFp.updateArtist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  "id": string; "artistTemplateResource"?: TemplateResource; }, options?: any) {
        return MediaArtistsApiFp.updateArtistTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaArtistsApi - factory interface
 */
export const MediaArtistsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Adds a new artist in the system
         * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
         * @param artistResource The new artist
         */
        addArtist(params: {  "artistResource"?: ArtistResource; }, options?: any) {
            return MediaArtistsApiFp.addArtist(params, options)(fetch, basePath);
        },
        /** 
         * Create an artist template
         * Artist Templates define a type of artist and the properties they have
         * @param artistTemplateResource The artist template resource object
         */
        createArtistTemplate(params: {  "artistTemplateResource"?: TemplateResource; }, options?: any) {
            return MediaArtistsApiFp.createArtistTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Removes an artist from the system IF no resources are attached to it
         * @param id The artist id
         */
        deleteArtist(params: {  "id": number; }, options?: any) {
            return MediaArtistsApiFp.deleteArtist(params, options)(fetch, basePath);
        },
        /** 
         * Delete an artist template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArtistTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return MediaArtistsApiFp.deleteArtistTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Loads a specific artist details
         * @param id The artist id
         * @param showContributions The number of contributions to show fetch
         */
        getArtist(params: {  "id": number; "showContributions"?: number; }, options?: any) {
            return MediaArtistsApiFp.getArtist(params, options)(fetch, basePath);
        },
        /** 
         * Get a single artist template
         * @param id The id of the template
         */
        getArtistTemplate(params: {  "id": string; }, options?: any) {
            return MediaArtistsApiFp.getArtistTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search artist templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtistTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return MediaArtistsApiFp.getArtistTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Search for artists
         * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtists(params: {  "filterArtistsByName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return MediaArtistsApiFp.getArtists(params, options)(fetch, basePath);
        },
        /** 
         * Modifies an artist details
         * @param id The artist id
         * @param artistResource The new artist
         */
        updateArtist(params: {  "id": number; "artistResource"?: ArtistResource; }, options?: any) {
            return MediaArtistsApiFp.updateArtist(params, options)(fetch, basePath);
        },
        /** 
         * Update an artist template
         * @param id The id of the template
         * @param artistTemplateResource The artist template resource object
         */
        updateArtistTemplate(params: {  "id": string; "artistTemplateResource"?: TemplateResource; }, options?: any) {
            return MediaArtistsApiFp.updateArtistTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaModerationApi - fetch parameter creator
 */
export const MediaModerationApiFetchParamCreator = {
    /** 
     * Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of flag reports
     * Context can be either a free-form string or a pre-defined context name
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: {  "excludeResolved"?: boolean; "filterContext"?: string; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/moderation/reports`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "exclude_resolved": params["excludeResolved"],
            "filter_context": params["filterContext"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a flag report
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of &#39;banned&#39; you will need to pass the reason.
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  "id": number; "flagReportResource"?: FlagReportResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["flagReportResource"]) {
            fetchOptions.body = JSON.stringify(params["flagReportResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaModerationApi - functional programming interface
 */
export const MediaModerationApiFp = {
    /** 
     * Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaModerationApiFetchParamCreator.getModerationReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of flag reports
     * Context can be either a free-form string or a pre-defined context name
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: { "excludeResolved"?: boolean; "filterContext"?: string; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceFlagReportResource> {
        const fetchArgs = MediaModerationApiFetchParamCreator.getModerationReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a flag report
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of &#39;banned&#39; you will need to pass the reason.
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: { "id": number; "flagReportResource"?: FlagReportResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaModerationApiFetchParamCreator.updateModerationReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaModerationApi - object-oriented interface
 */
export class MediaModerationApi extends BaseAPI {
    /** 
     * Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  "id": number; }, options?: any) {
        return MediaModerationApiFp.getModerationReport(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of flag reports
     * Context can be either a free-form string or a pre-defined context name
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: {  "excludeResolved"?: boolean; "filterContext"?: string; "size"?: number; "page"?: number; }, options?: any) {
        return MediaModerationApiFp.getModerationReports(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a flag report
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of &#39;banned&#39; you will need to pass the reason.
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  "id": number; "flagReportResource"?: FlagReportResource; }, options?: any) {
        return MediaModerationApiFp.updateModerationReport(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaModerationApi - factory interface
 */
export const MediaModerationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a flag report
         * @param id The flag report id
         */
        getModerationReport(params: {  "id": number; }, options?: any) {
            return MediaModerationApiFp.getModerationReport(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of flag reports
         * Context can be either a free-form string or a pre-defined context name
         * @param excludeResolved Ignore resolved context
         * @param filterContext Filter by moderation context
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getModerationReports(params: {  "excludeResolved"?: boolean; "filterContext"?: string; "size"?: number; "page"?: number; }, options?: any) {
            return MediaModerationApiFp.getModerationReports(params, options)(fetch, basePath);
        },
        /** 
         * Update a flag report
         * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of &#39;banned&#39; you will need to pass the reason.
         * @param id The flag report id
         * @param flagReportResource The new flag report
         */
        updateModerationReport(params: {  "id": number; "flagReportResource"?: FlagReportResource; }, options?: any) {
            return MediaModerationApiFp.updateModerationReport(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaVideosApi - fetch parameter creator
 */
export const MediaVideosApiFetchParamCreator = {
    /** 
     * Adds a user to a video&#39;s whitelist
     * Whitelisted users can view video regardless of privacy setting.
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  "id": number; "userId"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addUserToVideoWhitelist");
        }
        const baseUrl = `/media/videos/{id}/whitelist`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  "videoResource"?: VideoResource; }, options?: any): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  "videoId": number; "commentResource"?: CommentResource; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  "videoId": number; "contributionResource"?: ContributionResource; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["contributionResource"]) {
            fetchOptions.body = JSON.stringify(params["contributionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  "videoId": number; "reason"?: string; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reason"]) {
            fetchOptions.body = JSON.stringify(params["reason"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  "videoId": number; "videoRelationshipResource"?: VideoRelationshipResource; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoRelationshipResource"]) {
            fetchOptions.body = JSON.stringify(params["videoRelationshipResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  "videoId": number; "dispositionResource"?: DispositionResource; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling createVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["dispositionResource"]) {
            fetchOptions.body = JSON.stringify(params["dispositionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  "videoId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  "dispositionId": number; }, options?: any): FetchArgs {
        // verify required parameter "dispositionId" is set
        if (params["dispositionId"] == null) {
            throw new Error("Missing required parameter dispositionId when calling deleteVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions/{disposition_id}`
            .replace(`{${"disposition_id"}}`, `${ params["dispositionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  "videoId": number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a video&#39;s relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  "videoId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoRelationship");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  "userId": number; "excludeFlagged"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserVideos");
        }
        const baseUrl = `/users/{user_id}/videos`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "exclude_flagged": params["excludeFlagged"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoComments");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoDispositions");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  "excludeFlagged"?: boolean; "filterVideosByUploader"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterVideosByName"?: string; "filterVideosByContributor"?: string; "filterVideosByAuthor"?: string; "filterHasAuthor"?: boolean; "filterHasUploader"?: boolean; "filterRelatedTo"?: string; "filterFriends"?: boolean; "filterDisposition"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "exclude_flagged": params["excludeFlagged"],
            "filter_videos_by_uploader": params["filterVideosByUploader"],
            "filter_category": params["filterCategory"],
            "filter_tagset": params["filterTagset"],
            "filter_videos_by_name": params["filterVideosByName"],
            "filter_videos_by_contributor": params["filterVideosByContributor"],
            "filter_videos_by_author": params["filterVideosByAuthor"],
            "filter_has_author": params["filterHasAuthor"],
            "filter_has_uploader": params["filterHasUploader"],
            "filter_related_to": params["filterRelatedTo"],
            "filter_friends": params["filterFriends"],
            "filter_disposition": params["filterDisposition"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes a user from a video&#39;s whitelist
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  "videoId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeUserFromVideoWhitelist");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeUserFromVideoWhitelist");
        }
        const baseUrl = `/media/videos/{video_id}/whitelist/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  "videoId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeVideoContributor");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modifies a video&#39;s details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  "id": number; "videoResource"?: VideoResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  "videoId": number; "id": number; "content"?: string; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}/content`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a video&#39;s relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  "videoId": number; "relationshipId": number; "details"?: string; }, options?: any): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoRelationship");
        }
        // verify required parameter "relationshipId" is set
        if (params["relationshipId"] == null) {
            throw new Error("Missing required parameter relationshipId when calling updateVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}/relationship_details`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"relationship_id"}}`, `${ params["relationshipId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Increment a video&#39;s view count
     * @param id The video id
     */
    viewVideo(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling viewVideo");
        }
        const baseUrl = `/media/videos/{id}/views`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaVideosApi - functional programming interface
 */
export const MediaVideosApiFp = {
    /** 
     * Adds a user to a video&#39;s whitelist
     * Whitelisted users can view video regardless of privacy setting.
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: { "id": number; "userId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addUserToVideoWhitelist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: { "videoResource"?: VideoResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: { "videoId": number; "commentResource"?: CommentResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: { "videoId": number; "contributionResource"?: ContributionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoContributor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: { "videoId": number; "reason"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoFlag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: { "videoId": number; "videoRelationshipResource"?: VideoRelationshipResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VideoRelationshipResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoRelationships(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: { "videoId": number; "dispositionResource"?: DispositionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.createVideoDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: { "videoId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: { "dispositionId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: { "videoId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoFlag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a video&#39;s relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: { "videoId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: { "userId": number; "excludeFlagged"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getUserVideos(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Loads a specific video details
     * @param id The video id
     */
    getVideo(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: { "videoId": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: { "videoId": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoDispositions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: { "videoId": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceVideoRelationshipResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoRelationships(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: { "excludeFlagged"?: boolean; "filterVideosByUploader"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterVideosByName"?: string; "filterVideosByContributor"?: string; "filterVideosByAuthor"?: string; "filterHasAuthor"?: boolean; "filterHasUploader"?: boolean; "filterRelatedTo"?: string; "filterFriends"?: boolean; "filterDisposition"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideos(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes a user from a video&#39;s whitelist
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: { "videoId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.removeUserFromVideoWhitelist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: { "videoId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.removeVideoContributor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modifies a video&#39;s details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: { "id": number; "videoResource"?: VideoResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: { "videoId": number; "id": number; "content"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a video&#39;s relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: { "videoId": number; "relationshipId": number; "details"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideoRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Increment a video&#39;s view count
     * @param id The video id
     */
    viewVideo(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.viewVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaVideosApi - object-oriented interface
 */
export class MediaVideosApi extends BaseAPI {
    /** 
     * Adds a user to a video&#39;s whitelist
     * Whitelisted users can view video regardless of privacy setting.
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  "id": number; "userId"?: number; }, options?: any) {
        return MediaVideosApiFp.addUserToVideoWhitelist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  "videoResource"?: VideoResource; }, options?: any) {
        return MediaVideosApiFp.addVideo(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  "videoId": number; "commentResource"?: CommentResource; }, options?: any) {
        return MediaVideosApiFp.addVideoComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  "videoId": number; "contributionResource"?: ContributionResource; }, options?: any) {
        return MediaVideosApiFp.addVideoContributor(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  "videoId": number; "reason"?: string; }, options?: any) {
        return MediaVideosApiFp.addVideoFlag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  "videoId": number; "videoRelationshipResource"?: VideoRelationshipResource; }, options?: any) {
        return MediaVideosApiFp.addVideoRelationships(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  "videoId": number; "dispositionResource"?: DispositionResource; }, options?: any) {
        return MediaVideosApiFp.createVideoDisposition(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  "id": number; }, options?: any) {
        return MediaVideosApiFp.deleteVideo(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  "videoId": number; "id": number; }, options?: any) {
        return MediaVideosApiFp.deleteVideoComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  "dispositionId": number; }, options?: any) {
        return MediaVideosApiFp.deleteVideoDisposition(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  "videoId": number; }, options?: any) {
        return MediaVideosApiFp.deleteVideoFlag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a video&#39;s relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  "videoId": number; "id": number; }, options?: any) {
        return MediaVideosApiFp.deleteVideoRelationship(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  "userId": number; "excludeFlagged"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return MediaVideosApiFp.getUserVideos(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  "id": number; }, options?: any) {
        return MediaVideosApiFp.getVideo(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
        return MediaVideosApiFp.getVideoComments(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
        return MediaVideosApiFp.getVideoDispositions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
        return MediaVideosApiFp.getVideoRelationships(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  "excludeFlagged"?: boolean; "filterVideosByUploader"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterVideosByName"?: string; "filterVideosByContributor"?: string; "filterVideosByAuthor"?: string; "filterHasAuthor"?: boolean; "filterHasUploader"?: boolean; "filterRelatedTo"?: string; "filterFriends"?: boolean; "filterDisposition"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return MediaVideosApiFp.getVideos(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes a user from a video&#39;s whitelist
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  "videoId": number; "id": number; }, options?: any) {
        return MediaVideosApiFp.removeUserFromVideoWhitelist(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  "videoId": number; "id": number; }, options?: any) {
        return MediaVideosApiFp.removeVideoContributor(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modifies a video&#39;s details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  "id": number; "videoResource"?: VideoResource; }, options?: any) {
        return MediaVideosApiFp.updateVideo(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  "videoId": number; "id": number; "content"?: string; }, options?: any) {
        return MediaVideosApiFp.updateVideoComment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a video&#39;s relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  "videoId": number; "relationshipId": number; "details"?: string; }, options?: any) {
        return MediaVideosApiFp.updateVideoRelationship(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Increment a video&#39;s view count
     * @param id The video id
     */
    viewVideo(params: {  "id": number; }, options?: any) {
        return MediaVideosApiFp.viewVideo(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaVideosApi - factory interface
 */
export const MediaVideosApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Adds a user to a video&#39;s whitelist
         * Whitelisted users can view video regardless of privacy setting.
         * @param id The video id
         * @param userId The user id
         */
        addUserToVideoWhitelist(params: {  "id": number; "userId"?: number; }, options?: any) {
            return MediaVideosApiFp.addUserToVideoWhitelist(params, options)(fetch, basePath);
        },
        /** 
         * Adds a new video in the system
         * @param videoResource The video object
         */
        addVideo(params: {  "videoResource"?: VideoResource; }, options?: any) {
            return MediaVideosApiFp.addVideo(params, options)(fetch, basePath);
        },
        /** 
         * Add a new video comment
         * @param videoId The video id 
         * @param commentResource The comment object
         */
        addVideoComment(params: {  "videoId": number; "commentResource"?: CommentResource; }, options?: any) {
            return MediaVideosApiFp.addVideoComment(params, options)(fetch, basePath);
        },
        /** 
         * Adds a contributor to a video
         * @param videoId The video id
         * @param contributionResource The contribution object
         */
        addVideoContributor(params: {  "videoId": number; "contributionResource"?: ContributionResource; }, options?: any) {
            return MediaVideosApiFp.addVideoContributor(params, options)(fetch, basePath);
        },
        /** 
         * Add a new flag
         * @param videoId The video id
         * @param reason The flag reason
         */
        addVideoFlag(params: {  "videoId": number; "reason"?: string; }, options?: any) {
            return MediaVideosApiFp.addVideoFlag(params, options)(fetch, basePath);
        },
        /** 
         * Adds one or more existing videos as related to this one
         * @param videoId The video id
         * @param videoRelationshipResource The video relationship object 
         */
        addVideoRelationships(params: {  "videoId": number; "videoRelationshipResource"?: VideoRelationshipResource; }, options?: any) {
            return MediaVideosApiFp.addVideoRelationships(params, options)(fetch, basePath);
        },
        /** 
         * Create a video disposition
         * @param videoId The video id
         * @param dispositionResource The disposition object
         */
        createVideoDisposition(params: {  "videoId": number; "dispositionResource"?: DispositionResource; }, options?: any) {
            return MediaVideosApiFp.createVideoDisposition(params, options)(fetch, basePath);
        },
        /** 
         * Deletes a video from the system if no resources are attached to it
         * @param id The video id
         */
        deleteVideo(params: {  "id": number; }, options?: any) {
            return MediaVideosApiFp.deleteVideo(params, options)(fetch, basePath);
        },
        /** 
         * Delete a video comment
         * @param videoId The video id
         * @param id The comment id
         */
        deleteVideoComment(params: {  "videoId": number; "id": number; }, options?: any) {
            return MediaVideosApiFp.deleteVideoComment(params, options)(fetch, basePath);
        },
        /** 
         * Delete a video disposition
         * @param dispositionId The disposition id
         */
        deleteVideoDisposition(params: {  "dispositionId": number; }, options?: any) {
            return MediaVideosApiFp.deleteVideoDisposition(params, options)(fetch, basePath);
        },
        /** 
         * Delete a flag
         * @param videoId The video id
         */
        deleteVideoFlag(params: {  "videoId": number; }, options?: any) {
            return MediaVideosApiFp.deleteVideoFlag(params, options)(fetch, basePath);
        },
        /** 
         * Delete a video&#39;s relationship
         * @param videoId The video id
         * @param id The relationship id
         */
        deleteVideoRelationship(params: {  "videoId": number; "id": number; }, options?: any) {
            return MediaVideosApiFp.deleteVideoRelationship(params, options)(fetch, basePath);
        },
        /** 
         * Get user videos
         * @param userId The user id
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserVideos(params: {  "userId": number; "excludeFlagged"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return MediaVideosApiFp.getUserVideos(params, options)(fetch, basePath);
        },
        /** 
         * Loads a specific video details
         * @param id The video id
         */
        getVideo(params: {  "id": number; }, options?: any) {
            return MediaVideosApiFp.getVideo(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of comments for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoComments(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
            return MediaVideosApiFp.getVideoComments(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of dispositions for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoDispositions(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
            return MediaVideosApiFp.getVideoDispositions(params, options)(fetch, basePath);
        },
        /** 
         * Returns a page of video relationships
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoRelationships(params: {  "videoId": number; "size"?: number; "page"?: number; }, options?: any) {
            return MediaVideosApiFp.getVideoRelationships(params, options)(fetch, basePath);
        },
        /** 
         * Search videos using the documented filters
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param filterVideosByUploader Filter for videos by uploader id
         * @param filterCategory Filter for videos from a specific category by id
         * @param filterTagset Filter for videos with specified tags (separated by comma)
         * @param filterVideosByName Filter for videos which name *STARTS* with the given string
         * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
         * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
         * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
         * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
         * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
         * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
         * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVideos(params: {  "excludeFlagged"?: boolean; "filterVideosByUploader"?: string; "filterCategory"?: string; "filterTagset"?: string; "filterVideosByName"?: string; "filterVideosByContributor"?: string; "filterVideosByAuthor"?: string; "filterHasAuthor"?: boolean; "filterHasUploader"?: boolean; "filterRelatedTo"?: string; "filterFriends"?: boolean; "filterDisposition"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return MediaVideosApiFp.getVideos(params, options)(fetch, basePath);
        },
        /** 
         * Removes a user from a video&#39;s whitelist
         * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
         * @param videoId The video id
         * @param id The user id
         */
        removeUserFromVideoWhitelist(params: {  "videoId": number; "id": number; }, options?: any) {
            return MediaVideosApiFp.removeUserFromVideoWhitelist(params, options)(fetch, basePath);
        },
        /** 
         * Removes a contributor from a video
         * @param videoId The video id
         * @param id The contributor id
         */
        removeVideoContributor(params: {  "videoId": number; "id": number; }, options?: any) {
            return MediaVideosApiFp.removeVideoContributor(params, options)(fetch, basePath);
        },
        /** 
         * Modifies a video&#39;s details
         * @param id The video id
         * @param videoResource The video object
         */
        updateVideo(params: {  "id": number; "videoResource"?: VideoResource; }, options?: any) {
            return MediaVideosApiFp.updateVideo(params, options)(fetch, basePath);
        },
        /** 
         * Update a video comment
         * @param videoId The video id
         * @param id The comment id
         * @param content The comment content
         */
        updateVideoComment(params: {  "videoId": number; "id": number; "content"?: string; }, options?: any) {
            return MediaVideosApiFp.updateVideoComment(params, options)(fetch, basePath);
        },
        /** 
         * Update a video&#39;s relationship details
         * @param videoId The video id
         * @param relationshipId The relationship id
         * @param details The video relationship details
         */
        updateVideoRelationship(params: {  "videoId": number; "relationshipId": number; "details"?: string; }, options?: any) {
            return MediaVideosApiFp.updateVideoRelationship(params, options)(fetch, basePath);
        },
        /** 
         * Increment a video&#39;s view count
         * @param id The video id
         */
        viewVideo(params: {  "id": number; }, options?: any) {
            return MediaVideosApiFp.viewVideo(params, options)(fetch, basePath);
        },
    };
};


/**
 * MessagingApi - fetch parameter creator
 */
export const MessagingApiFetchParamCreator = {
    /** 
     * Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  "rawEmailResource"?: RawEmailResource; }, options?: any): FetchArgs {
        const baseUrl = `/messaging/raw-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawEmailResource"]) {
            fetchOptions.body = JSON.stringify(params["rawEmailResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Send a raw SMS
     * Sends a raw SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  "rawSMSResource"?: RawSMSResource; }, options?: any): FetchArgs {
        const baseUrl = `/messaging/raw-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["rawSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  "messageResource"?: TemplateEmailResource; }, options?: any): FetchArgs {
        const baseUrl = `/messaging/templated-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageResource"]) {
            fetchOptions.body = JSON.stringify(params["messageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Send a new templated SMS
     * Sends a templated SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  "templateSMSResource"?: TemplateSMSResource; }, options?: any): FetchArgs {
        const baseUrl = `/messaging/templated-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["templateSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["templateSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MessagingApi - functional programming interface
 */
export const MessagingApiFp = {
    /** 
     * Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: { "rawEmailResource"?: RawEmailResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Send a raw SMS
     * Sends a raw SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: { "rawSMSResource"?: RawSMSResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawSMS(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: { "messageResource"?: TemplateEmailResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Send a new templated SMS
     * Sends a templated SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: { "templateSMSResource"?: TemplateSMSResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedSMS(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MessagingApi - object-oriented interface
 */
export class MessagingApi extends BaseAPI {
    /** 
     * Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  "rawEmailResource"?: RawEmailResource; }, options?: any) {
        return MessagingApiFp.sendRawEmail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Send a raw SMS
     * Sends a raw SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  "rawSMSResource"?: RawSMSResource; }, options?: any) {
        return MessagingApiFp.sendRawSMS(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  "messageResource"?: TemplateEmailResource; }, options?: any) {
        return MessagingApiFp.sendTemplatedEmail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Send a new templated SMS
     * Sends a templated SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  "templateSMSResource"?: TemplateSMSResource; }, options?: any) {
        return MessagingApiFp.sendTemplatedSMS(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MessagingApi - factory interface
 */
export const MessagingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Send a raw email to one or more users
         * @param rawEmailResource The new raw email to be sent
         */
        sendRawEmail(params: {  "rawEmailResource"?: RawEmailResource; }, options?: any) {
            return MessagingApiFp.sendRawEmail(params, options)(fetch, basePath);
        },
        /** 
         * Send a raw SMS
         * Sends a raw SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
         * @param rawSMSResource The new raw SMS to be sent
         */
        sendRawSMS(params: {  "rawSMSResource"?: RawSMSResource; }, options?: any) {
            return MessagingApiFp.sendRawSMS(params, options)(fetch, basePath);
        },
        /** 
         * Send a templated email to one or more users
         * @param messageResource The new template email to be sent
         */
        sendTemplatedEmail(params: {  "messageResource"?: TemplateEmailResource; }, options?: any) {
            return MessagingApiFp.sendTemplatedEmail(params, options)(fetch, basePath);
        },
        /** 
         * Send a new templated SMS
         * Sends a templated SMS text message to one or more users. User&#39;s without registered mobile numbers will be skipped.
         * @param templateSMSResource The new template SMS to be sent
         */
        sendTemplatedSMS(params: {  "templateSMSResource"?: TemplateSMSResource; }, options?: any) {
            return MessagingApiFp.sendTemplatedSMS(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsApi - fetch parameter creator
 */
export const PaymentsApiFetchParamCreator = {
    /** 
     * Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  "userId": number; "paymentMethod"?: PaymentMethodResource; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  "userId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deletePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  "userId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  "userId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethods");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  "request"?: PaymentAuthorizationResource; }, options?: any): FetchArgs {
        const baseUrl = `/payment/authorizations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling paymentCapture");
        }
        const baseUrl = `/payment/authorizations/{id}/capture`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  "userId": number; "id": number; "paymentMethod"?: PaymentMethodResource; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updatePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = {
    /** 
     * Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: { "userId": number; "paymentMethod"?: PaymentMethodResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.createPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: { "userId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.deletePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: { "userId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: { "userId": number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PaymentMethodResource>> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethods(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: { "request"?: PaymentAuthorizationResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentAuthorizationResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentAuthorization(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentCapture(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: { "userId": number; "id": number; "paymentMethod"?: PaymentMethodResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.updatePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /** 
     * Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  "userId": number; "paymentMethod"?: PaymentMethodResource; }, options?: any) {
        return PaymentsApiFp.createPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  "userId": number; "id": number; }, options?: any) {
        return PaymentsApiFp.deletePaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  "userId": number; "id": number; }, options?: any) {
        return PaymentsApiFp.getPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  "userId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return PaymentsApiFp.getPaymentMethods(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  "request"?: PaymentAuthorizationResource; }, options?: any) {
        return PaymentsApiFp.paymentAuthorization(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  "id": number; }, options?: any) {
        return PaymentsApiFp.paymentCapture(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  "userId": number; "id": number; "paymentMethod"?: PaymentMethodResource; }, options?: any) {
        return PaymentsApiFp.updatePaymentMethod(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new payment method for a user
         * @param userId ID of the user for whom the payment method is being created
         * @param paymentMethod Payment method being created
         */
        createPaymentMethod(params: {  "userId": number; "paymentMethod"?: PaymentMethodResource; }, options?: any) {
            return PaymentsApiFp.createPaymentMethod(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being deleted
         */
        deletePaymentMethod(params: {  "userId": number; "id": number; }, options?: any) {
            return PaymentsApiFp.deletePaymentMethod(params, options)(fetch, basePath);
        },
        /** 
         * Get a single payment method for a user
         * @param userId ID of the user for whom the payment method is being retrieved
         * @param id ID of the payment method being retrieved
         */
        getPaymentMethod(params: {  "userId": number; "id": number; }, options?: any) {
            return PaymentsApiFp.getPaymentMethod(params, options)(fetch, basePath);
        },
        /** 
         * Get all payment methods for a user
         * @param userId ID of the user for whom the payment methods are being retrieved
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPaymentMethods(params: {  "userId": number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return PaymentsApiFp.getPaymentMethods(params, options)(fetch, basePath);
        },
        /** 
         * Authorize payment of an invoice for later capture
         * @param request Payment authorization request
         */
        paymentAuthorization(params: {  "request"?: PaymentAuthorizationResource; }, options?: any) {
            return PaymentsApiFp.paymentAuthorization(params, options)(fetch, basePath);
        },
        /** 
         * Capture an existing invoice payment authorization
         * @param id ID of the payment authorization to capture
         */
        paymentCapture(params: {  "id": number; }, options?: any) {
            return PaymentsApiFp.paymentCapture(params, options)(fetch, basePath);
        },
        /** 
         * Update an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being updated
         * @param paymentMethod The updated payment method data
         */
        updatePaymentMethod(params: {  "userId": number; "id": number; "paymentMethod"?: PaymentMethodResource; }, options?: any) {
            return PaymentsApiFp.updatePaymentMethod(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsAppleApi - fetch parameter creator
 */
export const PaymentsAppleApiFetchParamCreator = {
    /** 
     * Pay invoice with Apple receipt
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  "request"?: ApplyPaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/apple/receipt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsAppleApi - functional programming interface
 */
export const PaymentsAppleApiFp = {
    /** 
     * Pay invoice with Apple receipt
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: { "request"?: ApplyPaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsAppleApiFetchParamCreator.verifyAppleReceipt(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsAppleApi - object-oriented interface
 */
export class PaymentsAppleApi extends BaseAPI {
    /** 
     * Pay invoice with Apple receipt
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  "request"?: ApplyPaymentRequest; }, options?: any) {
        return PaymentsAppleApiFp.verifyAppleReceipt(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsAppleApi - factory interface
 */
export const PaymentsAppleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Pay invoice with Apple receipt
         * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
         * @param request The request for paying an invoice through an Apple receipt
         */
        verifyAppleReceipt(params: {  "request"?: ApplyPaymentRequest; }, options?: any) {
            return PaymentsAppleApiFp.verifyAppleReceipt(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsGoogleApi - fetch parameter creator
 */
export const PaymentsGoogleApiFetchParamCreator = {
    /** 
     * Mark an invoice paid with Google
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: {  "request"?: GooglePaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/google/payments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsGoogleApi - functional programming interface
 */
export const PaymentsGoogleApiFp = {
    /** 
     * Mark an invoice paid with Google
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: { "request"?: GooglePaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = PaymentsGoogleApiFetchParamCreator.handleGooglePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsGoogleApi - object-oriented interface
 */
export class PaymentsGoogleApi extends BaseAPI {
    /** 
     * Mark an invoice paid with Google
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: {  "request"?: GooglePaymentRequest; }, options?: any) {
        return PaymentsGoogleApiFp.handleGooglePayment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsGoogleApi - factory interface
 */
export const PaymentsGoogleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Mark an invoice paid with Google
         * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
         * @param request The request for paying an invoice through a Google in-app payment
         */
        handleGooglePayment(params: {  "request"?: GooglePaymentRequest; }, options?: any) {
            return PaymentsGoogleApiFp.handleGooglePayment(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsOptimalApi - fetch parameter creator
 */
export const PaymentsOptimalApiFetchParamCreator = {
    /** 
     * Initiate silent post with Optimal
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  "request"?: OptimalPaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/optimal/silent`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsOptimalApi - functional programming interface
 */
export const PaymentsOptimalApiFp = {
    /** 
     * Initiate silent post with Optimal
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: { "request"?: OptimalPaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsOptimalApiFetchParamCreator.silentPostOptimal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsOptimalApi - object-oriented interface
 */
export class PaymentsOptimalApi extends BaseAPI {
    /** 
     * Initiate silent post with Optimal
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  "request"?: OptimalPaymentRequest; }, options?: any) {
        return PaymentsOptimalApiFp.silentPostOptimal(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsOptimalApi - factory interface
 */
export const PaymentsOptimalApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Initiate silent post with Optimal
         * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
         * @param request The payment request to initiate
         */
        silentPostOptimal(params: {  "request"?: OptimalPaymentRequest; }, options?: any) {
            return PaymentsOptimalApiFp.silentPostOptimal(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsPayPalClassicApi - fetch parameter creator
 */
export const PaymentsPayPalClassicApiFetchParamCreator = {
    /** 
     * Create a PayPal Classic billing agreement for the user
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  "request"?: CreateBillingAgreementRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a payment token for PayPal express checkout
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  "request"?: CreatePayPalPaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Finalizes a billing agreement after the user has accepted through PayPal
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  "request"?: FinalizeBillingAgreementRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Finalizes a payment after the user has completed checkout with PayPal
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  "request"?: FinalizePayPalPaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsPayPalClassicApi - functional programming interface
 */
export const PaymentsPayPalClassicApiFp = {
    /** 
     * Create a PayPal Classic billing agreement for the user
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: { "request"?: CreateBillingAgreementRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.createPayPalBillingAgreementUrl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a payment token for PayPal express checkout
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: { "request"?: CreatePayPalPaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.createPayPalExpressCheckout(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Finalizes a billing agreement after the user has accepted through PayPal
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: { "request"?: FinalizeBillingAgreementRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.finalizePayPalBillingAgreement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Finalizes a payment after the user has completed checkout with PayPal
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: { "request"?: FinalizePayPalPaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.finalizePayPalCheckout(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsPayPalClassicApi - object-oriented interface
 */
export class PaymentsPayPalClassicApi extends BaseAPI {
    /** 
     * Create a PayPal Classic billing agreement for the user
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  "request"?: CreateBillingAgreementRequest; }, options?: any) {
        return PaymentsPayPalClassicApiFp.createPayPalBillingAgreementUrl(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a payment token for PayPal express checkout
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  "request"?: CreatePayPalPaymentRequest; }, options?: any) {
        return PaymentsPayPalClassicApiFp.createPayPalExpressCheckout(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Finalizes a billing agreement after the user has accepted through PayPal
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  "request"?: FinalizeBillingAgreementRequest; }, options?: any) {
        return PaymentsPayPalClassicApiFp.finalizePayPalBillingAgreement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Finalizes a payment after the user has completed checkout with PayPal
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  "request"?: FinalizePayPalPaymentRequest; }, options?: any) {
        return PaymentsPayPalClassicApiFp.finalizePayPalCheckout(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsPayPalClassicApi - factory interface
 */
export const PaymentsPayPalClassicApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a PayPal Classic billing agreement for the user
         * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
         * @param request The request to create a PayPal billing agreement
         */
        createPayPalBillingAgreementUrl(params: {  "request"?: CreateBillingAgreementRequest; }, options?: any) {
            return PaymentsPayPalClassicApiFp.createPayPalBillingAgreementUrl(params, options)(fetch, basePath);
        },
        /** 
         * Create a payment token for PayPal express checkout
         * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
         * @param request The request to create a PayPal payment token
         */
        createPayPalExpressCheckout(params: {  "request"?: CreatePayPalPaymentRequest; }, options?: any) {
            return PaymentsPayPalClassicApiFp.createPayPalExpressCheckout(params, options)(fetch, basePath);
        },
        /** 
         * Finalizes a billing agreement after the user has accepted through PayPal
         * Returns the ID of the new payment method created for the user for the billing agreement.
         * @param request The request to finalize a PayPal billing agreement
         */
        finalizePayPalBillingAgreement(params: {  "request"?: FinalizeBillingAgreementRequest; }, options?: any) {
            return PaymentsPayPalClassicApiFp.finalizePayPalBillingAgreement(params, options)(fetch, basePath);
        },
        /** 
         * Finalizes a payment after the user has completed checkout with PayPal
         * The invoice will be marked paid/failed by asynchronous IPN callback.
         * @param request The request to finalize the payment
         */
        finalizePayPalCheckout(params: {  "request"?: FinalizePayPalPaymentRequest; }, options?: any) {
            return PaymentsPayPalClassicApiFp.finalizePayPalCheckout(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsStripeApi - fetch parameter creator
 */
export const PaymentsStripeApiFetchParamCreator = {
    /** 
     * Create a Stripe payment method for a user
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  "request"?: StripeCreatePaymentMethod; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payment-methods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  "request"?: StripePaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsStripeApi - functional programming interface
 */
export const PaymentsStripeApiFp = {
    /** 
     * Create a Stripe payment method for a user
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: { "request"?: StripeCreatePaymentMethod;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsStripeApiFetchParamCreator.createStripePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: { "request"?: StripePaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsStripeApiFetchParamCreator.payStripeInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsStripeApi - object-oriented interface
 */
export class PaymentsStripeApi extends BaseAPI {
    /** 
     * Create a Stripe payment method for a user
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  "request"?: StripeCreatePaymentMethod; }, options?: any) {
        return PaymentsStripeApiFp.createStripePaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  "request"?: StripePaymentRequest; }, options?: any) {
        return PaymentsStripeApiFp.payStripeInvoice(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsStripeApi - factory interface
 */
export const PaymentsStripeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a Stripe payment method for a user
         * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
         * @param request The request to create a Stripe customer with payment info
         */
        createStripePaymentMethod(params: {  "request"?: StripeCreatePaymentMethod; }, options?: any) {
            return PaymentsStripeApiFp.createStripePaymentMethod(params, options)(fetch, basePath);
        },
        /** 
         * Pay with a single use token
         * @param request The request to pay an invoice
         */
        payStripeInvoice(params: {  "request"?: StripePaymentRequest; }, options?: any) {
            return PaymentsStripeApiFp.payStripeInvoice(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsTransactionsApi - fetch parameter creator
 */
export const PaymentsTransactionsApiFetchParamCreator = {
    /** 
     * Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTransaction");
        }
        const baseUrl = `/transactions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  "filterInvoice"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_invoice": params["filterInvoice"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Refund a payment transaction, in full or in part
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  "id": number; "request"?: RefundRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling refundTransaction");
        }
        const baseUrl = `/transactions/{id}/refunds`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsTransactionsApi - functional programming interface
 */
export const PaymentsTransactionsApiFp = {
    /** 
     * Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TransactionResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.getTransaction(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: { "filterInvoice"?: number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTransactionResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.getTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Refund a payment transaction, in full or in part
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: { "id": number; "request"?: RefundRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RefundResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.refundTransaction(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsTransactionsApi - object-oriented interface
 */
export class PaymentsTransactionsApi extends BaseAPI {
    /** 
     * Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  "id": number; }, options?: any) {
        return PaymentsTransactionsApiFp.getTransaction(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  "filterInvoice"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return PaymentsTransactionsApiFp.getTransactions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Refund a payment transaction, in full or in part
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  "id": number; "request"?: RefundRequest; }, options?: any) {
        return PaymentsTransactionsApiFp.refundTransaction(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsTransactionsApi - factory interface
 */
export const PaymentsTransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get the details for a single transaction
         * @param id id
         */
        getTransaction(params: {  "id": number; }, options?: any) {
            return PaymentsTransactionsApiFp.getTransaction(params, options)(fetch, basePath);
        },
        /** 
         * List and search transactions
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTransactions(params: {  "filterInvoice"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return PaymentsTransactionsApiFp.getTransactions(params, options)(fetch, basePath);
        },
        /** 
         * Refund a payment transaction, in full or in part
         * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
         * @param id The id of the transaction to refund
         * @param request Request containing refund details
         */
        refundTransaction(params: {  "id": number; "request"?: RefundRequest; }, options?: any) {
            return PaymentsTransactionsApiFp.refundTransaction(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsWalletsApi - fetch parameter creator
 */
export const PaymentsWalletsApiFetchParamCreator = {
    /** 
     * Returns the user&#39;s wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  "userId": number; "currencyCode": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallet");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWallet");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a user&#39;s wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  "userId": number; "currencyCode": string; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWalletTransactions");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWalletTransactions");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/transactions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_type": params["filterType"],
            "filter_max_date": params["filterMaxDate"],
            "filter_min_date": params["filterMinDate"],
            "filter_sign": params["filterSign"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List all of a user&#39;s wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallets");
        }
        const baseUrl = `/users/{user_id}/wallets`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options?: any): FetchArgs {
        const baseUrl = `/wallets/totals`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  "filterInvoice"?: number; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "filterUserId"?: number; "filterUsername"?: string; "filterDetails"?: string; "filterCurrencyCode"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/wallets/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_invoice": params["filterInvoice"],
            "filter_type": params["filterType"],
            "filter_max_date": params["filterMaxDate"],
            "filter_min_date": params["filterMinDate"],
            "filter_sign": params["filterSign"],
            "filter_user_id": params["filterUserId"],
            "filter_username": params["filterUsername"],
            "filter_details": params["filterDetails"],
            "filter_currency_code": params["filterCurrencyCode"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/wallets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates the balance for a user&#39;s wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  "userId": number; "currencyCode": string; "request"?: WalletAlterRequest; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateWalletBalance");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling updateWalletBalance");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/balance`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsWalletsApi - functional programming interface
 */
export const PaymentsWalletsApiFp = {
    /** 
     * Returns the user&#39;s wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: { "userId": number; "currencyCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleWallet> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWallet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a user&#39;s wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: { "userId": number; "currencyCode": string; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWalletTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List all of a user&#39;s wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimpleWallet>> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWallets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceWalletTotalResponse> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWalletBalances(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: { "filterInvoice"?: number; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "filterUserId"?: number; "filterUsername"?: string; "filterDetails"?: string; "filterCurrencyCode"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWalletTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSimpleWallet> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWallets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates the balance for a user&#39;s wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: { "userId": number; "currencyCode": string; "request"?: WalletAlterRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.updateWalletBalance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsWalletsApi - object-oriented interface
 */
export class PaymentsWalletsApi extends BaseAPI {
    /** 
     * Returns the user&#39;s wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  "userId": number; "currencyCode": string; }, options?: any) {
        return PaymentsWalletsApiFp.getUserWallet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a user&#39;s wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  "userId": number; "currencyCode": string; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return PaymentsWalletsApiFp.getUserWalletTransactions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List all of a user&#39;s wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  "userId": number; }, options?: any) {
        return PaymentsWalletsApiFp.getUserWallets(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options?: any) {
        return PaymentsWalletsApiFp.getWalletBalances(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  "filterInvoice"?: number; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "filterUserId"?: number; "filterUsername"?: string; "filterDetails"?: string; "filterCurrencyCode"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return PaymentsWalletsApiFp.getWalletTransactions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return PaymentsWalletsApiFp.getWallets(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates the balance for a user&#39;s wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  "userId": number; "currencyCode": string; "request"?: WalletAlterRequest; }, options?: any) {
        return PaymentsWalletsApiFp.updateWalletBalance(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsWalletsApi - factory interface
 */
export const PaymentsWalletsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Returns the user&#39;s wallet for the given currency code
         * @param userId The ID of the user for whom wallet is being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         */
        getUserWallet(params: {  "userId": number; "currencyCode": string; }, options?: any) {
            return PaymentsWalletsApiFp.getUserWallet(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a user&#39;s wallet transactions
         * @param userId The ID of the user for whom wallet transactions are being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param filterType Filter for transactions with specified type
         * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
         * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
         * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserWalletTransactions(params: {  "userId": number; "currencyCode": string; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return PaymentsWalletsApiFp.getUserWalletTransactions(params, options)(fetch, basePath);
        },
        /** 
         * List all of a user&#39;s wallets
         * @param userId The ID of the user for whom wallets are being retrieved
         */
        getUserWallets(params: {  "userId": number; }, options?: any) {
            return PaymentsWalletsApiFp.getUserWallets(params, options)(fetch, basePath);
        },
        /** 
         * Retrieves a summation of wallet balances by currency code
         */
        getWalletBalances(options?: any) {
            return PaymentsWalletsApiFp.getWalletBalances(options)(fetch, basePath);
        },
        /** 
         * Retrieve wallet transactions across the system
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param filterType Filter for transactions with specified type
         * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
         * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
         * @param filterSign Filter for transactions with amount with the given sign
         * @param filterUserId Filter for transactions for specific userId
         * @param filterUsername Filter for transactions for specific username that start with the given string
         * @param filterDetails Filter for transactions for specific details that start with the given string
         * @param filterCurrencyCode Filter for transactions for specific currency code
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWalletTransactions(params: {  "filterInvoice"?: number; "filterType"?: string; "filterMaxDate"?: number; "filterMinDate"?: number; "filterSign"?: string; "filterUserId"?: number; "filterUsername"?: string; "filterDetails"?: string; "filterCurrencyCode"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return PaymentsWalletsApiFp.getWalletTransactions(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a list of wallets across the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWallets(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return PaymentsWalletsApiFp.getWallets(params, options)(fetch, basePath);
        },
        /** 
         * Updates the balance for a user&#39;s wallet
         * @param userId The ID of the user for whom wallet is being modified
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param request The requested balance modification to be made to the user&#39;s wallet
         */
        updateWalletBalance(params: {  "userId": number; "currencyCode": string; "request"?: WalletAlterRequest; }, options?: any) {
            return PaymentsWalletsApiFp.updateWalletBalance(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsXsollaApi - fetch parameter creator
 */
export const PaymentsXsollaApiFetchParamCreator = {
    /** 
     * Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  "request"?: XsollaPaymentRequest; }, options?: any): FetchArgs {
        const baseUrl = `/payment/provider/xsolla/payment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Receives payment response from Xsolla
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     */
    receiveXsollaNotification(options?: any): FetchArgs {
        const baseUrl = `/payment/provider/xsolla/notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsXsollaApi - functional programming interface
 */
export const PaymentsXsollaApiFp = {
    /** 
     * Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: { "request"?: XsollaPaymentRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsXsollaApiFetchParamCreator.createXsollaTokenUrl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Receives payment response from Xsolla
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     */
    receiveXsollaNotification(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsXsollaApiFetchParamCreator.receiveXsollaNotification(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsXsollaApi - object-oriented interface
 */
export class PaymentsXsollaApi extends BaseAPI {
    /** 
     * Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  "request"?: XsollaPaymentRequest; }, options?: any) {
        return PaymentsXsollaApiFp.createXsollaTokenUrl(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Receives payment response from Xsolla
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     */
    receiveXsollaNotification(options?: any) {
        return PaymentsXsollaApiFp.receiveXsollaNotification(options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsXsollaApi - factory interface
 */
export const PaymentsXsollaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a payment token that should be used to forward the user to Xsolla so they can complete payment
         * @param request The payment request to be sent to XSolla
         */
        createXsollaTokenUrl(params: {  "request"?: XsollaPaymentRequest; }, options?: any) {
            return PaymentsXsollaApiFp.createXsollaTokenUrl(params, options)(fetch, basePath);
        },
        /** 
         * Receives payment response from Xsolla
         * Only used by Xsolla to call back to JSAPI after processing user payment action
         */
        receiveXsollaNotification(options?: any) {
            return PaymentsXsollaApiFp.receiveXsollaNotification(options)(fetch, basePath);
        },
    };
};


/**
 * ReportingChallengesApi - fetch parameter creator
 */
export const ReportingChallengesApiFetchParamCreator = {
    /** 
     * Retrieve a challenge event leaderboard details
     * Lists all leaderboard entries with additional user details
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventLeaderboard(params: {  "filterEvent"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/reporting/events/leaderboard`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_event": params["filterEvent"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a challenge event participant details
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventParticipants(params: {  "filterEvent"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/reporting/events/participants`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_event": params["filterEvent"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingChallengesApi - functional programming interface
 */
export const ReportingChallengesApiFp = {
    /** 
     * Retrieve a challenge event leaderboard details
     * Lists all leaderboard entries with additional user details
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventLeaderboard(params: { "filterEvent"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = ReportingChallengesApiFetchParamCreator.getChallengeEventLeaderboard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a challenge event participant details
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventParticipants(params: { "filterEvent"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = ReportingChallengesApiFetchParamCreator.getChallengeEventParticipants(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingChallengesApi - object-oriented interface
 */
export class ReportingChallengesApi extends BaseAPI {
    /** 
     * Retrieve a challenge event leaderboard details
     * Lists all leaderboard entries with additional user details
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventLeaderboard(params: {  "filterEvent"?: number; }, options?: any) {
        return ReportingChallengesApiFp.getChallengeEventLeaderboard(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a challenge event participant details
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @param filterEvent A sepecific challenge event id
     */
    getChallengeEventParticipants(params: {  "filterEvent"?: number; }, options?: any) {
        return ReportingChallengesApiFp.getChallengeEventParticipants(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingChallengesApi - factory interface
 */
export const ReportingChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve a challenge event leaderboard details
         * Lists all leaderboard entries with additional user details
         * @param filterEvent A sepecific challenge event id
         */
        getChallengeEventLeaderboard(params: {  "filterEvent"?: number; }, options?: any) {
            return ReportingChallengesApiFp.getChallengeEventLeaderboard(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a challenge event participant details
         * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
         * @param filterEvent A sepecific challenge event id
         */
        getChallengeEventParticipants(params: {  "filterEvent"?: number; }, options?: any) {
            return ReportingChallengesApiFp.getChallengeEventParticipants(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingOrdersApi - fetch parameter creator
 */
export const ReportingOrdersApiFetchParamCreator = {
    /** 
     * Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     */
    getInvoiceReports(params: {  "currencyCode": string; "granularity"?: string; "filterPaymentStatus"?: string; "filterFulfillmentStatus"?: string; "startDate"?: number; "endDate"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getInvoiceReports");
        }
        const baseUrl = `/reporting/orders/count/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "granularity": params["granularity"],
            "filter_payment_status": params["filterPaymentStatus"],
            "filter_fulfillment_status": params["filterFulfillmentStatus"],
            "start_date": params["startDate"],
            "end_date": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingOrdersApi - functional programming interface
 */
export const ReportingOrdersApiFp = {
    /** 
     * Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     */
    getInvoiceReports(params: { "currencyCode": string; "granularity"?: string; "filterPaymentStatus"?: string; "filterFulfillmentStatus"?: string; "startDate"?: number; "endDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceAggregateInvoiceReportResource> {
        const fetchArgs = ReportingOrdersApiFetchParamCreator.getInvoiceReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingOrdersApi - object-oriented interface
 */
export class ReportingOrdersApi extends BaseAPI {
    /** 
     * Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     */
    getInvoiceReports(params: {  "currencyCode": string; "granularity"?: string; "filterPaymentStatus"?: string; "filterFulfillmentStatus"?: string; "startDate"?: number; "endDate"?: number; }, options?: any) {
        return ReportingOrdersApiFp.getInvoiceReports(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingOrdersApi - factory interface
 */
export const ReportingOrdersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve invoice counts aggregated by time ranges
         * @param currencyCode The code for a currency to get sales data for
         * @param granularity The time duration to aggregate by
         * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
         * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
         * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
         */
        getInvoiceReports(params: {  "currencyCode": string; "granularity"?: string; "filterPaymentStatus"?: string; "filterFulfillmentStatus"?: string; "startDate"?: number; "endDate"?: number; }, options?: any) {
            return ReportingOrdersApiFp.getInvoiceReports(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingRevenueApi - fetch parameter creator
 */
export const ReportingRevenueApiFetchParamCreator = {
    /** 
     * Get item revenue info
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getItemRevenue");
        }
        const baseUrl = `/reporting/revenue/item-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get refund revenue info
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRefundRevenue");
        }
        const baseUrl = `/reporting/revenue/refunds/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get revenue info by country
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByCountry");
        }
        const baseUrl = `/reporting/revenue/countries/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get revenue info by item
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByItem");
        }
        const baseUrl = `/reporting/revenue/products/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get subscription revenue info
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getSubscriptionRevenue");
        }
        const baseUrl = `/reporting/revenue/subscription-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingRevenueApi - functional programming interface
 */
export const ReportingRevenueApiFp = {
    /** 
     * Get item revenue info
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: { "currencyCode": string; "startDate"?: number; "endDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getItemRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get refund revenue info
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: { "currencyCode": string; "startDate"?: number; "endDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRefundRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get revenue info by country
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: { "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceRevenueCountryReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRevenueByCountry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get revenue info by item
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: { "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceRevenueProductReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRevenueByItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get subscription revenue info
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: { "currencyCode": string; "startDate"?: number; "endDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getSubscriptionRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingRevenueApi - object-oriented interface
 */
export class ReportingRevenueApi extends BaseAPI {
    /** 
     * Get item revenue info
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
        return ReportingRevenueApiFp.getItemRevenue(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get refund revenue info
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
        return ReportingRevenueApiFp.getRefundRevenue(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get revenue info by country
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingRevenueApiFp.getRevenueByCountry(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get revenue info by item
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingRevenueApiFp.getRevenueByItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get subscription revenue info
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
        return ReportingRevenueApiFp.getSubscriptionRevenue(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingRevenueApi - factory interface
 */
export const ReportingRevenueApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get item revenue info
         * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getItemRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
            return ReportingRevenueApiFp.getItemRevenue(params, options)(fetch, basePath);
        },
        /** 
         * Get refund revenue info
         * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
         * @param currencyCode The code for a currency to get refund data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getRefundRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
            return ReportingRevenueApiFp.getRefundRevenue(params, options)(fetch, basePath);
        },
        /** 
         * Get revenue info by country
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByCountry(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingRevenueApiFp.getRevenueByCountry(params, options)(fetch, basePath);
        },
        /** 
         * Get revenue info by item
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByItem(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingRevenueApiFp.getRevenueByItem(params, options)(fetch, basePath);
        },
        /** 
         * Get subscription revenue info
         * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getSubscriptionRevenue(params: {  "currencyCode": string; "startDate"?: number; "endDate"?: number; }, options?: any) {
            return ReportingRevenueApiFp.getSubscriptionRevenue(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingSubscriptionsApi - fetch parameter creator
 */
export const ReportingSubscriptionsApiFetchParamCreator = {
    /** 
     * Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/reporting/subscription`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingSubscriptionsApi - functional programming interface
 */
export const ReportingSubscriptionsApiFp = {
    /** 
     * Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: { "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceBillingReport> {
        const fetchArgs = ReportingSubscriptionsApiFetchParamCreator.getSubscriptionReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingSubscriptionsApi - object-oriented interface
 */
export class ReportingSubscriptionsApi extends BaseAPI {
    /** 
     * Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  "size"?: number; "page"?: number; }, options?: any) {
        return ReportingSubscriptionsApiFp.getSubscriptionReports(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingSubscriptionsApi - factory interface
 */
export const ReportingSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get a list of available subscription reports in most recent first order
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getSubscriptionReports(params: {  "size"?: number; "page"?: number; }, options?: any) {
            return ReportingSubscriptionsApiFp.getSubscriptionReports(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingUsageApi - fetch parameter creator
 */
export const ReportingUsageApiFetchParamCreator = {
    /** 
     * Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByDay");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByDay");
        }
        const baseUrl = `/reporting/usage/day`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "combine_endpoints": params["combineEndpoints"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByHour");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByHour");
        }
        const baseUrl = `/reporting/usage/hour`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "combine_endpoints": params["combineEndpoints"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMinute");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMinute");
        }
        const baseUrl = `/reporting/usage/minute`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "combine_endpoints": params["combineEndpoints"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMonth");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMonth");
        }
        const baseUrl = `/reporting/usage/month`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "combine_endpoints": params["combineEndpoints"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByYear");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByYear");
        }
        const baseUrl = `/reporting/usage/year`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start_date": params["startDate"],
            "end_date": params["endDate"],
            "combine_endpoints": params["combineEndpoints"],
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingUsageApi - functional programming interface
 */
export const ReportingUsageApiFp = {
    /** 
     * Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: { "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByDay(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: { "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByHour(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: { "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByMinute(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: { "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByMonth(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: { "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByYear(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingUsageApi - object-oriented interface
 */
export class ReportingUsageApi extends BaseAPI {
    /** 
     * Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingUsageApiFp.getUsageByDay(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingUsageApiFp.getUsageByHour(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingUsageApiFp.getUsageByMinute(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingUsageApiFp.getUsageByMonth(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
        return ReportingUsageApiFp.getUsageByYear(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingUsageApi - factory interface
 */
export const ReportingUsageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Returns aggregated endpoint usage information by day
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByDay(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingUsageApiFp.getUsageByDay(params, options)(fetch, basePath);
        },
        /** 
         * Returns aggregated endpoint usage information by hour
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByHour(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingUsageApiFp.getUsageByHour(params, options)(fetch, basePath);
        },
        /** 
         * Returns aggregated endpoint usage information by minute
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMinute(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingUsageApiFp.getUsageByMinute(params, options)(fetch, basePath);
        },
        /** 
         * Returns aggregated endpoint usage information by month
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMonth(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingUsageApiFp.getUsageByMonth(params, options)(fetch, basePath);
        },
        /** 
         * Returns aggregated endpoint usage information by year
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByYear(params: {  "startDate": number; "endDate": number; "combineEndpoints"?: boolean; "size"?: number; "page"?: number; }, options?: any) {
            return ReportingUsageApiFp.getUsageByYear(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingUsersApi - fetch parameter creator
 */
export const ReportingUsersApiFetchParamCreator = {
    /** 
     * Get user registration info
     * Get user registration counts grouped by time range
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getUserRegistrations(params: {  "granularity"?: string; "startDate"?: number; "endDate"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/reporting/users/registrations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "granularity": params["granularity"],
            "start_date": params["startDate"],
            "end_date": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingUsersApi - functional programming interface
 */
export const ReportingUsersApiFp = {
    /** 
     * Get user registration info
     * Get user registration counts grouped by time range
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getUserRegistrations(params: { "granularity"?: string; "startDate"?: number; "endDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceAggregateCountResource> {
        const fetchArgs = ReportingUsersApiFetchParamCreator.getUserRegistrations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingUsersApi - object-oriented interface
 */
export class ReportingUsersApi extends BaseAPI {
    /** 
     * Get user registration info
     * Get user registration counts grouped by time range
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getUserRegistrations(params: {  "granularity"?: string; "startDate"?: number; "endDate"?: number; }, options?: any) {
        return ReportingUsersApiFp.getUserRegistrations(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingUsersApi - factory interface
 */
export const ReportingUsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get user registration info
         * Get user registration counts grouped by time range
         * @param granularity The time duration to aggregate by
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getUserRegistrations(params: {  "granularity"?: string; "startDate"?: number; "endDate"?: number; }, options?: any) {
            return ReportingUsersApiFp.getUserRegistrations(params, options)(fetch, basePath);
        },
    };
};


/**
 * SearchApi - fetch parameter creator
 */
export const SearchApiFetchParamCreator = {
    /** 
     * Add a new object to an index
     * Mainly intended for internal use.
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: {  "type": string; "id": string; "object"?: any; }, options?: any): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling addSearchIndex");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addSearchIndex");
        }
        const baseUrl = `/search/index/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["object"]) {
            fetchOptions.body = JSON.stringify(params["object"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Register reference mappings
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @param mappings The mappings to add
     */
    addSearchMappings(params: {  "mappings"?: Array<SearchReferenceMapping>; }, options?: any): FetchArgs {
        const baseUrl = `/search/mappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["mappings"]) {
            fetchOptions.body = JSON.stringify(params["mappings"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an object
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: {  "type": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling deleteSearchIndex");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSearchIndex");
        }
        const baseUrl = `/search/index/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete all objects in an index
     * Mainly intended for internal use
     * @param type The index type
     */
    deleteSearchIndexes(params: {  "type": string; }, options?: any): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling deleteSearchIndexes");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Search an index
     * The body is an ElasticSearch query in JSON format. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options. The searchable object&#39;s format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: {  "type": string; "query"?: any; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndex");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = {
    /** 
     * Add a new object to an index
     * Mainly intended for internal use.
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: { "type": string; "id": string; "object"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.addSearchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Register reference mappings
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @param mappings The mappings to add
     */
    addSearchMappings(params: { "mappings"?: Array<SearchReferenceMapping>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.addSearchMappings(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an object
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: { "type": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.deleteSearchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete all objects in an index
     * Mainly intended for internal use
     * @param type The index type
     */
    deleteSearchIndexes(params: { "type": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.deleteSearchIndexes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Search an index
     * The body is an ElasticSearch query in JSON format. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options. The searchable object&#39;s format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: { "type": string; "query"?: any; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceMapstringobject> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /** 
     * Add a new object to an index
     * Mainly intended for internal use.
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: {  "type": string; "id": string; "object"?: any; }, options?: any) {
        return SearchApiFp.addSearchIndex(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Register reference mappings
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @param mappings The mappings to add
     */
    addSearchMappings(params: {  "mappings"?: Array<SearchReferenceMapping>; }, options?: any) {
        return SearchApiFp.addSearchMappings(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an object
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: {  "type": string; "id": string; }, options?: any) {
        return SearchApiFp.deleteSearchIndex(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete all objects in an index
     * Mainly intended for internal use
     * @param type The index type
     */
    deleteSearchIndexes(params: {  "type": string; }, options?: any) {
        return SearchApiFp.deleteSearchIndexes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Search an index
     * The body is an ElasticSearch query in JSON format. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options. The searchable object&#39;s format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: {  "type": string; "query"?: any; "size"?: number; "page"?: number; }, options?: any) {
        return SearchApiFp.searchIndex(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a new object to an index
         * Mainly intended for internal use.
         * @param type The index type
         * @param id The ID of the object
         * @param object The object to add
         */
        addSearchIndex(params: {  "type": string; "id": string; "object"?: any; }, options?: any) {
            return SearchApiFp.addSearchIndex(params, options)(fetch, basePath);
        },
        /** 
         * Register reference mappings
         * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
         * @param mappings The mappings to add
         */
        addSearchMappings(params: {  "mappings"?: Array<SearchReferenceMapping>; }, options?: any) {
            return SearchApiFp.addSearchMappings(params, options)(fetch, basePath);
        },
        /** 
         * Delete an object
         * Mainly intended for internal use. Requires SEARCH_ADMIN.
         * @param type The index type
         * @param id The ID of the object to delete
         */
        deleteSearchIndex(params: {  "type": string; "id": string; }, options?: any) {
            return SearchApiFp.deleteSearchIndex(params, options)(fetch, basePath);
        },
        /** 
         * Delete all objects in an index
         * Mainly intended for internal use
         * @param type The index type
         */
        deleteSearchIndexes(params: {  "type": string; }, options?: any) {
            return SearchApiFp.deleteSearchIndexes(params, options)(fetch, basePath);
        },
        /** 
         * Search an index
         * The body is an ElasticSearch query in JSON format. Please see their &lt;a href&#x3D;&#39;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#39;&gt;documentation&lt;/a&gt; for details on the format and search options. The searchable object&#39;s format depends on on the type. See individual search endpoints on other resources for details on their format.
         * @param type The index type
         * @param query The query to be used for the search
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        searchIndex(params: {  "type": string; "query"?: any; "size"?: number; "page"?: number; }, options?: any) {
            return SearchApiFp.searchIndex(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreApi - fetch parameter creator
 */
export const StoreApiFetchParamCreator = {
    /** 
     * Create an item template
     * Item Templates define a type of item and the properties they have.
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a store item
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  "storeItem"?: StoreItem; }, options?: any): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single item template
     * Item Templates define a type of item and the properties they have.
     * @param id The id of the template
     */
    getItemTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a listing of store items
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: {  "limit"?: number; "page"?: number; "useCatalog"?: boolean; "ignoreLocation"?: boolean; "inStockOnly"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/store`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "limit": params["limit"],
            "page": params["page"],
            "use_catalog": params["useCatalog"],
            "ignore_location": params["ignoreLocation"],
            "in_stock_only": params["inStockOnly"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  "filterNameSearch"?: string; "filterUniqueKey"?: string; "filterPublished"?: boolean; "filterDisplayable"?: boolean; "filterStart"?: string; "filterEnd"?: string; "filterStartDate"?: string; "filterStopDate"?: string; "filterSku"?: string; "filterPrice"?: string; "filterTag"?: string; "filterItemsByType"?: string; "filterBundledSkus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_name_search": params["filterNameSearch"],
            "filter_unique_key": params["filterUniqueKey"],
            "filter_published": params["filterPublished"],
            "filter_displayable": params["filterDisplayable"],
            "filter_start": params["filterStart"],
            "filter_end": params["filterEnd"],
            "filter_start_date": params["filterStartDate"],
            "filter_stop_date": params["filterStopDate"],
            "filter_sku": params["filterSku"],
            "filter_price": params["filterPrice"],
            "filter_tag": params["filterTag"],
            "filter_items_by_type": params["filterItemsByType"],
            "filter_bundled_skus": params["filterBundledSkus"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  "id": string; "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a store item
     * @param id The id of the item
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  "id": number; "storeItem"?: StoreItem; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreApi - functional programming interface
 */
export const StoreApiFp = {
    /** 
     * Create an item template
     * Item Templates define a type of item and the properties they have.
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: { "itemTemplateResource"?: StoreItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.createItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a store item
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @param storeItem The store item object
     */
    createStoreItem(params: { "storeItem"?: StoreItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.createStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single item template
     * Item Templates define a type of item and the properties they have.
     * @param id The id of the template
     */
    getItemTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceStoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a listing of store items
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: { "limit"?: number; "page"?: number; "useCatalog"?: boolean; "ignoreLocation"?: boolean; "inStockOnly"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceStoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStore(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: { "filterNameSearch"?: string; "filterUniqueKey"?: string; "filterPublished"?: boolean; "filterDisplayable"?: boolean; "filterStart"?: string; "filterEnd"?: string; "filterStartDate"?: string; "filterStopDate"?: string; "filterSku"?: string; "filterPrice"?: string; "filterTag"?: string; "filterItemsByType"?: string; "filterBundledSkus"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceStoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItems(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: { "id": string; "itemTemplateResource"?: StoreItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.updateItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a store item
     * @param id The id of the item
     * @param storeItem The store item object
     */
    updateStoreItem(params: { "id": number; "storeItem"?: StoreItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.updateStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreApi - object-oriented interface
 */
export class StoreApi extends BaseAPI {
    /** 
     * Create an item template
     * Item Templates define a type of item and the properties they have.
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any) {
        return StoreApiFp.createItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a store item
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  "storeItem"?: StoreItem; }, options?: any) {
        return StoreApiFp.createStoreItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return StoreApiFp.deleteItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  "id": number; }, options?: any) {
        return StoreApiFp.deleteStoreItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single item template
     * Item Templates define a type of item and the properties they have.
     * @param id The id of the template
     */
    getItemTemplate(params: {  "id": string; }, options?: any) {
        return StoreApiFp.getItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreApiFp.getItemTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a listing of store items
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: {  "limit"?: number; "page"?: number; "useCatalog"?: boolean; "ignoreLocation"?: boolean; "inStockOnly"?: boolean; }, options?: any) {
        return StoreApiFp.getStore(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  "id": number; }, options?: any) {
        return StoreApiFp.getStoreItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  "filterNameSearch"?: string; "filterUniqueKey"?: string; "filterPublished"?: boolean; "filterDisplayable"?: boolean; "filterStart"?: string; "filterEnd"?: string; "filterStartDate"?: string; "filterStopDate"?: string; "filterSku"?: string; "filterPrice"?: string; "filterTag"?: string; "filterItemsByType"?: string; "filterBundledSkus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreApiFp.getStoreItems(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  "id": string; "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any) {
        return StoreApiFp.updateItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a store item
     * @param id The id of the item
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  "id": number; "storeItem"?: StoreItem; }, options?: any) {
        return StoreApiFp.updateStoreItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreApi - factory interface
 */
export const StoreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create an item template
         * Item Templates define a type of item and the properties they have.
         * @param itemTemplateResource The new item template
         */
        createItemTemplate(params: {  "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any) {
            return StoreApiFp.createItemTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Create a store item
         * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \&quot;parameters\&quot; field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:&lt;br /&gt; {..., parameters: [[{item: 1, skus: [\&quot;SKU-1\&quot;]}]]}&lt;br /&gt; If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
         * @param storeItem The store item object
         */
        createStoreItem(params: {  "storeItem"?: StoreItem; }, options?: any) {
            return StoreApiFp.createStoreItem(params, options)(fetch, basePath);
        },
        /** 
         * Delete an item template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteItemTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return StoreApiFp.deleteItemTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a store item
         * @param id The id of the item
         */
        deleteStoreItem(params: {  "id": number; }, options?: any) {
            return StoreApiFp.deleteStoreItem(params, options)(fetch, basePath);
        },
        /** 
         * Get a single item template
         * Item Templates define a type of item and the properties they have.
         * @param id The id of the template
         */
        getItemTemplate(params: {  "id": string; }, options?: any) {
            return StoreApiFp.getItemTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search item templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getItemTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreApiFp.getItemTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Get a listing of store items
         * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
         * @param limit The amount of items returned
         * @param page The page of the request
         * @param useCatalog Whether to remove items that are not intended for display or not in date
         * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
         * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
         */
        getStore(params: {  "limit"?: number; "page"?: number; "useCatalog"?: boolean; "ignoreLocation"?: boolean; "inStockOnly"?: boolean; }, options?: any) {
            return StoreApiFp.getStore(params, options)(fetch, basePath);
        },
        /** 
         * Get a single store item
         * @param id The id of the item
         */
        getStoreItem(params: {  "id": number; }, options?: any) {
            return StoreApiFp.getStoreItem(params, options)(fetch, basePath);
        },
        /** 
         * List and search store items
         * @param filterNameSearch Filter for items whose name starts with a given string.
         * @param filterUniqueKey Filter for items whose unique_key is a given string.
         * @param filterPublished Filter for skus that have been published.
         * @param filterDisplayable Filter for items that are displayable.
         * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterSku Filter for skus whose name starts with a given string.
         * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
         * @param filterItemsByType Filter for item type based on its type hint.
         * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStoreItems(params: {  "filterNameSearch"?: string; "filterUniqueKey"?: string; "filterPublished"?: boolean; "filterDisplayable"?: boolean; "filterStart"?: string; "filterEnd"?: string; "filterStartDate"?: string; "filterStopDate"?: string; "filterSku"?: string; "filterPrice"?: string; "filterTag"?: string; "filterItemsByType"?: string; "filterBundledSkus"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreApiFp.getStoreItems(params, options)(fetch, basePath);
        },
        /** 
         * Update an item template
         * @param id The id of the template
         * @param itemTemplateResource The item template resource object
         */
        updateItemTemplate(params: {  "id": string; "itemTemplateResource"?: StoreItemTemplateResource; }, options?: any) {
            return StoreApiFp.updateItemTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Update a store item
         * @param id The id of the item
         * @param storeItem The store item object
         */
        updateStoreItem(params: {  "id": number; "storeItem"?: StoreItem; }, options?: any) {
            return StoreApiFp.updateStoreItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreBundlesApi - fetch parameter creator
 */
export const StoreBundlesApiFetchParamCreator = {
    /** 
     * Create a bundle item
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  "bundleItem"?: BundleItem; }, options?: any): FetchArgs {
        const baseUrl = `/store/bundles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  "bundleTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param id The id of the template
     */
    getBundleTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a bundle item
     * @param id The id of the bundle
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  "id": number; "bundleItem"?: BundleItem; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  "id": string; "bundleTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreBundlesApi - functional programming interface
 */
export const StoreBundlesApiFp = {
    /** 
     * Create a bundle item
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: { "bundleItem"?: BundleItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.createBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: { "bundleTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.createBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.deleteBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.deleteBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param id The id of the template
     */
    getBundleTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a bundle item
     * @param id The id of the bundle
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: { "id": number; "bundleItem"?: BundleItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.updateBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: { "id": string; "bundleTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.updateBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreBundlesApi - object-oriented interface
 */
export class StoreBundlesApi extends BaseAPI {
    /** 
     * Create a bundle item
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  "bundleItem"?: BundleItem; }, options?: any) {
        return StoreBundlesApiFp.createBundleItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  "bundleTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreBundlesApiFp.createBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  "id": number; }, options?: any) {
        return StoreBundlesApiFp.deleteBundleItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return StoreBundlesApiFp.deleteBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  "id": number; }, options?: any) {
        return StoreBundlesApiFp.getBundleItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single bundle template
     * Bundle Templates define a type of bundle and the properties they have.
     * @param id The id of the template
     */
    getBundleTemplate(params: {  "id": string; }, options?: any) {
        return StoreBundlesApiFp.getBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreBundlesApiFp.getBundleTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a bundle item
     * @param id The id of the bundle
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  "id": number; "bundleItem"?: BundleItem; }, options?: any) {
        return StoreBundlesApiFp.updateBundleItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  "id": string; "bundleTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreBundlesApiFp.updateBundleTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreBundlesApi - factory interface
 */
export const StoreBundlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a bundle item
         * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
         * @param bundleItem The bundle item object
         */
        createBundleItem(params: {  "bundleItem"?: BundleItem; }, options?: any) {
            return StoreBundlesApiFp.createBundleItem(params, options)(fetch, basePath);
        },
        /** 
         * Create a bundle template
         * Bundle Templates define a type of bundle and the properties they have.
         * @param bundleTemplateResource The new bundle template
         */
        createBundleTemplate(params: {  "bundleTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreBundlesApiFp.createBundleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a bundle item
         * @param id The id of the bundle
         */
        deleteBundleItem(params: {  "id": number; }, options?: any) {
            return StoreBundlesApiFp.deleteBundleItem(params, options)(fetch, basePath);
        },
        /** 
         * Delete a bundle template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteBundleTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return StoreBundlesApiFp.deleteBundleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single bundle item
         * @param id The id of the bundle
         */
        getBundleItem(params: {  "id": number; }, options?: any) {
            return StoreBundlesApiFp.getBundleItem(params, options)(fetch, basePath);
        },
        /** 
         * Get a single bundle template
         * Bundle Templates define a type of bundle and the properties they have.
         * @param id The id of the template
         */
        getBundleTemplate(params: {  "id": string; }, options?: any) {
            return StoreBundlesApiFp.getBundleTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search bundle templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBundleTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreBundlesApiFp.getBundleTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Update a bundle item
         * @param id The id of the bundle
         * @param bundleItem The bundle item object
         */
        updateBundleItem(params: {  "id": number; "bundleItem"?: BundleItem; }, options?: any) {
            return StoreBundlesApiFp.updateBundleItem(params, options)(fetch, basePath);
        },
        /** 
         * Update a bundle template
         * @param id The id of the template
         * @param bundleTemplateResource The bundle template resource object
         */
        updateBundleTemplate(params: {  "id": string; "bundleTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreBundlesApiFp.updateBundleTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreCouponsApi - fetch parameter creator
 */
export const StoreCouponsApiFetchParamCreator = {
    /** 
     * Create a coupon item
     * SKUs have to be unique in the entire store.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  "couponItem"?: CouponItem; }, options?: any): FetchArgs {
        const baseUrl = `/store/coupons`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  "couponTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param id The id of the template
     */
    getCouponTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a coupon item
     * @param id The id of the coupon
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  "id": number; "couponItem"?: CouponItem; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  "id": string; "couponTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreCouponsApi - functional programming interface
 */
export const StoreCouponsApiFp = {
    /** 
     * Create a coupon item
     * SKUs have to be unique in the entire store.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: { "couponItem"?: CouponItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.createCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: { "couponTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.createCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.deleteCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.deleteCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param id The id of the template
     */
    getCouponTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a coupon item
     * @param id The id of the coupon
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: { "id": number; "couponItem"?: CouponItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.updateCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: { "id": string; "couponTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.updateCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreCouponsApi - object-oriented interface
 */
export class StoreCouponsApi extends BaseAPI {
    /** 
     * Create a coupon item
     * SKUs have to be unique in the entire store.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  "couponItem"?: CouponItem; }, options?: any) {
        return StoreCouponsApiFp.createCouponItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  "couponTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreCouponsApiFp.createCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  "id": number; }, options?: any) {
        return StoreCouponsApiFp.deleteCouponItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return StoreCouponsApiFp.deleteCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  "id": number; }, options?: any) {
        return StoreCouponsApiFp.getCouponItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single coupon template
     * Coupon Templates define a type of coupon and the properties they have.
     * @param id The id of the template
     */
    getCouponTemplate(params: {  "id": string; }, options?: any) {
        return StoreCouponsApiFp.getCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreCouponsApiFp.getCouponTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a coupon item
     * @param id The id of the coupon
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  "id": number; "couponItem"?: CouponItem; }, options?: any) {
        return StoreCouponsApiFp.updateCouponItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  "id": string; "couponTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreCouponsApiFp.updateCouponTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreCouponsApi - factory interface
 */
export const StoreCouponsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a coupon item
         * SKUs have to be unique in the entire store.
         * @param couponItem The coupon item object
         */
        createCouponItem(params: {  "couponItem"?: CouponItem; }, options?: any) {
            return StoreCouponsApiFp.createCouponItem(params, options)(fetch, basePath);
        },
        /** 
         * Create a coupon template
         * Coupon Templates define a type of coupon and the properties they have.
         * @param couponTemplateResource The new coupon template
         */
        createCouponTemplate(params: {  "couponTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreCouponsApiFp.createCouponTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a coupon item
         * @param id The id of the coupon
         */
        deleteCouponItem(params: {  "id": number; }, options?: any) {
            return StoreCouponsApiFp.deleteCouponItem(params, options)(fetch, basePath);
        },
        /** 
         * Delete a coupon template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteCouponTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return StoreCouponsApiFp.deleteCouponTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single coupon item
         * @param id The id of the coupon
         */
        getCouponItem(params: {  "id": number; }, options?: any) {
            return StoreCouponsApiFp.getCouponItem(params, options)(fetch, basePath);
        },
        /** 
         * Get a single coupon template
         * Coupon Templates define a type of coupon and the properties they have.
         * @param id The id of the template
         */
        getCouponTemplate(params: {  "id": string; }, options?: any) {
            return StoreCouponsApiFp.getCouponTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search coupon templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCouponTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreCouponsApiFp.getCouponTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Update a coupon item
         * @param id The id of the coupon
         * @param couponItem The coupon item object
         */
        updateCouponItem(params: {  "id": number; "couponItem"?: CouponItem; }, options?: any) {
            return StoreCouponsApiFp.updateCouponItem(params, options)(fetch, basePath);
        },
        /** 
         * Update a coupon template
         * @param id The id of the template
         * @param couponTemplateResource The coupon template resource object
         */
        updateCouponTemplate(params: {  "id": string; "couponTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreCouponsApiFp.updateCouponTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreSalesApi - fetch parameter creator
 */
export const StoreSalesApiFetchParamCreator = {
    /** 
     * Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  "catalogSale"?: CatalogSale; }, options?: any): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  "id": number; "catalogSale"?: CatalogSale; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreSalesApi - functional programming interface
 */
export const StoreSalesApiFp = {
    /** 
     * Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: { "catalogSale"?: CatalogSale;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.createCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSalesApiFetchParamCreator.deleteCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.getCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.getCatalogSales(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: { "id": number; "catalogSale"?: CatalogSale;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSalesApiFetchParamCreator.updateCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreSalesApi - object-oriented interface
 */
export class StoreSalesApi extends BaseAPI {
    /** 
     * Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  "catalogSale"?: CatalogSale; }, options?: any) {
        return StoreSalesApiFp.createCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  "id": number; }, options?: any) {
        return StoreSalesApiFp.deleteCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  "id": number; }, options?: any) {
        return StoreSalesApiFp.getCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreSalesApiFp.getCatalogSales(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  "id": number; "catalogSale"?: CatalogSale; }, options?: any) {
        return StoreSalesApiFp.updateCatalogSale(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreSalesApi - factory interface
 */
export const StoreSalesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a sale
         * @param catalogSale The catalog sale object
         */
        createCatalogSale(params: {  "catalogSale"?: CatalogSale; }, options?: any) {
            return StoreSalesApiFp.createCatalogSale(params, options)(fetch, basePath);
        },
        /** 
         * Delete a sale
         * @param id The id of the sale
         */
        deleteCatalogSale(params: {  "id": number; }, options?: any) {
            return StoreSalesApiFp.deleteCatalogSale(params, options)(fetch, basePath);
        },
        /** 
         * Get a single sale
         * @param id The id of the sale
         */
        getCatalogSale(params: {  "id": number; }, options?: any) {
            return StoreSalesApiFp.getCatalogSale(params, options)(fetch, basePath);
        },
        /** 
         * List and search sales
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCatalogSales(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreSalesApiFp.getCatalogSales(params, options)(fetch, basePath);
        },
        /** 
         * Update a sale
         * @param id The id of the sale
         * @param catalogSale The catalog sale object
         */
        updateCatalogSale(params: {  "id": number; "catalogSale"?: CatalogSale; }, options?: any) {
            return StoreSalesApiFp.updateCatalogSale(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreShippingApi - fetch parameter creator
 */
export const StoreShippingApiFetchParamCreator = {
    /** 
     * Create a shipping item
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  "shippingItem"?: ShippingItem; }, options?: any): FetchArgs {
        const baseUrl = `/store/shipping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  "shippingTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param id The id of the template
     */
    getShippingTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a shipping item
     * @param id The id of the shipping item
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  "id": number; "shippingItem"?: ShippingItem; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  "id": string; "shippingTemplateResource"?: ItemTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreShippingApi - functional programming interface
 */
export const StoreShippingApiFp = {
    /** 
     * Create a shipping item
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: { "shippingItem"?: ShippingItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = StoreShippingApiFetchParamCreator.createShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: { "shippingTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.createShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.deleteShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.deleteShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param id The id of the template
     */
    getShippingTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a shipping item
     * @param id The id of the shipping item
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: { "id": number; "shippingItem"?: ShippingItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.updateShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: { "id": string; "shippingTemplateResource"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.updateShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreShippingApi - object-oriented interface
 */
export class StoreShippingApi extends BaseAPI {
    /** 
     * Create a shipping item
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  "shippingItem"?: ShippingItem; }, options?: any) {
        return StoreShippingApiFp.createShippingItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  "shippingTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreShippingApiFp.createShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  "id": number; }, options?: any) {
        return StoreShippingApiFp.deleteShippingItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return StoreShippingApiFp.deleteShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  "id": number; }, options?: any) {
        return StoreShippingApiFp.getShippingItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single shipping template
     * Shipping Templates define a type of shipping and the properties they have.
     * @param id The id of the template
     */
    getShippingTemplate(params: {  "id": string; }, options?: any) {
        return StoreShippingApiFp.getShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreShippingApiFp.getShippingTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a shipping item
     * @param id The id of the shipping item
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  "id": number; "shippingItem"?: ShippingItem; }, options?: any) {
        return StoreShippingApiFp.updateShippingItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  "id": string; "shippingTemplateResource"?: ItemTemplateResource; }, options?: any) {
        return StoreShippingApiFp.updateShippingTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreShippingApi - factory interface
 */
export const StoreShippingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a shipping item
         * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
         * @param shippingItem The shipping item object
         */
        createShippingItem(params: {  "shippingItem"?: ShippingItem; }, options?: any) {
            return StoreShippingApiFp.createShippingItem(params, options)(fetch, basePath);
        },
        /** 
         * Create a shipping template
         * Shipping Templates define a type of shipping and the properties they have.
         * @param shippingTemplateResource The new shipping template
         */
        createShippingTemplate(params: {  "shippingTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreShippingApiFp.createShippingTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a shipping item
         * @param id The id of the shipping item
         */
        deleteShippingItem(params: {  "id": number; }, options?: any) {
            return StoreShippingApiFp.deleteShippingItem(params, options)(fetch, basePath);
        },
        /** 
         * Delete a shipping template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteShippingTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return StoreShippingApiFp.deleteShippingTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single shipping item
         * @param id The id of the shipping item
         */
        getShippingItem(params: {  "id": number; }, options?: any) {
            return StoreShippingApiFp.getShippingItem(params, options)(fetch, basePath);
        },
        /** 
         * Get a single shipping template
         * Shipping Templates define a type of shipping and the properties they have.
         * @param id The id of the template
         */
        getShippingTemplate(params: {  "id": string; }, options?: any) {
            return StoreShippingApiFp.getShippingTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search shipping templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getShippingTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreShippingApiFp.getShippingTemplates(params, options)(fetch, basePath);
        },
        /** 
         * Update a shipping item
         * @param id The id of the shipping item
         * @param shippingItem The shipping item object
         */
        updateShippingItem(params: {  "id": number; "shippingItem"?: ShippingItem; }, options?: any) {
            return StoreShippingApiFp.updateShippingItem(params, options)(fetch, basePath);
        },
        /** 
         * Update a shipping template
         * @param id The id of the template
         * @param shippingTemplateResource The shipping template resource object
         */
        updateShippingTemplate(params: {  "id": string; "shippingTemplateResource"?: ItemTemplateResource; }, options?: any) {
            return StoreShippingApiFp.updateShippingTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreShoppingCartsApi - fetch parameter creator
 */
export const StoreShoppingCartsApiFetchParamCreator = {
    /** 
     * Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  "id": string; "skuRequest"?: SkuRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addDiscountToCart");
        }
        const baseUrl = `/carts/{id}/discounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["skuRequest"]) {
            fetchOptions.body = JSON.stringify(params["skuRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add an item to the cart
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a cart
     * You don&#39;t have to have a user to create a cart but the API requires authentication to checkout
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  "owner"?: number; "currencyCode"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "owner": params["owner"],
            "currency_code": params["currencyCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCart");
        }
        const baseUrl = `/carts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  "filterOwnerId"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_owner_id": params["filterOwnerId"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippable");
        }
        const baseUrl = `/carts/{id}/shippable`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the list of available shipping countries per vendor
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @param id The id of the cart
     */
    getShippingCountries(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingCountries");
        }
        const baseUrl = `/carts/{id}/countries`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  "id": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeDiscountFromCart");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling removeDiscountFromCart");
        }
        const baseUrl = `/carts/{id}/discounts/{code}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Sets the currency to use for the cart
     * May be disallowed by site settings.
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  "id": string; "currencyCode"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartCurrency");
        }
        const baseUrl = `/carts/{id}/currency`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currencyCode"]) {
            fetchOptions.body = JSON.stringify(params["currencyCode"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  "id": string; "userId"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartOwner");
        }
        const baseUrl = `/carts/{id}/owner`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Changes the quantity of an item already in the cart
     * A quantity of zero will remove the item from the cart altogether.
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemInCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  "id": string; "cartShippingAddressRequest"?: CartShippingAddressRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingAddress");
        }
        const baseUrl = `/carts/{id}/shipping-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartShippingAddressRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartShippingAddressRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreShoppingCartsApi - functional programming interface
 */
export const StoreShoppingCartsApiFp = {
    /** 
     * Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: { "id": string; "skuRequest"?: SkuRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.addDiscountToCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add an item to the cart
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: { "id": string; "cartItemRequest"?: CartItemRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.addItemToCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a cart
     * You don&#39;t have to have a user to create a cart but the API requires authentication to checkout
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: { "owner"?: number; "currencyCode"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.createCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cart> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: { "filterOwnerId"?: number; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCartSummary> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getCarts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CartShippableResponse> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getShippable(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the list of available shipping countries per vendor
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @param id The id of the cart
     */
    getShippingCountries(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SampleCountriesResponse> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getShippingCountries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: { "id": string; "code": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.removeDiscountFromCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Sets the currency to use for the cart
     * May be disallowed by site settings.
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: { "id": string; "currencyCode"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.setCartCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: { "id": string; "userId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.setCartOwner(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Changes the quantity of an item already in the cart
     * A quantity of zero will remove the item from the cart altogether.
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: { "id": string; "cartItemRequest"?: CartItemRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.updateItemInCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: { "id": string; "cartShippingAddressRequest"?: CartShippingAddressRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.updateShippingAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreShoppingCartsApi - object-oriented interface
 */
export class StoreShoppingCartsApi extends BaseAPI {
    /** 
     * Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  "id": string; "skuRequest"?: SkuRequest; }, options?: any) {
        return StoreShoppingCartsApiFp.addDiscountToCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add an item to the cart
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any) {
        return StoreShoppingCartsApiFp.addItemToCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a cart
     * You don&#39;t have to have a user to create a cart but the API requires authentication to checkout
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  "owner"?: number; "currencyCode"?: string; }, options?: any) {
        return StoreShoppingCartsApiFp.createCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  "id": string; }, options?: any) {
        return StoreShoppingCartsApiFp.getCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  "filterOwnerId"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreShoppingCartsApiFp.getCarts(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  "id": string; }, options?: any) {
        return StoreShoppingCartsApiFp.getShippable(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the list of available shipping countries per vendor
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @param id The id of the cart
     */
    getShippingCountries(params: {  "id": string; }, options?: any) {
        return StoreShoppingCartsApiFp.getShippingCountries(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  "id": string; "code": string; }, options?: any) {
        return StoreShoppingCartsApiFp.removeDiscountFromCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Sets the currency to use for the cart
     * May be disallowed by site settings.
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  "id": string; "currencyCode"?: string; }, options?: any) {
        return StoreShoppingCartsApiFp.setCartCurrency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  "id": string; "userId"?: number; }, options?: any) {
        return StoreShoppingCartsApiFp.setCartOwner(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Changes the quantity of an item already in the cart
     * A quantity of zero will remove the item from the cart altogether.
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any) {
        return StoreShoppingCartsApiFp.updateItemInCart(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  "id": string; "cartShippingAddressRequest"?: CartShippingAddressRequest; }, options?: any) {
        return StoreShoppingCartsApiFp.updateShippingAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreShoppingCartsApi - factory interface
 */
export const StoreShoppingCartsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Adds a discount coupon to the cart
         * @param id The id of the cart
         * @param skuRequest The request of the sku
         */
        addDiscountToCart(params: {  "id": string; "skuRequest"?: SkuRequest; }, options?: any) {
            return StoreShoppingCartsApiFp.addDiscountToCart(params, options)(fetch, basePath);
        },
        /** 
         * Add an item to the cart
         * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        addItemToCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any) {
            return StoreShoppingCartsApiFp.addItemToCart(params, options)(fetch, basePath);
        },
        /** 
         * Create a cart
         * You don&#39;t have to have a user to create a cart but the API requires authentication to checkout
         * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
         * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
         */
        createCart(params: {  "owner"?: number; "currencyCode"?: string; }, options?: any) {
            return StoreShoppingCartsApiFp.createCart(params, options)(fetch, basePath);
        },
        /** 
         * Returns the cart with the given GUID
         * @param id The id of the cart
         */
        getCart(params: {  "id": string; }, options?: any) {
            return StoreShoppingCartsApiFp.getCart(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of carts
         * @param filterOwnerId Filter by the id of the owner
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCarts(params: {  "filterOwnerId"?: number; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreShoppingCartsApiFp.getCarts(params, options)(fetch, basePath);
        },
        /** 
         * Returns whether a cart requires shipping
         * @param id The id of the cart
         */
        getShippable(params: {  "id": string; }, options?: any) {
            return StoreShoppingCartsApiFp.getShippable(params, options)(fetch, basePath);
        },
        /** 
         * Get the list of available shipping countries per vendor
         * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
         * @param id The id of the cart
         */
        getShippingCountries(params: {  "id": string; }, options?: any) {
            return StoreShoppingCartsApiFp.getShippingCountries(params, options)(fetch, basePath);
        },
        /** 
         * Removes a discount coupon from the cart
         * @param id The id of the cart
         * @param code The SKU code of the coupon to remove
         */
        removeDiscountFromCart(params: {  "id": string; "code": string; }, options?: any) {
            return StoreShoppingCartsApiFp.removeDiscountFromCart(params, options)(fetch, basePath);
        },
        /** 
         * Sets the currency to use for the cart
         * May be disallowed by site settings.
         * @param id The id of the cart
         * @param currencyCode The code of the currency
         */
        setCartCurrency(params: {  "id": string; "currencyCode"?: string; }, options?: any) {
            return StoreShoppingCartsApiFp.setCartCurrency(params, options)(fetch, basePath);
        },
        /** 
         * Sets the owner of a cart if none is set already
         * @param id The id of the cart
         * @param userId The id of the user
         */
        setCartOwner(params: {  "id": string; "userId"?: number; }, options?: any) {
            return StoreShoppingCartsApiFp.setCartOwner(params, options)(fetch, basePath);
        },
        /** 
         * Changes the quantity of an item already in the cart
         * A quantity of zero will remove the item from the cart altogether.
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        updateItemInCart(params: {  "id": string; "cartItemRequest"?: CartItemRequest; }, options?: any) {
            return StoreShoppingCartsApiFp.updateItemInCart(params, options)(fetch, basePath);
        },
        /** 
         * Modifies or sets the order shipping address
         * @param id The id of the cart
         * @param cartShippingAddressRequest The cart shipping address request object
         */
        updateShippingAddress(params: {  "id": string; "cartShippingAddressRequest"?: CartShippingAddressRequest; }, options?: any) {
            return StoreShoppingCartsApiFp.updateShippingAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreSubscriptionsApi - fetch parameter creator
 */
export const StoreSubscriptionsApiFetchParamCreator = {
    /** 
     * Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  "subscriptionResource"?: SubscriptionResource; }, options?: any): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a subscription plan
     * Must not be locked or a migration target
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  "id": number; "planId": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscription");
        }
        // verify required parameter "planId" is set
        if (params["planId"] == null) {
            throw new Error("Missing required parameter planId when calling deleteSubscription");
        }
        const baseUrl = `/subscriptions/{id}/plans/{plan_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"plan_id"}}`, `${ params["planId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Processes subscriptions and charge dues
     */
    processSubscriptions(options?: any): FetchArgs {
        const baseUrl = `/subscriptions/process`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates a subscription item and associated plans
     * Will not remove plans left out
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  "id": number; "subscriptionResource"?: SubscriptionResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  "id": string; "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreSubscriptionsApi - functional programming interface
 */
export const StoreSubscriptionsApiFp = {
    /** 
     * Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: { "subscriptionResource"?: SubscriptionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.createSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: { "subscriptionTemplateResource"?: SubscriptionTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.createSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a subscription plan
     * Must not be locked or a migration target
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: { "id": number; "planId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.deleteSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.deleteSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptionTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Processes subscriptions and charge dues
     */
    processSubscriptions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.processSubscriptions(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates a subscription item and associated plans
     * Will not remove plans left out
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: { "id": number; "subscriptionResource"?: SubscriptionResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.updateSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: { "id": string; "subscriptionTemplateResource"?: SubscriptionTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.updateSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreSubscriptionsApi - object-oriented interface
 */
export class StoreSubscriptionsApi extends BaseAPI {
    /** 
     * Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  "subscriptionResource"?: SubscriptionResource; }, options?: any) {
        return StoreSubscriptionsApiFp.createSubscription(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any) {
        return StoreSubscriptionsApiFp.createSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a subscription plan
     * Must not be locked or a migration target
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  "id": number; "planId": string; }, options?: any) {
        return StoreSubscriptionsApiFp.deleteSubscription(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return StoreSubscriptionsApiFp.deleteSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  "id": number; }, options?: any) {
        return StoreSubscriptionsApiFp.getSubscription(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single subscription template
     * Subscription Templates define a type of subscription and the properties they have.
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  "id": string; }, options?: any) {
        return StoreSubscriptionsApiFp.getSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreSubscriptionsApiFp.getSubscriptionTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreSubscriptionsApiFp.getSubscriptions(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Processes subscriptions and charge dues
     */
    processSubscriptions(options?: any) {
        return StoreSubscriptionsApiFp.processSubscriptions(options)(this.fetch, this.basePath);
    }
    /** 
     * Updates a subscription item and associated plans
     * Will not remove plans left out
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  "id": number; "subscriptionResource"?: SubscriptionResource; }, options?: any) {
        return StoreSubscriptionsApiFp.updateSubscription(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  "id": string; "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any) {
        return StoreSubscriptionsApiFp.updateSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreSubscriptionsApi - factory interface
 */
export const StoreSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Creates a subscription item and associated plans
         * @param subscriptionResource The subscription to be created
         */
        createSubscription(params: {  "subscriptionResource"?: SubscriptionResource; }, options?: any) {
            return StoreSubscriptionsApiFp.createSubscription(params, options)(fetch, basePath);
        },
        /** 
         * Create a subscription template
         * Subscription Templates define a type of subscription and the properties they have.
         * @param subscriptionTemplateResource The new subscription template
         */
        createSubscriptionTemplate(params: {  "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any) {
            return StoreSubscriptionsApiFp.createSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a subscription plan
         * Must not be locked or a migration target
         * @param id The id of the subscription
         * @param planId The id of the plan
         */
        deleteSubscription(params: {  "id": number; "planId": string; }, options?: any) {
            return StoreSubscriptionsApiFp.deleteSubscription(params, options)(fetch, basePath);
        },
        /** 
         * Delete a subscription template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteSubscriptionTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return StoreSubscriptionsApiFp.deleteSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve a single subscription item and associated plans
         * @param id The id of the subscription
         */
        getSubscription(params: {  "id": number; }, options?: any) {
            return StoreSubscriptionsApiFp.getSubscription(params, options)(fetch, basePath);
        },
        /** 
         * Get a single subscription template
         * Subscription Templates define a type of subscription and the properties they have.
         * @param id The id of the template
         */
        getSubscriptionTemplate(params: {  "id": string; }, options?: any) {
            return StoreSubscriptionsApiFp.getSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search subscription templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptionTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreSubscriptionsApiFp.getSubscriptionTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List available subscription items and associated plans
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptions(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreSubscriptionsApiFp.getSubscriptions(params, options)(fetch, basePath);
        },
        /** 
         * Processes subscriptions and charge dues
         */
        processSubscriptions(options?: any) {
            return StoreSubscriptionsApiFp.processSubscriptions(options)(fetch, basePath);
        },
        /** 
         * Updates a subscription item and associated plans
         * Will not remove plans left out
         * @param id The id of the subscription
         * @param subscriptionResource The subscription resource object
         */
        updateSubscription(params: {  "id": number; "subscriptionResource"?: SubscriptionResource; }, options?: any) {
            return StoreSubscriptionsApiFp.updateSubscription(params, options)(fetch, basePath);
        },
        /** 
         * Update a subscription template
         * @param id The id of the template
         * @param subscriptionTemplateResource The subscription template resource object
         */
        updateSubscriptionTemplate(params: {  "id": string; "subscriptionTemplateResource"?: SubscriptionTemplateResource; }, options?: any) {
            return StoreSubscriptionsApiFp.updateSubscriptionTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreVendorsApi - fetch parameter creator
 */
export const StoreVendorsApiFetchParamCreator = {
    /** 
     * Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  "vendor"?: VendorResource; }, options?: any): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_name": params["filterName"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  "id": number; "vendor"?: VendorResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreVendorsApi - functional programming interface
 */
export const StoreVendorsApiFp = {
    /** 
     * Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: { "vendor"?: VendorResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.createVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.deleteVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: { "filterName"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceVendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendors(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: { "id": number; "vendor"?: VendorResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.updateVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreVendorsApi - object-oriented interface
 */
export class StoreVendorsApi extends BaseAPI {
    /** 
     * Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  "vendor"?: VendorResource; }, options?: any) {
        return StoreVendorsApiFp.createVendor(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  "id": number; }, options?: any) {
        return StoreVendorsApiFp.deleteVendor(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  "id": number; }, options?: any) {
        return StoreVendorsApiFp.getVendor(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return StoreVendorsApiFp.getVendors(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  "id": number; "vendor"?: VendorResource; }, options?: any) {
        return StoreVendorsApiFp.updateVendor(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreVendorsApi - factory interface
 */
export const StoreVendorsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a vendor
         * @param vendor The vendor
         */
        createVendor(params: {  "vendor"?: VendorResource; }, options?: any) {
            return StoreVendorsApiFp.createVendor(params, options)(fetch, basePath);
        },
        /** 
         * Delete a vendor
         * @param id The id of the vendor
         */
        deleteVendor(params: {  "id": number; }, options?: any) {
            return StoreVendorsApiFp.deleteVendor(params, options)(fetch, basePath);
        },
        /** 
         * Get a single vendor
         * @param id The id of the vendor
         */
        getVendor(params: {  "id": number; }, options?: any) {
            return StoreVendorsApiFp.getVendor(params, options)(fetch, basePath);
        },
        /** 
         * List and search vendors
         * @param filterName Filters vendors by name starting with the text provided in the filter
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVendors(params: {  "filterName"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return StoreVendorsApiFp.getVendors(params, options)(fetch, basePath);
        },
        /** 
         * Update a vendor
         * @param id The id of the vendor
         * @param vendor The vendor
         */
        updateVendor(params: {  "id": number; "vendor"?: VendorResource; }, options?: any) {
            return StoreVendorsApiFp.updateVendor(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxesApi - fetch parameter creator
 */
export const TaxesApiFetchParamCreator = {
    /** 
     * Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  "taxResource"?: CountryTaxResource; }, options?: any): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  "countryCodeIso3": string; "taxResource"?: StateTaxResource; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling createStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  "countryCodeIso3": string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling deleteStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  "countryCodeIso3": string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search taxes
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling getStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search taxes across all countries
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/tax/states`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search taxes within a country
     * Get a list of taxes
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  "countryCodeIso3": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTaxesForCountry");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  "countryCodeIso3": string; "taxResource"?: CountryTaxResource; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  "countryCodeIso3": string; "stateCode": string; "taxResource"?: StateTaxResource; }, options?: any): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling updateStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxesApi - functional programming interface
 */
export const TaxesApiFp = {
    /** 
     * Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: { "taxResource"?: CountryTaxResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.createCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: { "countryCodeIso3": string; "taxResource"?: StateTaxResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.createStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: { "countryCodeIso3": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: { "countryCodeIso3": string; "stateCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: { "countryCodeIso3": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search taxes
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceCountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTaxes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: { "countryCodeIso3": string; "stateCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search taxes across all countries
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search taxes within a country
     * Get a list of taxes
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: { "countryCodeIso3": string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: { "countryCodeIso3": string; "taxResource"?: CountryTaxResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.updateCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: { "countryCodeIso3": string; "stateCode": string; "taxResource"?: StateTaxResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.updateStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxesApi - object-oriented interface
 */
export class TaxesApi extends BaseAPI {
    /** 
     * Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  "taxResource"?: CountryTaxResource; }, options?: any) {
        return TaxesApiFp.createCountryTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  "countryCodeIso3": string; "taxResource"?: StateTaxResource; }, options?: any) {
        return TaxesApiFp.createStateTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  "countryCodeIso3": string; }, options?: any) {
        return TaxesApiFp.deleteCountryTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any) {
        return TaxesApiFp.deleteStateTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  "countryCodeIso3": string; }, options?: any) {
        return TaxesApiFp.getCountryTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search taxes
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return TaxesApiFp.getCountryTaxes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any) {
        return TaxesApiFp.getStateTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search taxes across all countries
     * Get a list of taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return TaxesApiFp.getStateTaxesForCountries(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search taxes within a country
     * Get a list of taxes
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  "countryCodeIso3": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return TaxesApiFp.getStateTaxesForCountry(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  "countryCodeIso3": string; "taxResource"?: CountryTaxResource; }, options?: any) {
        return TaxesApiFp.updateCountryTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  "countryCodeIso3": string; "stateCode": string; "taxResource"?: StateTaxResource; }, options?: any) {
        return TaxesApiFp.updateStateTax(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxesApi - factory interface
 */
export const TaxesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a country tax
         * @param taxResource The tax object
         */
        createCountryTax(params: {  "taxResource"?: CountryTaxResource; }, options?: any) {
            return TaxesApiFp.createCountryTax(params, options)(fetch, basePath);
        },
        /** 
         * Create a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        createStateTax(params: {  "countryCodeIso3": string; "taxResource"?: StateTaxResource; }, options?: any) {
            return TaxesApiFp.createStateTax(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        deleteCountryTax(params: {  "countryCodeIso3": string; }, options?: any) {
            return TaxesApiFp.deleteCountryTax(params, options)(fetch, basePath);
        },
        /** 
         * Delete an existing state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        deleteStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any) {
            return TaxesApiFp.deleteStateTax(params, options)(fetch, basePath);
        },
        /** 
         * Get a single tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryTax(params: {  "countryCodeIso3": string; }, options?: any) {
            return TaxesApiFp.getCountryTax(params, options)(fetch, basePath);
        },
        /** 
         * List and search taxes
         * Get a list of taxes
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCountryTaxes(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return TaxesApiFp.getCountryTaxes(params, options)(fetch, basePath);
        },
        /** 
         * Get a single state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        getStateTax(params: {  "countryCodeIso3": string; "stateCode": string; }, options?: any) {
            return TaxesApiFp.getStateTax(params, options)(fetch, basePath);
        },
        /** 
         * List and search taxes across all countries
         * Get a list of taxes
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountries(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return TaxesApiFp.getStateTaxesForCountries(params, options)(fetch, basePath);
        },
        /** 
         * List and search taxes within a country
         * Get a list of taxes
         * @param countryCodeIso3 The iso3 code of the country
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountry(params: {  "countryCodeIso3": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return TaxesApiFp.getStateTaxesForCountry(params, options)(fetch, basePath);
        },
        /** 
         * Create or update a tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        updateCountryTax(params: {  "countryCodeIso3": string; "taxResource"?: CountryTaxResource; }, options?: any) {
            return TaxesApiFp.updateCountryTax(params, options)(fetch, basePath);
        },
        /** 
         * Create or update a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         * @param taxResource The tax object
         */
        updateStateTax(params: {  "countryCodeIso3": string; "stateCode": string; "taxResource"?: StateTaxResource; }, options?: any) {
            return TaxesApiFp.updateStateTax(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersApi - fetch parameter creator
 */
export const UsersApiFetchParamCreator = {
    /** 
     * Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  "userId": number; "tag": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling addUserTag");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a user template
     * User Templates define a type of user and the properties they have
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  "userTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a user template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single user
     * Additional private info is included as USERS_ADMIN
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserTags");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search users
     * Additional private info is included as USERS_ADMIN
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  "filterDisplayname"?: string; "filterEmail"?: string; "filterFirstname"?: string; "filterFullname"?: string; "filterLastname"?: string; "filterUsername"?: string; "filterTag"?: string; "filterGroup"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter_displayname": params["filterDisplayname"],
            "filter_email": params["filterEmail"],
            "filter_firstname": params["filterFirstname"],
            "filter_fullname": params["filterFullname"],
            "filter_lastname": params["filterLastname"],
            "filter_username": params["filterUsername"],
            "filter_tag": params["filterTag"],
            "filter_group": params["filterGroup"],
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Choose a new password after a reset
     * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  "id": number; "newPasswordRequest"?: NewPasswordRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling passwordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newPasswordRequest"]) {
            fetchOptions.body = JSON.stringify(params["newPasswordRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Register a new user
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @param userResource The user resource object
     */
    registerUser(params: {  "userResource"?: UserResource; }, options?: any): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  "userId": number; "tag": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeUserTag");
        }
        const baseUrl = `/users/{user_id}/tags/{tag}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set a user&#39;s password
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  "id": number; "password"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPassword");
        }
        const baseUrl = `/users/{id}/password`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["password"]) {
            fetchOptions.body = JSON.stringify(params["password"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Reset a user&#39;s password
     * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code; this can be routed to the user as needed and submitted to the &#39;choose a new password&#39; endpoint.
     * @param id The id of the user
     */
    startPasswordReset(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling startPasswordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a user
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  "id": string; "userResource"?: UserResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  "id": string; "userTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = {
    /** 
     * Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: { "userId": number; "tag": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.addUserTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a user template
     * User Templates define a type of user and the properties they have
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: { "userTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.createUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a user template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.deleteUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single user
     * Additional private info is included as USERS_ADMIN
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search users
     * Additional private info is included as USERS_ADMIN
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: { "filterDisplayname"?: string; "filterEmail"?: string; "filterFirstname"?: string; "filterFullname"?: string; "filterLastname"?: string; "filterUsername"?: string; "filterTag"?: string; "filterGroup"?: string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserBaseResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Choose a new password after a reset
     * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: { "id": number; "newPasswordRequest"?: NewPasswordRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.passwordReset(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Register a new user
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @param userResource The user resource object
     */
    registerUser(params: { "userResource"?: UserResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.registerUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: { "userId": number; "tag": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.removeUserTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set a user&#39;s password
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: { "id": number; "password"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.setPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Reset a user&#39;s password
     * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code; this can be routed to the user as needed and submitted to the &#39;choose a new password&#39; endpoint.
     * @param id The id of the user
     */
    startPasswordReset(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.startPasswordReset(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a user
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: { "id": string; "userResource"?: UserResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.updateUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: { "id": string; "userTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.updateUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /** 
     * Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  "userId": number; "tag": string; }, options?: any) {
        return UsersApiFp.addUserTag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a user template
     * User Templates define a type of user and the properties they have
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  "userTemplateResource"?: TemplateResource; }, options?: any) {
        return UsersApiFp.createUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a user template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return UsersApiFp.deleteUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single user
     * Additional private info is included as USERS_ADMIN
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  "id": string; }, options?: any) {
        return UsersApiFp.getUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  "userId": number; }, options?: any) {
        return UsersApiFp.getUserTags(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  "id": string; }, options?: any) {
        return UsersApiFp.getUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersApiFp.getUserTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search users
     * Additional private info is included as USERS_ADMIN
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  "filterDisplayname"?: string; "filterEmail"?: string; "filterFirstname"?: string; "filterFullname"?: string; "filterLastname"?: string; "filterUsername"?: string; "filterTag"?: string; "filterGroup"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersApiFp.getUsers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Choose a new password after a reset
     * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  "id": number; "newPasswordRequest"?: NewPasswordRequest; }, options?: any) {
        return UsersApiFp.passwordReset(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Register a new user
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @param userResource The user resource object
     */
    registerUser(params: {  "userResource"?: UserResource; }, options?: any) {
        return UsersApiFp.registerUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  "userId": number; "tag": string; }, options?: any) {
        return UsersApiFp.removeUserTag(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set a user&#39;s password
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  "id": number; "password"?: string; }, options?: any) {
        return UsersApiFp.setPassword(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Reset a user&#39;s password
     * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code; this can be routed to the user as needed and submitted to the &#39;choose a new password&#39; endpoint.
     * @param id The id of the user
     */
    startPasswordReset(params: {  "id": number; }, options?: any) {
        return UsersApiFp.startPasswordReset(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a user
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  "id": string; "userResource"?: UserResource; }, options?: any) {
        return UsersApiFp.updateUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  "id": string; "userTemplateResource"?: TemplateResource; }, options?: any) {
        return UsersApiFp.updateUserTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a tag to a user
         * @param userId The id of the user
         * @param tag tag
         */
        addUserTag(params: {  "userId": number; "tag": string; }, options?: any) {
            return UsersApiFp.addUserTag(params, options)(fetch, basePath);
        },
        /** 
         * Create a user template
         * User Templates define a type of user and the properties they have
         * @param userTemplateResource The user template resource object
         */
        createUserTemplate(params: {  "userTemplateResource"?: TemplateResource; }, options?: any) {
            return UsersApiFp.createUserTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete a user template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteUserTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return UsersApiFp.deleteUserTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single user
         * Additional private info is included as USERS_ADMIN
         * @param id The id of the user or &#39;me&#39;
         */
        getUser(params: {  "id": string; }, options?: any) {
            return UsersApiFp.getUser(params, options)(fetch, basePath);
        },
        /** 
         * List tags for a user
         * @param userId The id of the user
         */
        getUserTags(params: {  "userId": number; }, options?: any) {
            return UsersApiFp.getUserTags(params, options)(fetch, basePath);
        },
        /** 
         * Get a single user template
         * @param id The id of the template
         */
        getUserTemplate(params: {  "id": string; }, options?: any) {
            return UsersApiFp.getUserTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search user templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersApiFp.getUserTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List and search users
         * Additional private info is included as USERS_ADMIN
         * @param filterDisplayname Filter for users whose display name starts with provided string.
         * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
         * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
         * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
         * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
         * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
         * @param filterTag Filter for users who have a given tag
         * @param filterGroup Filter for users in a given group, by unique name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUsers(params: {  "filterDisplayname"?: string; "filterEmail"?: string; "filterFirstname"?: string; "filterFullname"?: string; "filterLastname"?: string; "filterUsername"?: string; "filterTag"?: string; "filterGroup"?: string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersApiFp.getUsers(params, options)(fetch, basePath);
        },
        /** 
         * Choose a new password after a reset
         * Finish resetting a user&#39;s password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
         * @param id The id of the user
         * @param newPasswordRequest The new password request object
         */
        passwordReset(params: {  "id": number; "newPasswordRequest"?: NewPasswordRequest; }, options?: any) {
            return UsersApiFp.passwordReset(params, options)(fetch, basePath);
        },
        /** 
         * Register a new user
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security
         * @param userResource The user resource object
         */
        registerUser(params: {  "userResource"?: UserResource; }, options?: any) {
            return UsersApiFp.registerUser(params, options)(fetch, basePath);
        },
        /** 
         * Remove a tag from a user
         * @param userId The id of the user
         * @param tag The tag to remove
         */
        removeUserTag(params: {  "userId": number; "tag": string; }, options?: any) {
            return UsersApiFp.removeUserTag(params, options)(fetch, basePath);
        },
        /** 
         * Set a user&#39;s password
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
         * @param id The id of the user
         * @param password The new plain text password
         */
        setPassword(params: {  "id": number; "password"?: string; }, options?: any) {
            return UsersApiFp.setPassword(params, options)(fetch, basePath);
        },
        /** 
         * Reset a user&#39;s password
         * A reset code will be generated and a &#39;forgot_password&#39; BRE event will be fired with that code; this can be routed to the user as needed and submitted to the &#39;choose a new password&#39; endpoint.
         * @param id The id of the user
         */
        startPasswordReset(params: {  "id": number; }, options?: any) {
            return UsersApiFp.startPasswordReset(params, options)(fetch, basePath);
        },
        /** 
         * Update a user
         * Password will not be edited on this endpoint, use password specific endpoints.
         * @param id The id of the user or &#39;me&#39;
         * @param userResource The user resource object
         */
        updateUser(params: {  "id": string; "userResource"?: UserResource; }, options?: any) {
            return UsersApiFp.updateUser(params, options)(fetch, basePath);
        },
        /** 
         * Update a user template
         * @param id The id of the template
         * @param userTemplateResource The user template resource object
         */
        updateUserTemplate(params: {  "id": string; "userTemplateResource"?: TemplateResource; }, options?: any) {
            return UsersApiFp.updateUserTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersAddressesApi - fetch parameter creator
 */
export const UsersAddressesApiFetchParamCreator = {
    /** 
     * Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  "userId": string; "savedAddressResource"?: SavedAddressResource; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createAddress");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  "userId": string; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deleteAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  "userId": string; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddresses");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  "userId": string; "id": number; "savedAddressResource"?: SavedAddressResource; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersAddressesApi - functional programming interface
 */
export const UsersAddressesApiFp = {
    /** 
     * Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: { "userId": string; "savedAddressResource"?: SavedAddressResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.createAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: { "userId": string; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.deleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: { "userId": string; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.getAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: { "userId": string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.getAddresses(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: { "userId": string; "id": number; "savedAddressResource"?: SavedAddressResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.updateAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersAddressesApi - object-oriented interface
 */
export class UsersAddressesApi extends BaseAPI {
    /** 
     * Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  "userId": string; "savedAddressResource"?: SavedAddressResource; }, options?: any) {
        return UsersAddressesApiFp.createAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  "userId": string; "id": number; }, options?: any) {
        return UsersAddressesApiFp.deleteAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  "userId": string; "id": number; }, options?: any) {
        return UsersAddressesApiFp.getAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersAddressesApiFp.getAddresses(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  "userId": string; "id": number; "savedAddressResource"?: SavedAddressResource; }, options?: any) {
        return UsersAddressesApiFp.updateAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersAddressesApi - factory interface
 */
export const UsersAddressesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a new address
         * @param userId The id of the user
         * @param savedAddressResource The new address
         */
        createAddress(params: {  "userId": string; "savedAddressResource"?: SavedAddressResource; }, options?: any) {
            return UsersAddressesApiFp.createAddress(params, options)(fetch, basePath);
        },
        /** 
         * Delete an address
         * @param userId The id of the user
         * @param id The id of the address
         */
        deleteAddress(params: {  "userId": string; "id": number; }, options?: any) {
            return UsersAddressesApiFp.deleteAddress(params, options)(fetch, basePath);
        },
        /** 
         * Get a single address
         * @param userId The id of the user
         * @param id The id of the address
         */
        getAddress(params: {  "userId": string; "id": number; }, options?: any) {
            return UsersAddressesApiFp.getAddress(params, options)(fetch, basePath);
        },
        /** 
         * List and search addresses
         * @param userId The id of the user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAddresses(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersAddressesApiFp.getAddresses(params, options)(fetch, basePath);
        },
        /** 
         * Update an address
         * @param userId The id of the user
         * @param id The id of the address
         * @param savedAddressResource The saved address resource object
         */
        updateAddress(params: {  "userId": string; "id": number; "savedAddressResource"?: SavedAddressResource; }, options?: any) {
            return UsersAddressesApiFp.updateAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersFriendshipsApi - fetch parameter creator
 */
export const UsersFriendshipsApiFetchParamCreator = {
    /** 
     * Add a friend
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  "userId": string; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFriends(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getFriends");
        }
        const baseUrl = `/users/{user_id}/friends`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns the invite token
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInviteToken");
        }
        const baseUrl = `/users/{user_id}/invite-token`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get pending invites
     * Invites that the specified user received
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvites(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInvites");
        }
        const baseUrl = `/users/{user_id}/invites`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Redeem friendship token
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  "userId": string; "token"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling redeemFriendshipToken");
        }
        const baseUrl = `/users/{user_id}/friends/tokens`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["token"]) {
            fetchOptions.body = JSON.stringify(params["token"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  "userId": string; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeOrDeclineFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeOrDeclineFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersFriendshipsApi - functional programming interface
 */
export const UsersFriendshipsApiFp = {
    /** 
     * Add a friend
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: { "userId": string; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.addFriend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFriends(params: { "userId": string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getFriends(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns the invite token
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getInviteToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get pending invites
     * Invites that the specified user received
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvites(params: { "userId": string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getInvites(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Redeem friendship token
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: { "userId": string; "token"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.redeemFriendshipToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: { "userId": string; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.removeOrDeclineFriend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersFriendshipsApi - object-oriented interface
 */
export class UsersFriendshipsApi extends BaseAPI {
    /** 
     * Add a friend
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  "userId": string; "id": number; }, options?: any) {
        return UsersFriendshipsApiFp.addFriend(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFriends(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersFriendshipsApiFp.getFriends(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns the invite token
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  "userId": string; }, options?: any) {
        return UsersFriendshipsApiFp.getInviteToken(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get pending invites
     * Invites that the specified user received
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvites(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersFriendshipsApiFp.getInvites(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Redeem friendship token
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  "userId": string; "token"?: string; }, options?: any) {
        return UsersFriendshipsApiFp.redeemFriendshipToken(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  "userId": string; "id": number; }, options?: any) {
        return UsersFriendshipsApiFp.removeOrDeclineFriend(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersFriendshipsApi - factory interface
 */
export const UsersFriendshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a friend
         * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        addFriend(params: {  "userId": string; "id": number; }, options?: any) {
            return UsersFriendshipsApiFp.addFriend(params, options)(fetch, basePath);
        },
        /** 
         * Get friends list
         * @param userId The id of the user or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getFriends(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersFriendshipsApiFp.getFriends(params, options)(fetch, basePath);
        },
        /** 
         * Returns the invite token
         * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
         * @param userId The id of the user or &#39;me&#39; if logged in
         */
        getInviteToken(params: {  "userId": string; }, options?: any) {
            return UsersFriendshipsApiFp.getInviteToken(params, options)(fetch, basePath);
        },
        /** 
         * Get pending invites
         * Invites that the specified user received
         * @param userId The id of the user or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getInvites(params: {  "userId": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersFriendshipsApiFp.getInvites(params, options)(fetch, basePath);
        },
        /** 
         * Redeem friendship token
         * Immediately connects the requested user with the user mapped by the provided invite token
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param token The invite token
         */
        redeemFriendshipToken(params: {  "userId": string; "token"?: string; }, options?: any) {
            return UsersFriendshipsApiFp.redeemFriendshipToken(params, options)(fetch, basePath);
        },
        /** 
         * Remove or decline a friend
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        removeOrDeclineFriend(params: {  "userId": string; "id": number; }, options?: any) {
            return UsersFriendshipsApiFp.removeOrDeclineFriend(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersGroupsApi - fetch parameter creator
 */
export const UsersGroupsApiFetchParamCreator = {
    /** 
     * Adds a new member to the group
     * @param uniqueName The group unique name
     * @param username The username of a user to add to the group
     */
    addMemberToGroup(params: {  "uniqueName": string; "username": GroupMemberResource; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling addMemberToGroup");
        }
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling addMemberToGroup");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["username"]) {
            fetchOptions.body = JSON.stringify(params["username"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  "groupResource"?: GroupResource; }, options?: any): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a group template
     * Group Templates define a type of group and the properties they have
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  "groupTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  "uniqueName": string; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling deleteGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a group template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Loads a specific group&#39;s details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  "uniqueName": string; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  "uniqueName": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMembers");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupsForUser");
        }
        const baseUrl = `/users/{user_id}/groups`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling removeGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  "uniqueName": string; "groupResource"?: GroupResource; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Change a user&#39;s status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  "uniqueName": string; "userId": number; "status": string; }, options?: any): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroupMemberStatus");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateGroupMemberStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling updateGroupMemberStatus");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/status`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  "id": string; "groupTemplateResource"?: TemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search groups
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersGroupsApi - functional programming interface
 */
export const UsersGroupsApiFp = {
    /** 
     * Adds a new member to the group
     * @param uniqueName The group unique name
     * @param username The username of a user to add to the group
     */
    addMemberToGroup(params: { "uniqueName": string; "username": GroupMemberResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.addMemberToGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a group
     * @param groupResource The new group
     */
    createGroup(params: { "groupResource"?: GroupResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.createGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a group template
     * Group Templates define a type of group and the properties they have
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: { "groupTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.createGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: { "uniqueName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.deleteGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a group template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.deleteGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Loads a specific group&#39;s details
     * @param uniqueName The group unique name
     */
    getGroup(params: { "uniqueName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: { "uniqueName": string; "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupMember(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: { "uniqueName": string; "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceGroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupsForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: { "uniqueName": string; "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.removeGroupMember(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: { "uniqueName": string; "groupResource"?: GroupResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Change a user&#39;s status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: { "uniqueName": string; "userId": number; "status": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroupMemberStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: { "id": string; "groupTemplateResource"?: TemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search groups
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceGroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroups(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersGroupsApi - object-oriented interface
 */
export class UsersGroupsApi extends BaseAPI {
    /** 
     * Adds a new member to the group
     * @param uniqueName The group unique name
     * @param username The username of a user to add to the group
     */
    addMemberToGroup(params: {  "uniqueName": string; "username": GroupMemberResource; }, options?: any) {
        return UsersGroupsApiFp.addMemberToGroup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  "groupResource"?: GroupResource; }, options?: any) {
        return UsersGroupsApiFp.createGroup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a group template
     * Group Templates define a type of group and the properties they have
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  "groupTemplateResource"?: TemplateResource; }, options?: any) {
        return UsersGroupsApiFp.createGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  "uniqueName": string; }, options?: any) {
        return UsersGroupsApiFp.deleteGroup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a group template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return UsersGroupsApiFp.deleteGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Loads a specific group&#39;s details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  "uniqueName": string; }, options?: any) {
        return UsersGroupsApiFp.getGroup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any) {
        return UsersGroupsApiFp.getGroupMember(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  "uniqueName": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersGroupsApiFp.getGroupMembers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  "id": string; }, options?: any) {
        return UsersGroupsApiFp.getGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersGroupsApiFp.getGroupTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: {  "userId": number; }, options?: any) {
        return UsersGroupsApiFp.getGroupsForUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any) {
        return UsersGroupsApiFp.removeGroupMember(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  "uniqueName": string; "groupResource"?: GroupResource; }, options?: any) {
        return UsersGroupsApiFp.updateGroup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Change a user&#39;s status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  "uniqueName": string; "userId": number; "status": string; }, options?: any) {
        return UsersGroupsApiFp.updateGroupMemberStatus(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  "id": string; "groupTemplateResource"?: TemplateResource; }, options?: any) {
        return UsersGroupsApiFp.updateGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search groups
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersGroupsApiFp.updateGroups(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersGroupsApi - factory interface
 */
export const UsersGroupsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Adds a new member to the group
         * @param uniqueName The group unique name
         * @param username The username of a user to add to the group
         */
        addMemberToGroup(params: {  "uniqueName": string; "username": GroupMemberResource; }, options?: any) {
            return UsersGroupsApiFp.addMemberToGroup(params, options)(fetch, basePath);
        },
        /** 
         * Create a group
         * @param groupResource The new group
         */
        createGroup(params: {  "groupResource"?: GroupResource; }, options?: any) {
            return UsersGroupsApiFp.createGroup(params, options)(fetch, basePath);
        },
        /** 
         * Create a group template
         * Group Templates define a type of group and the properties they have
         * @param groupTemplateResource The group template resource object
         */
        createGroupTemplate(params: {  "groupTemplateResource"?: TemplateResource; }, options?: any) {
            return UsersGroupsApiFp.createGroupTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Removes a group from the system IF no resources are attached to it
         * @param uniqueName The group unique name
         */
        deleteGroup(params: {  "uniqueName": string; }, options?: any) {
            return UsersGroupsApiFp.deleteGroup(params, options)(fetch, basePath);
        },
        /** 
         * Delete a group template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteGroupTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return UsersGroupsApiFp.deleteGroupTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Loads a specific group&#39;s details
         * @param uniqueName The group unique name
         */
        getGroup(params: {  "uniqueName": string; }, options?: any) {
            return UsersGroupsApiFp.getGroup(params, options)(fetch, basePath);
        },
        /** 
         * Get a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user
         */
        getGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any) {
            return UsersGroupsApiFp.getGroupMember(params, options)(fetch, basePath);
        },
        /** 
         * Lists members of the group
         * @param uniqueName The group unique name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupMembers(params: {  "uniqueName": string; "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersGroupsApiFp.getGroupMembers(params, options)(fetch, basePath);
        },
        /** 
         * Get a single group template
         * @param id The id of the template
         */
        getGroupTemplate(params: {  "id": string; }, options?: any) {
            return UsersGroupsApiFp.getGroupTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search group templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersGroupsApiFp.getGroupTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List groups a user is in
         * @param userId The id of the user
         */
        getGroupsForUser(params: {  "userId": number; }, options?: any) {
            return UsersGroupsApiFp.getGroupsForUser(params, options)(fetch, basePath);
        },
        /** 
         * Removes a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user to remove
         */
        removeGroupMember(params: {  "uniqueName": string; "userId": number; }, options?: any) {
            return UsersGroupsApiFp.removeGroupMember(params, options)(fetch, basePath);
        },
        /** 
         * Update a group
         * @param uniqueName The group unique name
         * @param groupResource The updated group
         */
        updateGroup(params: {  "uniqueName": string; "groupResource"?: GroupResource; }, options?: any) {
            return UsersGroupsApiFp.updateGroup(params, options)(fetch, basePath);
        },
        /** 
         * Change a user&#39;s status
         * @param uniqueName The group unique name
         * @param userId The user id of the member to modify
         * @param status The new status for the user
         */
        updateGroupMemberStatus(params: {  "uniqueName": string; "userId": number; "status": string; }, options?: any) {
            return UsersGroupsApiFp.updateGroupMemberStatus(params, options)(fetch, basePath);
        },
        /** 
         * Update a group template
         * @param id The id of the template
         * @param groupTemplateResource The group template resource object
         */
        updateGroupTemplate(params: {  "id": string; "groupTemplateResource"?: TemplateResource; }, options?: any) {
            return UsersGroupsApiFp.updateGroupTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search groups
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        updateGroups(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersGroupsApiFp.updateGroups(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersInventoryApi - fetch parameter creator
 */
export const UsersInventoryApiFetchParamCreator = {
    /** 
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  "id": number; "userInventoryAddRequest"?: UserInventoryAddRequest; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToUserInventory");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userInventoryAddRequest"]) {
            fetchOptions.body = JSON.stringify(params["userInventoryAddRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling checkUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling checkUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/check`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sku": params["sku"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an entitlement item
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  "entitlementItem"?: EntitlementItem; }, options?: any): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  "template"?: ItemTemplateResource; }, options?: any): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  "entitlementId": number; }, options?: any): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling deleteEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "cascade": params["cascade"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  "entitlementId": number; }, options?: any): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling getEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
            "order": params["order"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds
     * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds
     */
    getUserInventories(params: {  "id": number; "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterMinDate"?: number; "filterMaxDate"?: number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventories");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "inactive": params["inactive"],
            "size": params["size"],
            "page": params["page"],
            "filter_item_name": params["filterItemName"],
            "filter_min_date": params["filterMinDate"],
            "filter_max_date": params["filterMaxDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  "userId": number; "id": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventory");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventory");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  "userId": string; "id": number; "size"?: number; "page"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventoryLog");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventoryLog");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/log`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "size": params["size"],
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterUsername"?: string; "filterGroup"?: string; "filterDate"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/inventories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "inactive": params["inactive"],
            "size": params["size"],
            "page": params["page"],
            "filter_item_name": params["filterItemName"],
            "filter_username": params["filterUsername"],
            "filter_group": params["filterGroup"],
            "filter_date": params["filterDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  "userId": number; "grantRequest": EntitlementGrantRequest; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling grantUserEntitlement");
        }
        // verify required parameter "grantRequest" is set
        if (params["grantRequest"] == null) {
            throw new Error("Missing required parameter grantRequest when calling grantUserEntitlement");
        }
        const baseUrl = `/users/{user_id}/entitlements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantRequest"]) {
            fetchOptions.body = JSON.stringify(params["grantRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  "entitlementId": number; "entitlementItem"?: EntitlementItem; }, options?: any): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling updateEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  "id": string; "template"?: ItemTemplateResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  "userId": number; "id": number; "data"?: any; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryBehaviorData");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryBehaviorData");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/behavior-data`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  "userId": number; "id": number; "timestamp"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryExpires");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryExpires");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/expires`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["timestamp"]) {
            fetchOptions.body = JSON.stringify(params["timestamp"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  "userId": number; "id": number; "inventoryStatus"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryStatus");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryStatus");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["inventoryStatus"]) {
            fetchOptions.body = JSON.stringify(params["inventoryStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; "info"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling useUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling useUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/use`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sku": params["sku"],
            "info": params["info"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersInventoryApi - functional programming interface
 */
export const UsersInventoryApiFp = {
    /** 
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: { "id": number; "userInventoryAddRequest"?: UserInventoryAddRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.addItemToUserInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: { "userId": string; "itemId": number; "sku"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.checkUserEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an entitlement item
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: { "entitlementItem"?: EntitlementItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.createEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: { "template"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.createEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: { "entitlementId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.deleteEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: { "id": string; "cascade"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.deleteEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: { "entitlementId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceEntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementItems(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: { "size"?: number; "page"?: number; "order"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds
     * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds
     */
    getUserInventories(params: { "id": number; "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterMinDate"?: number; "filterMaxDate"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: { "userId": number; "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: { "userId": string; "id": number; "size"?: number; "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserItemLogResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventoryLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: { "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterUsername"?: string; "filterGroup"?: string; "filterDate"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUsersInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: { "userId": number; "grantRequest": EntitlementGrantRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.grantUserEntitlement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: { "entitlementId": number; "entitlementItem"?: EntitlementItem;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: { "id": string; "template"?: ItemTemplateResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: { "userId": number; "id": number; "data"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryBehaviorData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: { "userId": number; "id": number; "timestamp"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryExpires(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: { "userId": number; "id": number; "inventoryStatus"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: { "userId": string; "itemId": number; "sku"?: string; "info"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.useUserEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersInventoryApi - object-oriented interface
 */
export class UsersInventoryApi extends BaseAPI {
    /** 
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  "id": number; "userInventoryAddRequest"?: UserInventoryAddRequest; }, options?: any) {
        return UsersInventoryApiFp.addItemToUserInventory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; }, options?: any) {
        return UsersInventoryApiFp.checkUserEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an entitlement item
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  "entitlementItem"?: EntitlementItem; }, options?: any) {
        return UsersInventoryApiFp.createEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  "template"?: ItemTemplateResource; }, options?: any) {
        return UsersInventoryApiFp.createEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  "entitlementId": number; }, options?: any) {
        return UsersInventoryApiFp.deleteEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
        return UsersInventoryApiFp.deleteEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  "entitlementId": number; }, options?: any) {
        return UsersInventoryApiFp.getEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersInventoryApiFp.getEntitlementItems(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  "id": string; }, options?: any) {
        return UsersInventoryApiFp.getEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
        return UsersInventoryApiFp.getEntitlementTemplates(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds
     * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds
     */
    getUserInventories(params: {  "id": number; "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterMinDate"?: number; "filterMaxDate"?: number; }, options?: any) {
        return UsersInventoryApiFp.getUserInventories(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  "userId": number; "id": number; }, options?: any) {
        return UsersInventoryApiFp.getUserInventory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  "userId": string; "id": number; "size"?: number; "page"?: number; }, options?: any) {
        return UsersInventoryApiFp.getUserInventoryLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterUsername"?: string; "filterGroup"?: string; "filterDate"?: string; }, options?: any) {
        return UsersInventoryApiFp.getUsersInventory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  "userId": number; "grantRequest": EntitlementGrantRequest; }, options?: any) {
        return UsersInventoryApiFp.grantUserEntitlement(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  "entitlementId": number; "entitlementItem"?: EntitlementItem; }, options?: any) {
        return UsersInventoryApiFp.updateEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  "id": string; "template"?: ItemTemplateResource; }, options?: any) {
        return UsersInventoryApiFp.updateEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  "userId": number; "id": number; "data"?: any; }, options?: any) {
        return UsersInventoryApiFp.updateUserInventoryBehaviorData(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  "userId": number; "id": number; "timestamp"?: number; }, options?: any) {
        return UsersInventoryApiFp.updateUserInventoryExpires(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  "userId": number; "id": number; "inventoryStatus"?: string; }, options?: any) {
        return UsersInventoryApiFp.updateUserInventoryStatus(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; "info"?: string; }, options?: any) {
        return UsersInventoryApiFp.useUserEntitlementItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersInventoryApi - factory interface
 */
export const UsersInventoryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Adds an item to the user inventory
         * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
         * @param id The id of the user
         * @param userInventoryAddRequest The user inventory add request object
         */
        addItemToUserInventory(params: {  "id": number; "userInventoryAddRequest"?: UserInventoryAddRequest; }, options?: any) {
            return UsersInventoryApiFp.addItemToUserInventory(params, options)(fetch, basePath);
        },
        /** 
         * Check for access to an item without consuming
         * Useful for pre-check and accounts for all various buisness rules
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         */
        checkUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; }, options?: any) {
            return UsersInventoryApiFp.checkUserEntitlementItem(params, options)(fetch, basePath);
        },
        /** 
         * Create an entitlement item
         * @param entitlementItem The entitlement item object
         */
        createEntitlementItem(params: {  "entitlementItem"?: EntitlementItem; }, options?: any) {
            return UsersInventoryApiFp.createEntitlementItem(params, options)(fetch, basePath);
        },
        /** 
         * Create an entitlement template
         * Entitlement templates define a type of entitlement and the properties they have
         * @param template The entitlement template to be created
         */
        createEntitlementTemplate(params: {  "template"?: ItemTemplateResource; }, options?: any) {
            return UsersInventoryApiFp.createEntitlementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Delete an entitlement item
         * @param entitlementId The id of the entitlement
         */
        deleteEntitlementItem(params: {  "entitlementId": number; }, options?: any) {
            return UsersInventoryApiFp.deleteEntitlementItem(params, options)(fetch, basePath);
        },
        /** 
         * Delete an entitlement template
         * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteEntitlementTemplate(params: {  "id": string; "cascade"?: string; }, options?: any) {
            return UsersInventoryApiFp.deleteEntitlementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Get a single entitlement item
         * @param entitlementId The id of the entitlement
         */
        getEntitlementItem(params: {  "entitlementId": number; }, options?: any) {
            return UsersInventoryApiFp.getEntitlementItem(params, options)(fetch, basePath);
        },
        /** 
         * List and search entitlement items
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementItems(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersInventoryApiFp.getEntitlementItems(params, options)(fetch, basePath);
        },
        /** 
         * Get a single entitlement template
         * @param id The id of the template
         */
        getEntitlementTemplate(params: {  "id": string; }, options?: any) {
            return UsersInventoryApiFp.getEntitlementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * List and search entitlement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementTemplates(params: {  "size"?: number; "page"?: number; "order"?: string; }, options?: any) {
            return UsersInventoryApiFp.getEntitlementTemplates(params, options)(fetch, basePath);
        },
        /** 
         * List the user inventory entries for a given user
         * @param id The id of the user
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterMinDate Filter for inventory added after the specified date, unix timestamp in seconds
         * @param filterMaxDate Filter for inventory added before the specified date, unix timestamp in seconds
         */
        getUserInventories(params: {  "id": number; "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterMinDate"?: number; "filterMaxDate"?: number; }, options?: any) {
            return UsersInventoryApiFp.getUserInventories(params, options)(fetch, basePath);
        },
        /** 
         * Get an inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         */
        getUserInventory(params: {  "userId": number; "id": number; }, options?: any) {
            return UsersInventoryApiFp.getUserInventory(params, options)(fetch, basePath);
        },
        /** 
         * List the log entries for this inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserInventoryLog(params: {  "userId": string; "id": number; "size"?: number; "page"?: number; }, options?: any) {
            return UsersInventoryApiFp.getUserInventoryLog(params, options)(fetch, basePath);
        },
        /** 
         * List the user inventory entries for all users
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterUsername Filter by entries owned by the user with the specified username
         * @param filterGroup Filter by entries owned by the users in a given group, by unique name
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         */
        getUsersInventory(params: {  "inactive"?: boolean; "size"?: number; "page"?: number; "filterItemName"?: string; "filterUsername"?: string; "filterGroup"?: string; "filterDate"?: string; }, options?: any) {
            return UsersInventoryApiFp.getUsersInventory(params, options)(fetch, basePath);
        },
        /** 
         * Grant an entitlement
         * @param userId The id of the user to grant the entitlement to
         * @param grantRequest grantRequest
         */
        grantUserEntitlement(params: {  "userId": number; "grantRequest": EntitlementGrantRequest; }, options?: any) {
            return UsersInventoryApiFp.grantUserEntitlement(params, options)(fetch, basePath);
        },
        /** 
         * Update an entitlement item
         * @param entitlementId The id of the entitlement
         * @param entitlementItem The entitlement item object
         */
        updateEntitlementItem(params: {  "entitlementId": number; "entitlementItem"?: EntitlementItem; }, options?: any) {
            return UsersInventoryApiFp.updateEntitlementItem(params, options)(fetch, basePath);
        },
        /** 
         * Update an entitlement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateEntitlementTemplate(params: {  "id": string; "template"?: ItemTemplateResource; }, options?: any) {
            return UsersInventoryApiFp.updateEntitlementTemplate(params, options)(fetch, basePath);
        },
        /** 
         * Set the behavior data for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param data The data map
         */
        updateUserInventoryBehaviorData(params: {  "userId": number; "id": number; "data"?: any; }, options?: any) {
            return UsersInventoryApiFp.updateUserInventoryBehaviorData(params, options)(fetch, basePath);
        },
        /** 
         * Set the expiration date
         * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
         * @param userId user_id
         * @param id The id of the user inventory
         * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
         */
        updateUserInventoryExpires(params: {  "userId": number; "id": number; "timestamp"?: number; }, options?: any) {
            return UsersInventoryApiFp.updateUserInventoryExpires(params, options)(fetch, basePath);
        },
        /** 
         * Set the status for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param inventoryStatus The inventory status object
         */
        updateUserInventoryStatus(params: {  "userId": number; "id": number; "inventoryStatus"?: string; }, options?: any) {
            return UsersInventoryApiFp.updateUserInventoryStatus(params, options)(fetch, basePath);
        },
        /** 
         * Use an item
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         * @param info Any additional info to add to the log about this use
         */
        useUserEntitlementItem(params: {  "userId": string; "itemId": number; "sku"?: string; "info"?: string; }, options?: any) {
            return UsersInventoryApiFp.useUserEntitlementItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersRelationshipsApi - fetch parameter creator
 */
export const UsersRelationshipsApiFetchParamCreator = {
    /** 
     * Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  "relationship"?: UserRelationshipResource; }, options?: any): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  "id": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of user relationships
     */
    getUserRelationships(options?: any): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  "id": number; "relationship"?: UserRelationshipResource; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersRelationshipsApi - functional programming interface
 */
export const UsersRelationshipsApiFp = {
    /** 
     * Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: { "relationship"?: UserRelationshipResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.createUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.deleteUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: { "id": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.getUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of user relationships
     */
    getUserRelationships(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceUserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.getUserRelationships(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: { "id": number; "relationship"?: UserRelationshipResource;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.updateUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersRelationshipsApi - object-oriented interface
 */
export class UsersRelationshipsApi extends BaseAPI {
    /** 
     * Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  "relationship"?: UserRelationshipResource; }, options?: any) {
        return UsersRelationshipsApiFp.createUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  "id": number; }, options?: any) {
        return UsersRelationshipsApiFp.deleteUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  "id": number; }, options?: any) {
        return UsersRelationshipsApiFp.getUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of user relationships
     */
    getUserRelationships(options?: any) {
        return UsersRelationshipsApiFp.getUserRelationships(options)(this.fetch, this.basePath);
    }
    /** 
     * Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  "id": number; "relationship"?: UserRelationshipResource; }, options?: any) {
        return UsersRelationshipsApiFp.updateUserRelationship(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersRelationshipsApi - factory interface
 */
export const UsersRelationshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create a user relationship
         * @param relationship The new relationship
         */
        createUserRelationship(params: {  "relationship"?: UserRelationshipResource; }, options?: any) {
            return UsersRelationshipsApiFp.createUserRelationship(params, options)(fetch, basePath);
        },
        /** 
         * Delete a user relationship
         * @param id The id of the relationship
         */
        deleteUserRelationship(params: {  "id": number; }, options?: any) {
            return UsersRelationshipsApiFp.deleteUserRelationship(params, options)(fetch, basePath);
        },
        /** 
         * Get a user relationship
         * @param id The id of the relationship
         */
        getUserRelationship(params: {  "id": number; }, options?: any) {
            return UsersRelationshipsApiFp.getUserRelationship(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of user relationships
         */
        getUserRelationships(options?: any) {
            return UsersRelationshipsApiFp.getUserRelationships(options)(fetch, basePath);
        },
        /** 
         * Update a user relationship
         * @param id The id of the relationship
         * @param relationship The new relationship
         */
        updateUserRelationship(params: {  "id": number; "relationship"?: UserRelationshipResource; }, options?: any) {
            return UsersRelationshipsApiFp.updateUserRelationship(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersSubscriptionsApi - fetch parameter creator
 */
export const UsersSubscriptionsApiFetchParamCreator = {
    /** 
     * Get details about a user&#39;s subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  "userId": number; "inventoryId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserSubscriptionDetails");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling getUserSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get details about a user&#39;s subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUsersSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  "userId": number; "inventoryId": number; "reactivateSubscriptionRequest"?: ReactivateSubscriptionRequest; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling reactivateUserSubscription");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling reactivateUserSubscription");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/reactivate`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reactivateSubscriptionRequest"]) {
            fetchOptions.body = JSON.stringify(params["reactivateSubscriptionRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  "userId": number; "inventoryId": number; "billDate": number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionBillDate");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionBillDate");
        }
        // verify required parameter "billDate" is set
        if (params["billDate"] == null) {
            throw new Error("Missing required parameter billDate when calling setSubscriptionBillDate");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/bill-date`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billDate"]) {
            fetchOptions.body = JSON.stringify(params["billDate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the payment method to use for a subscription
     * May send null to use floating default
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  "userId": number; "inventoryId": number; "paymentMethodId"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionPaymentMethod");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/payment-method`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethodId"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethodId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set the status of a subscription
     * The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: {  "userId": number; "inventoryId": number; "status": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionStatus");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setSubscriptionStatus");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  "userId": number; "inventoryId": number; "planId"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserSubscriptionPlan");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setUserSubscriptionPlan");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/plan`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["planId"]) {
            fetchOptions.body = JSON.stringify(params["planId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersSubscriptionsApi - functional programming interface
 */
export const UsersSubscriptionsApiFp = {
    /** 
     * Get details about a user&#39;s subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: { "userId": number; "inventoryId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InventorySubscriptionResource> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.getUserSubscriptionDetails(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get details about a user&#39;s subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: { "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InventorySubscriptionResource>> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.getUsersSubscriptionDetails(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: { "userId": number; "inventoryId": number; "reactivateSubscriptionRequest"?: ReactivateSubscriptionRequest;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.reactivateUserSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: { "userId": number; "inventoryId": number; "billDate": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionBillDate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the payment method to use for a subscription
     * May send null to use floating default
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: { "userId": number; "inventoryId": number; "paymentMethodId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set the status of a subscription
     * The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: { "userId": number; "inventoryId": number; "status": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: { "userId": number; "inventoryId": number; "planId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setUserSubscriptionPlan(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersSubscriptionsApi - object-oriented interface
 */
export class UsersSubscriptionsApi extends BaseAPI {
    /** 
     * Get details about a user&#39;s subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  "userId": number; "inventoryId": number; }, options?: any) {
        return UsersSubscriptionsApiFp.getUserSubscriptionDetails(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get details about a user&#39;s subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  "userId": number; }, options?: any) {
        return UsersSubscriptionsApiFp.getUsersSubscriptionDetails(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  "userId": number; "inventoryId": number; "reactivateSubscriptionRequest"?: ReactivateSubscriptionRequest; }, options?: any) {
        return UsersSubscriptionsApiFp.reactivateUserSubscription(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  "userId": number; "inventoryId": number; "billDate": number; }, options?: any) {
        return UsersSubscriptionsApiFp.setSubscriptionBillDate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the payment method to use for a subscription
     * May send null to use floating default
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  "userId": number; "inventoryId": number; "paymentMethodId"?: number; }, options?: any) {
        return UsersSubscriptionsApiFp.setSubscriptionPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set the status of a subscription
     * The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: {  "userId": number; "inventoryId": number; "status": string; }, options?: any) {
        return UsersSubscriptionsApiFp.setSubscriptionStatus(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  "userId": number; "inventoryId": number; "planId"?: string; }, options?: any) {
        return UsersSubscriptionsApiFp.setUserSubscriptionPlan(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersSubscriptionsApi - factory interface
 */
export const UsersSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get details about a user&#39;s subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         */
        getUserSubscriptionDetails(params: {  "userId": number; "inventoryId": number; }, options?: any) {
            return UsersSubscriptionsApiFp.getUserSubscriptionDetails(params, options)(fetch, basePath);
        },
        /** 
         * Get details about a user&#39;s subscriptions
         * @param userId The id of the user
         */
        getUsersSubscriptionDetails(params: {  "userId": number; }, options?: any) {
            return UsersSubscriptionsApiFp.getUsersSubscriptionDetails(params, options)(fetch, basePath);
        },
        /** 
         * Reactivate a subscription and charge fee
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
         */
        reactivateUserSubscription(params: {  "userId": number; "inventoryId": number; "reactivateSubscriptionRequest"?: ReactivateSubscriptionRequest; }, options?: any) {
            return UsersSubscriptionsApiFp.reactivateUserSubscription(params, options)(fetch, basePath);
        },
        /** 
         * Set a new date to bill a subscription on
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param billDate The new bill date. Unix timestamp in seconds
         */
        setSubscriptionBillDate(params: {  "userId": number; "inventoryId": number; "billDate": number; }, options?: any) {
            return UsersSubscriptionsApiFp.setSubscriptionBillDate(params, options)(fetch, basePath);
        },
        /** 
         * Set the payment method to use for a subscription
         * May send null to use floating default
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param paymentMethodId The id of the payment method
         */
        setSubscriptionPaymentMethod(params: {  "userId": number; "inventoryId": number; "paymentMethodId"?: number; }, options?: any) {
            return UsersSubscriptionsApiFp.setSubscriptionPaymentMethod(params, options)(fetch, basePath);
        },
        /** 
         * Set the status of a subscription
         * The body is a json string (put in quotes) that should match a desired invoice status type. Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
         */
        setSubscriptionStatus(params: {  "userId": number; "inventoryId": number; "status": string; }, options?: any) {
            return UsersSubscriptionsApiFp.setSubscriptionStatus(params, options)(fetch, basePath);
        },
        /** 
         * Set a new subscription plan for a user
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param planId The id of the new plan. Must be from the same subscription
         */
        setUserSubscriptionPlan(params: {  "userId": number; "inventoryId": number; "planId"?: string; }, options?: any) {
            return UsersSubscriptionsApiFp.setUserSubscriptionPlan(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilBatchApi - fetch parameter creator
 */
export const UtilBatchApiFetchParamCreator = {
    /** 
     * Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  "batch"?: Batch; }, options?: any): FetchArgs {
        const baseUrl = `/batch`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["batch"]) {
            fetchOptions.body = JSON.stringify(params["batch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilBatchApi - functional programming interface
 */
export const UtilBatchApiFp = {
    /** 
     * Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: { "batch"?: Batch;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilBatchApiFetchParamCreator.sendBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilBatchApi - object-oriented interface
 */
export class UtilBatchApi extends BaseAPI {
    /** 
     * Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  "batch"?: Batch; }, options?: any) {
        return UtilBatchApiFp.sendBatch(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UtilBatchApi - factory interface
 */
export const UtilBatchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Request to run API call given the method, content type, path url, and body of request
         * @param batch The batch object
         */
        sendBatch(params: {  "batch"?: Batch; }, options?: any) {
            return UtilBatchApiFp.sendBatch(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilHealthApi - fetch parameter creator
 */
export const UtilHealthApiFetchParamCreator = {
    /** 
     * Get health info
     */
    getHealth(options?: any): FetchArgs {
        const baseUrl = `/health`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilHealthApi - functional programming interface
 */
export const UtilHealthApiFp = {
    /** 
     * Get health info
     */
    getHealth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilHealthApiFetchParamCreator.getHealth(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilHealthApi - object-oriented interface
 */
export class UtilHealthApi extends BaseAPI {
    /** 
     * Get health info
     */
    getHealth(options?: any) {
        return UtilHealthApiFp.getHealth(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilHealthApi - factory interface
 */
export const UtilHealthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get health info
         */
        getHealth(options?: any) {
            return UtilHealthApiFp.getHealth(options)(fetch, basePath);
        },
    };
};


/**
 * UtilMaintenanceApi - fetch parameter creator
 */
export const UtilMaintenanceApiFetchParamCreator = {
    /** 
     * Delete maintenance info
     */
    deleteMaintenance(options?: any): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get current maintenance info
     * Get current maintenance info. 404 if no maintenance.
     */
    getMaintenance(options?: any): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilMaintenanceApi - functional programming interface
 */
export const UtilMaintenanceApiFp = {
    /** 
     * Delete maintenance info
     */
    deleteMaintenance(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.deleteMaintenance(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get current maintenance info
     * Get current maintenance info. 404 if no maintenance.
     */
    getMaintenance(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Maintenance> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.getMaintenance(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: { "maintenance"?: Maintenance;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.setMaintenance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: { "maintenance"?: Maintenance;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.updateMaintenance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilMaintenanceApi - object-oriented interface
 */
export class UtilMaintenanceApi extends BaseAPI {
    /** 
     * Delete maintenance info
     */
    deleteMaintenance(options?: any) {
        return UtilMaintenanceApiFp.deleteMaintenance(options)(this.fetch, this.basePath);
    }
    /** 
     * Get current maintenance info
     * Get current maintenance info. 404 if no maintenance.
     */
    getMaintenance(options?: any) {
        return UtilMaintenanceApiFp.getMaintenance(options)(this.fetch, this.basePath);
    }
    /** 
     * Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any) {
        return UtilMaintenanceApiFp.setMaintenance(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any) {
        return UtilMaintenanceApiFp.updateMaintenance(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UtilMaintenanceApi - factory interface
 */
export const UtilMaintenanceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Delete maintenance info
         */
        deleteMaintenance(options?: any) {
            return UtilMaintenanceApiFp.deleteMaintenance(options)(fetch, basePath);
        },
        /** 
         * Get current maintenance info
         * Get current maintenance info. 404 if no maintenance.
         */
        getMaintenance(options?: any) {
            return UtilMaintenanceApiFp.getMaintenance(options)(fetch, basePath);
        },
        /** 
         * Set current maintenance info
         * @param maintenance The maintenance object
         */
        setMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any) {
            return UtilMaintenanceApiFp.setMaintenance(params, options)(fetch, basePath);
        },
        /** 
         * Update current maintenance info
         * @param maintenance The maintenance object
         */
        updateMaintenance(params: {  "maintenance"?: Maintenance; }, options?: any) {
            return UtilMaintenanceApiFp.updateMaintenance(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilSecurityApi - fetch parameter creator
 */
export const UtilSecurityApiFetchParamCreator = {
    /** 
     * Returns the authentication log for a user
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @param userId The user id
     */
    getUserLocationLog(params: {  "userId"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/security/country-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "user_id": params["userId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Returns the authentication token details. Use /users endpoint for detailed user&#39;s info
     */
    getUserTokenDetails(options?: any): FetchArgs {
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilSecurityApi - functional programming interface
 */
export const UtilSecurityApiFp = {
    /** 
     * Returns the authentication log for a user
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @param userId The user id
     */
    getUserLocationLog(params: { "userId"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PageResourceLocationLogResource> {
        const fetchArgs = UtilSecurityApiFetchParamCreator.getUserLocationLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Returns the authentication token details. Use /users endpoint for detailed user&#39;s info
     */
    getUserTokenDetails(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TokenDetailsResource> {
        const fetchArgs = UtilSecurityApiFetchParamCreator.getUserTokenDetails(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilSecurityApi - object-oriented interface
 */
export class UtilSecurityApi extends BaseAPI {
    /** 
     * Returns the authentication log for a user
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @param userId The user id
     */
    getUserLocationLog(params: {  "userId"?: number; }, options?: any) {
        return UtilSecurityApiFp.getUserLocationLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Returns the authentication token details. Use /users endpoint for detailed user&#39;s info
     */
    getUserTokenDetails(options?: any) {
        return UtilSecurityApiFp.getUserTokenDetails(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilSecurityApi - factory interface
 */
export const UtilSecurityApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Returns the authentication log for a user
         * A log entry is recorded everytime a user requests a new token. Standard pagination available
         * @param userId The user id
         */
        getUserLocationLog(params: {  "userId"?: number; }, options?: any) {
            return UtilSecurityApiFp.getUserLocationLog(params, options)(fetch, basePath);
        },
        /** 
         * Returns the authentication token details. Use /users endpoint for detailed user&#39;s info
         */
        getUserTokenDetails(options?: any) {
            return UtilSecurityApiFp.getUserTokenDetails(options)(fetch, basePath);
        },
    };
};


/**
 * UtilVersionApi - fetch parameter creator
 */
export const UtilVersionApiFetchParamCreator = {
    /** 
     * Get current version info
     */
    getVersion(options?: any): FetchArgs {
        const baseUrl = `/version`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilVersionApi - functional programming interface
 */
export const UtilVersionApiFp = {
    /** 
     * Get current version info
     */
    getVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Version> {
        const fetchArgs = UtilVersionApiFetchParamCreator.getVersion(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilVersionApi - object-oriented interface
 */
export class UtilVersionApi extends BaseAPI {
    /** 
     * Get current version info
     */
    getVersion(options?: any) {
        return UtilVersionApiFp.getVersion(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilVersionApi - factory interface
 */
export const UtilVersionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get current version info
         */
        getVersion(options?: any) {
            return UtilVersionApiFp.getVersion(options)(fetch, basePath);
        },
    };
};

