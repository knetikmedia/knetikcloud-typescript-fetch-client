/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

import { Configuration } from "./configuration";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://jsapi-integration.us-east-1.elasticbeanstalk.com".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    public configuration: Configuration;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH, configuration: Configuration = new Configuration()) {
        this.basePath = basePath;
        this.fetch = fetch;
        this.configuration = configuration;
    }
};

export interface AchievementDefinitionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this resource type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The description of the achievement. Must be at least 2 characters in length.
     */
    "description"?: string;
    /**
     * Whether the achievement is hidden from the user
     */
    "hidden": boolean;
    /**
     * The name of the achievement. Must be at least 6 characters in length. IMMUTABLE
     */
    "name": string;
    /**
     * The required progress for the achievement definition
     */
    "requiredProgress": number;
    /**
     * The id of the rule generated for this achievement
     */
    "ruleId"?: string;
    /**
     * The tags for the achievement definition
     */
    "tags"?: Array<string>;
    /**
     * An achievement template this achievement is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The name of the trigger event associated with this achievement
     */
    "triggerEventName"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ActionContextobject {
    /**
     * The mapping of the action context
     */
    "mapping": any;
    /**
     * The name of the action
     */
    "type": string;
}

export interface ActionResource {
    /**
     * The category the action is in. All customer specific actions are in the 'custom' category
     */
    "category"?: ActionResourceCategoryEnum;
    /**
     * The description of the action
     */
    "description": string;
    /**
     * The name of the action. Used as the unique id for reference
     */
    "name": string;
    /**
     * A list of tags for searching
     */
    "tags"?: Array<string>;
    /**
     * The variables required for the action
     */
    "variables": Array<ActionVariableResource>;
}

export type ActionResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "device" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface ActionVariableResource {
    /**
     * The name of the variable
     */
    "name": string;
    /**
     * Whether this variable is optional and can be left out/null
     */
    "optional": boolean;
    /**
     * The type of the variable (see variable type endpoint for list)
     */
    "type": string;
}

export interface ActivityEntitlementResource {
    /**
     * The ISO3 currency code the price is in, if available
     */
    "currencyCode"?: string;
    /**
     * The id of the entitlement item
     */
    "itemId": number;
    /**
     * The name of the entitlement item
     */
    "name"?: string;
    /**
     * The price of the sku, if available
     */
    "price"?: number;
    /**
     * The sku id, if available. If multiple are available, then first one is returned
     */
    "sku"?: string;
}

export interface ActivityOccurrenceCreationFailure {
    /**
     * The details of each user's entry, or just the current user's if not run with ACTIVITIES_ADMIN permission
     */
    "userResults"?: Array<ActivityOccurrenceJoinResult>;
}

export interface ActivityOccurrenceJoinResult {
    /**
     * The details on the entitlement object needed to enter the occurrence (if any)
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * Zero if the user was/could be added to the occurrence. Jsapi error code indicating the reason of the failure otherwise
     */
    "errorCode": number;
    /**
     * An error message if failure
     */
    "message"?: string;
    /**
     * The user's id
     */
    "userId": number;
}

/**
 * A occurrence of an activity (the actual game for example). Used to track scores, participants, and provide settings
 */
export interface ActivityOccurrenceResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The ids of banned users that cannot join the occurrence. See occurrence-user delete endpoint
     */
    "bans"?: Array<number>;
    /**
     * The id of the challenge activity (as part of the event, required if eventId set)
     */
    "challengeActivityId"?: number;
    /**
     * Defines core settings about the activity occurrence that affect how it behaves in the system. Validated against core settings in activity/challenge-activity.
     */
    "coreSettings"?: CoreActivityOccurrenceSettings;
    /**
     * The date this occurrence was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The id of the event
     */
    "eventId"?: number;
    /**
     * The host of the occurrence, if not a participant (will be left out of users array). Must be the caller that creates the occurrence unless admin. Requires activity/challenge to allow host_option of 'non_player' if not admin as well
     */
    "host"?: SimpleUserResource;
    /**
     * The id of the activity occurrence
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: ActivityOccurrenceResourceRewardStatusEnum;
    /**
     * The values selected from the available settings defined for the activity. Ex: difficulty: hard. Can be left out if the activity is played during an event and the settings are already set at the event level. Ex: every monday, difficulty: hard, number of questions: 10, category: sport. Otherwise, the set must exactly match those of the activity.
     */
    "settings"?: Array<SelectedSettingResource>;
    /**
     * Whether this occurrence will be ran as a simulation. Simulations will not be rewarded. Useful for bot play or trials
     */
    "simulated"?: boolean;
    /**
     * The date this occurrence was started, unix timestamp in seconds. null if not yet started
     */
    "startDate"?: number;
    /**
     * The current status of the occurrence (default: OPEN)
     */
    "status"?: ActivityOccurrenceResourceStatusEnum;
    /**
     * The date this occurrence was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The list of users participating in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
     */
    "users"?: Array<ActivityUserResource>;
}

export type ActivityOccurrenceResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export type ActivityOccurrenceResourceStatusEnum = "SETUP" | "OPEN" | "LAUNCHING" | "PLAYING" | "FINISHED" | "ABANDONED";
export interface ActivityOccurrenceResults {
    /**
     * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
     */
    "users": Array<UserActivityResults>;
}

export interface ActivityOccurrenceResultsResource {
    /**
     * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
     */
    "users": Array<UserActivityResultsResource>;
}

export interface ActivityOccurrenceSettingsResource {
    /**
     * Defines core settings about the activity occurrence that affect how it behaves in the system. Validated against core settings in activity/challenge-activity.
     */
    "coreSettings"?: CoreActivityOccurrenceSettings;
    /**
     * The values selected from the available settings defined for the activity. Ex: difficulty: hard. Can be left out if the activity is played during an event and the settings are already set at the event level. Ex: every monday, difficulty: hard, number of questions: 10, category: sport. Otherwise, the set must exactly match those of the activity.
     */
    "settings"?: Array<SelectedSettingRequest>;
}

export interface ActivityOccurrenceStatusWrapper {
    "value"?: ActivityOccurrenceStatusWrapperValueEnum;
}

export type ActivityOccurrenceStatusWrapperValueEnum = "SETUP" | "OPEN" | "LAUNCHING" | "PLAYING" | "FINISHED" | "ABANDONED";
/**
 * Represents an activity that can be parameterized and tracked through metrics (scores, etc)
 */
export interface ActivityResource {
    /**
     * A map of additional properties keyed on the property name. Used to further describe an activity. While settings will vary from one activity occurrence (a game) to another, additional properties are shared by all the occurrences of this activity. Ex: Activity Logo, Disclaimer, Greeting, etc. Validated against template if one exists for activities
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * Defines core settings about the activity that affect how it can be created/played by users.
     */
    "coreSettings"?: CoreActivitySettings;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The list of items that can be used for entitlement (wager amounts/etc)
     */
    "entitlements"?: Array<ActivityEntitlementResource>;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The strategy for calculating the leaderboard. No strategy means no leaderboard for the top level context. Value MUST come from the list of available strategies from the Leaderboard Service
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * Define what parameters are required/available to start and run an activity. For example: Difficulty, Number of Questions, Character name, Avatar, Duration, etc. Not populated when getting listing
     */
    "settings"?: Array<AvailableSettingResource>;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * An activity template this activity is validated against (private). May be null and no validation of additional_properties will be done
     */
    "templateId"?: string;
    /**
     * The type of the activity
     */
    "type"?: string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ActivityUserResource {
    /**
     * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
     */
    "host"?: boolean;
    /**
     * The id of the activity user entry
     */
    "id"?: number;
    /**
     * The date this user last joined the occurrence, unix timestamp in seconds
     */
    "joinedDate"?: number;
    /**
     * The date this user last left the occurrence, unix timestamp in seconds. Null if still present
     */
    "leftDate"?: number;
    /**
     * The metric for the user's results, after the game is over
     */
    "metric"?: MetricResource;
    /**
     * The current status of the user in the occurrence (default: present)
     */
    "status"?: ActivityUserResourceStatusEnum;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export type ActivityUserResourceStatusEnum = "present" | "ready" | "left" | "surrendered" | "disconnected";
export interface ActivityUserStatusWrapper {
    "value"?: ActivityUserStatusWrapperValueEnum;
}

export type ActivityUserStatusWrapperValueEnum = "present" | "ready" | "left" | "surrendered" | "disconnected";
export interface AddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface AggregateCountResource {
    "count"?: number;
    "date"?: string;
}

export interface AggregateInvoiceReportResource {
    "count"?: number;
    "date"?: string;
    "revenue"?: number;
    "userCount"?: number;
}

export interface AmazonS3Activity {
    /**
     * S3 action (i.e., 'PUT') associated with the activity
     */
    "action"?: string;
    /**
     * URL for accessing the resource. Will use a CDN if configured, or direct to S3 if not
     */
    "cdnUrl"?: string;
    /**
     * Date the resource was created in S3
     */
    "createdDate"?: number;
    /**
     * Name of the file being processed as a resource in S3
     */
    "filename"?: string;
    /**
     * Unique id of the S3 activity
     */
    "id"?: number;
    /**
     * S3 object key for the resource
     */
    "objectKey"?: string;
    /**
     * URL that one can PUT the file to, to upload it to S3
     */
    "url"?: string;
    /**
     * The id of the user that created this S3 activity
     */
    "userId"?: number;
}

export interface AnswerResource {
    /**
     * The answer to the question. Different 'type' values indicate different structures as the answer may be test, image, etc. See information on additional properties for the list and their structures
     */
    "answer": Property;
    /**
     * Whether the answer is correct or not
     */
    "correct": boolean;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
}

export interface ApplyPaymentRequest {
    /**
     * The id of the local invoice being paid.
     */
    "invoiceId": number;
    /**
     * The encoded receipt string from Apple's services.
     */
    "receipt": string;
    /**
     * The id of the specific transaction from Apple's services.
     */
    "transactionId": string;
}

export interface ArgumentResource {
    "name"?: string;
    "type"?: string;
}

export interface ArticleResource {
    /**
     * Whether the article is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The body of the article
     */
    "body": string;
    /**
     * The category for the article
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the article
     */
    "id"?: string;
    /**
     * The tags for the article
     */
    "tags"?: Array<string>;
    /**
     * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The title of the article
     */
    "title": string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ArtistResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * YYYY/MM/DD when this artist was born
     */
    "born"?: string;
    /**
     * The current number of contributions the artist has made
     */
    "contributionCount"?: number;
    /**
     * The list of media this artist has contributed to as well as role(s) during contribution.  Use media endpoint to add contributions
     */
    "contributions"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * YYYY/MM/DD when this artist died
     */
    "died"?: string;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order priority ofr the artist.  Default 100
     */
    "priority"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * An artist template this artist is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

/**
 * The definition of an activity parameters: ex: difficulty level
 */
export interface AvailableSettingResource {
    /**
     * Whether the setting is advanced. Default: false
     */
    "advancedOption"?: boolean;
    /**
     * The default value of the setting (must be in options array). Ex: easy
     */
    "defaultValue"?: string;
    /**
     * The description of the setting: Ex: Choose the difficulty level to show more or less complicated questions (for a trivia activity)
     */
    "description"?: string;
    /**
     * The unique ID for the setting: Ex: difficulty
     */
    "key": string;
    /**
     * The textual name of the setting: Ex: Difficulty Level
     */
    "name": string;
    /**
     * The set of options available for this setting, Ex: easy, medium, hard
     */
    "options"?: Array<SettingOption>;
    /**
     * The type of the setting value: Ex: TEXT
     */
    "type": string;
}

export interface BareActivityResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * The type of the activity
     */
    "type"?: string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface BareChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge
     */
    "challengeId": number;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
}

export interface BasicTemplatedResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface Batch {
    /**
     * The list of batch requests
     */
    "batch": Array<BatchRequest>;
    /**
     * The amount of time before a request token is returned instead of the batch result.  Default is 60.  Range is 0-300
     */
    "timeout": number;
}

export interface BatchRequest {
    /**
     * The request body as would be passed to the URI
     */
    "body": any;
    /**
     * Content type used, Ex:(application/json)
     */
    "contentType": string;
    /**
     * The HTTP method used, Ex: (GET)
     */
    "method": string;
    /**
     * Time in seconds before process will timeout.  Default is 60.  Range is 1-300
     */
    "timeout": number;
    /**
     * The oauth token only
     */
    "token"?: string;
    /**
     * Full URI of REST call
     */
    "uri": string;
}

export interface BatchResult {
    /**
     * List of batch responses.  Returns in the order requested
     */
    "batchReturn"?: Array<BatchReturn>;
    /**
     * The date the batch call started processing
     */
    "createdDate"?: number;
    /**
     * The token to use at the /batch/{token} endpoint if the request times out
     */
    "id"?: string;
    /**
     * The date the batch call finished processing
     */
    "updatedDate"?: number;
}

export interface BatchReturn {
    /**
     * The result body
     */
    "body"?: any;
    /**
     * The HTTP response code
     */
    "code"?: number;
    /**
     * Full URI of REST call
     */
    "uri"?: string;
}

export interface Behavior {
    "description"?: string;
    /**
     * Used for polymorphic type recognition and thus must match an expected type with additional properties
     */
    "typeHint"?: string;
}

export interface BehaviorDefinitionResource {
    /**
     * Description of the behavior
     */
    "description"?: string;
    /**
     * Pre-requisite behaviors that an item must have in order to also have this behavior
     */
    "prerequisiteBehaviors"?: Array<Behavior>;
    /**
     * Configurable properties of the behavior
     */
    "properties": Array<PropertyFieldResource>;
    /**
     * The behavior type
     */
    "typeHint": string;
}

export interface BillingReport {
    "created"?: number;
    "id"?: string;
    "lastKnownFailures"?: Array<string>;
    "statistics"?: { [key: string]: number; };
}

export interface BooleanResource {
    "value"?: boolean;
}

export interface BreActionLog {
    /**
     * The name of the action
     */
    "name"?: string;
    /**
     * The runtime of the action in milliseconds
     */
    "runtime"?: number;
    /**
     * The status of the action (ran, failed)
     */
    "status"?: string;
}

export interface BreEvent {
    /**
     * The event name of the trigger to be fired
     */
    "eventName": string;
    /**
     * The parameters to the event. A Map (assosiative array) with a key for each trigger parameter name and a corrosponding value.
     */
    "params": any;
}

export interface BreEventLog {
    /**
     * The customer of the BRE event log
     */
    "customer"?: string;
    /**
     * The event id of the BRE event log
     */
    "eventId"?: string;
    /**
     * The event name of the BRE event log
     */
    "eventName"?: string;
    /**
     * The event start date of the BRE event log
     */
    "eventStartDate"?: number;
    /**
     * The id of the BRE event log
     */
    "id"?: string;
    /**
     * The event paramters of the BRE event log
     */
    "parameters"?: any;
    /**
     * The rules of the BRE event log
     */
    "rules"?: Array<BreRuleLog>;
}

export interface BreGlobalResource {
    /**
     * A human readable description for display in admin pages
     */
    "description"?: string;
    /**
     * The id of the global definition. Default is a random guid. Cannot be updated
     */
    "id"?: string;
    /**
     * The key for the global. Must be unique when combined with scope names. Usually a single descriptive word like 'purchases' or 'logins'
     */
    "key": string;
    /**
     * A human readable name for display in admin pages
     */
    "name"?: string;
    /**
     * A list of scoping parameters. Allows the global to have a different value in different context such as a count of purchases for each user (by putting a 'user' scope in this list). When using this global in a rule these scopes will need to be mapped with an expression to provide a value, similar to the parameters in an action
     */
    "scopes"?: Array<BreGlobalScopeDefinition>;
    /**
     * Where this global came from. System globals cannot be removed or updated
     */
    "systemGlobal"?: boolean;
    /**
     * The variable type the global stores. See the BRE variables endpoint for list
     */
    "type": string;
}

export interface BreGlobalScopeDefinition {
    /**
     * The name of the scoping parameter. This is used as the unique identifier of this scope
     */
    "name": string;
    /**
     * The variable type of this scoping parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreRule {
    /**
     * A list of actions to execute, and the mapping for their parameters, when the rule runs. Minimum 1
     */
    "actions": Array<ActionContextobject>;
    /**
     * A condition expression that must be met in a given event for the rule to run. Null to always run.
     */
    "condition"?: PredicateResource;
    /**
     * The condition as a readable string. Filled in by the system from the condition
     */
    "conditionText"?: string;
    /**
     * The human readable description of the rule
     */
    "description"?: string;
    /**
     * Whether the rule is enabled to run (in conjunction with dates). Default true
     */
    "enabled"?: boolean;
    /**
     * The date the rule ceases to take effect, or null if never. Unix timestamp in seconds
     */
    "endDate"?: number;
    /**
     * How many times the rule has been evaluated (it's conditions checked, whether it then runs or not)
     */
    "evaluationCount"?: number;
    /**
     * The event name of the trigger this rule runs for. Affects which parameters are available
     */
    "eventName": string;
    /**
     * The id of the rule for later references. If left null a random guid will be generated. Must be unique. Cannot be changed
     */
    "id"?: string;
    /**
     * The human readable name of the rule
     */
    "name": string;
    /**
     * How many times the rule has run
     */
    "runCount"?: number;
    /**
     * Used to sort rules to control the order they run in. Larger numbered sort values run first.  Default 500
     */
    "sort"?: number;
    /**
     * The date the rule begins to take effect, or null if always. Unix timestamp in seconds
     */
    "startDate"?: number;
    /**
     * Whether the rule is a default part of the system. System rules cannot be edited or deleted, but may be disabled
     */
    "systemRule"?: boolean;
}

export interface BreRuleLog {
    /**
     * The actions of the BRE rule
     */
    "actions"?: Array<BreActionLog>;
    /**
     * Whether the rule ran
     */
    "ran"?: boolean;
    /**
     * The reason for the rule
     */
    "reason"?: string;
    /**
     * The end date of the rule in seconds
     */
    "ruleEndDate"?: number;
    /**
     * The id of the rule
     */
    "ruleId"?: string;
    /**
     * The name of the rule
     */
    "ruleName"?: string;
    /**
     * The start date of the rule in seconds
     */
    "ruleStartDate"?: number;
}

export interface BreTriggerParameterDefinition {
    /**
     * Whether this parameter is implicitely derived from another. Internal use only.
     */
    "implicit"?: boolean;
    /**
     * The name of the parameter. This is used as the unique identifier of this parameter
     */
    "name": string;
    /**
     * Whether this parameter can be left off when firing the event. Default false
     */
    "optional"?: boolean;
    /**
     * The variable type of this parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreTriggerResource {
    /**
     * The category this trigger belongs to. See endpoints for related asset information. All new triggers are in category 'custom'
     */
    "category"?: BreTriggerResourceCategoryEnum;
    /**
     * The unique name for the event. This serves as the unique identifier. Cannot be changed after creation
     */
    "eventName": string;
    /**
     * A list of parameters that will be sent with the event when the trigger is fired. These must be included in the event and match the described types
     */
    "parameters"?: Array<BreTriggerParameterDefinition>;
    /**
     * Where this trigger came from. System triggers cannot be removed or updated
     */
    "systemTrigger"?: boolean;
    /**
     * A list of tags for filtering
     */
    "tags"?: Array<string>;
    /**
     * A description of the trigger
     */
    "triggerDescription": string;
    /**
     * A human readable name for this trigger
     */
    "triggerName": string;
}

export type BreTriggerResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "device" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface BroadcastableEvent {
    "client"?: string;
    "customer"?: string;
    "doNotBroadcast"?: boolean;
    "section"?: string;
    "source"?: any;
    "specifics"?: string;
    "synchronous"?: boolean;
    "timestamp"?: number;
    /**
     * The type of the event. Used for polymorphic type recognition and thus must match an expected type
     */
    "type": string;
}

export interface BundledSku {
    /**
     * The amount this item will cost inside the bundle instead of its regular price
     */
    "priceOverride"?: number;
    /**
     * The quantity of this item within the bundle
     */
    "quantity": number;
    /**
     * The stock keeping unit (SKU) for an item included in the bundle
     */
    "sku": string;
}

export interface CampaignResource {
    /**
     * Whether the campaign is active or not.  Defaults to false
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The name of the next challenge coming up
     */
    "nextChallenge"?: string;
    /**
     * The date/time of the next challenge coming up
     */
    "nextChallengeDate"?: number;
    /**
     * The rewards to give at the end of the campaign. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: CampaignResourceRewardStatusEnum;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * A campaign template this campaign is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type CampaignResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface Cart {
    "availableShippingOptions"?: Array<CartShippingOption>;
    "countryTax"?: number;
    "coupons"?: Array<CouponDefinition>;
    "created"?: number;
    "currencyCode"?: string;
    "discountTotal"?: number;
    "errorCode"?: number;
    "errorMessage"?: string;
    "grandTotal"?: number;
    "id"?: string;
    "invoiceId"?: number;
    "items"?: Array<CartLineItem>;
    "owner"?: number;
    "selectedShippingOptions"?: Array<CartShippingOption>;
    "shippable"?: boolean;
    "shippingAddress"?: CartShippingAddressRequest;
    "shippingCost"?: number;
    "stateTax"?: number;
    "status"?: CartStatusEnum;
    "subtotal"?: number;
    "updated"?: number;
}

export type CartStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CartItemRequest {
    /**
     * The affiliate key of the item
     */
    "affiliateKey"?: string;
    /**
     * The catalog SKU of the item
     */
    "catalogSku": string;
    /**
     * Allows to override the price of an item, if the behavior configuration permits it
     */
    "priceOverride": number;
    /**
     * The quantity of the item
     */
    "quantity": number;
}

export interface CartLineItem {
    "currencyCode"?: string;
    "description"?: string;
    "discount"?: Discount;
    "lineTotal"?: number;
    "name"?: string;
    "originalLineTotal"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "storeItemId"?: number;
    "tags"?: Array<string>;
    "thumbUrl"?: string;
    "uniqueKey"?: string;
    "unitPrice"?: number;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartShippableResponse {
    /**
     * The id of the cart
     */
    "cartId"?: number;
    /**
     * Whether the item is shippable
     */
    "shippable"?: boolean;
}

export interface CartShippingAddressRequest {
    /**
     * The city of the user
     */
    "city"?: string;
    /**
     * The country code of the user
     */
    "countryCodeIso3"?: string;
    /**
     * The email of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    "namePrefix"?: string;
    /**
     * The order notes the user
     */
    "orderNotes"?: string;
    /**
     * The phone number of the user
     */
    "phoneNumber"?: string;
    /**
     * The postal state code of the user
     */
    "postalStateCode"?: string;
    /**
     * The shipping address of the user, first line
     */
    "shippingAddressLine1"?: string;
    /**
     * The shipping address of the user, second line
     */
    "shippingAddressLine2"?: string;
    /**
     * The zipcode of the user
     */
    "zip"?: string;
}

export interface CartShippingOption {
    "currencyCode"?: string;
    "description"?: string;
    "name"?: string;
    "originalPrice"?: number;
    "price"?: number;
    "shippingItemId"?: number;
    "sku"?: string;
    "taxable"?: boolean;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartSummary {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique id code for the currency used in the cart
     */
    "currencyCode"?: string;
    /**
     * The grand total for the cart
     */
    "grandTotal"?: number;
    /**
     * The unique ID for the cart
     */
    "id"?: string;
    /**
     * The ID of the invoice associated with this cart
     */
    "invoiceId"?: number;
    /**
     * The number of items in the cart
     */
    "itemsInCart"?: number;
    /**
     * The status of the cart
     */
    "status"?: CartSummaryStatusEnum;
    /**
     * The subtotal of all items in the cart
     */
    "subtotal"?: number;
}

export type CartSummaryStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CatalogSale {
    /**
     * The iso3 code for the currency for this discountValue.  The sku purchased will have to match for it this sale to apply
     */
    "currencyCode": string;
    /**
     * The way in which the price is reduced. 'value' means subtracting directly, 'percentage' means subtracting by the price times the discountValue (1.0 == 100%)
     */
    "discountType": CatalogSaleDiscountTypeEnum;
    /**
     * The amount deducted from the price, in the same currencyCode as the item
     */
    "discountValue"?: number;
    /**
     * The id of the sale
     */
    "id"?: number;
    /**
     * The id of the item this sale applies to.  Leave null to use other filters
     */
    "item"?: number;
    /**
     * The long description of the sale
     */
    "longDescription"?: string;
    /**
     * The name of the sale.  Max 40 characters
     */
    "name": string;
    /**
     * The date the sale ends, null for never.  Unix timestamp in seconds
     */
    "saleEndDate"?: number;
    /**
     * The date the sale begins.  Unix timestamp in seconds
     */
    "saleStartDate": number;
    /**
     * The short description of the sale.  Max 140 characters
     */
    "shortDescription"?: string;
    /**
     * The tag this sale applies to.  Leave null to skip this filter (applies to all tags)
     */
    "tag"?: string;
    /**
     * The id of the vendor this sale applies to.  Leave null to skip this filter (applies to all vendors)
     */
    "vendor"?: number;
}

export type CatalogSaleDiscountTypeEnum = "value" | "percentage";
export interface CategoryResource {
    /**
     * Whether the category is currently active. If not, it and its questions will be filtered out.
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The unique ID for this category
     */
    "id"?: string;
    /**
     * The name of this category. Cannot be blank
     */
    "name": string;
    /**
     * A category template this category is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface ChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * Defines core settings about the activity that affect how it can be created/played by users. Values may be left null to inherit from parent activity.
     */
    "coreSettings"?: CoreChallengeActivitySettings;
    /**
     * The entitlement item needed to participate in the activity as part of this event. Null indicates free entry. When creating/updating only id is used. Item must be pre-existing
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The list of settings and the select options
     */
    "settings"?: Array<SelectedSettingResource>;
    /**
     * A challenge activity template this challenge activity is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface ChallengeEventParticipantResource {
    /**
     * The email address of the user
     */
    "email"?: string;
    /**
     * The full name of the user
     */
    "fullname"?: string;
    /**
     * The user's score
     */
    "score"?: number;
    /**
     * The id of the user
     */
    "userId"?: number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface ChallengeEventResource {
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * The end date in seconds
     */
    "endDate"?: number;
    /**
     * The id of the challenge event
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already 
     */
    "rewardStatus"?: ChallengeEventResourceRewardStatusEnum;
    /**
     * The start date in seconds
     */
    "startDate"?: number;
}

export type ChallengeEventResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface ChallengeResource {
    /**
     * The number of activities allowed to this challenge
     */
    "activities"?: number;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The id of the campaign this challenge is a part of. The challenge must be tied to an active campaign before it will spawn events
     */
    "campaignId"?: number;
    /**
     * The ID of the original challenge it was copied from
     */
    "copyOf"?: number;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The end date of this challenge in seconds since epoch. required if part of a campaign
     */
    "endDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service.
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The next date this challenge will be occur in seconds since epoch
     */
    "nextEventDate"?: number;
    /**
     * The number of minutes minimum to wait at the end of this challenge before running rewards, to allow activities to complete
     */
    "rewardLagMinutes"?: number;
    /**
     * The rewards to give at the end of the challenge. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The repeat schedule for the challenge
     */
    "schedule"?: Schedule;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The start date of this challenge in seconds since epoch. required if part of a campaign
     */
    "startDate"?: number;
    /**
     * A challenge template this challenge is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ChatBlacklistResource {
    /**
     * The user that is blacklisted
     */
    "blacklistedUser"?: SimpleUserResource;
    /**
     * The date the user was blacklisted
     */
    "createdDate"?: number;
    /**
     * The unique ID for this chat message blacklist
     */
    "id"?: string;
    /**
     * The user that has blacklisted someone
     */
    "userId"?: number;
}

export interface ChatMessageRequest {
    /**
     * The content of the message
     */
    "content": any;
    /**
     * The type of the message set by the client
     */
    "messageType": string;
}

export interface ChatMessageResource {
    /**
     * The content of the message
     */
    "content": any;
    /**
     * The date the chat message was created
     */
    "createdDate"?: number;
    /**
     * Whether the message has been edited
     */
    "edited"?: boolean;
    /**
     * The id for this message
     */
    "id"?: string;
    /**
     * The type of the message set by the client
     */
    "messageType": string;
    /**
     * The id of the recipient: user id or topic id
     */
    "recipientId": string;
    /**
     * The recipient type of the message
     */
    "recipientType": ChatMessageResourceRecipientTypeEnum;
    /**
     * The id of the sender
     */
    "senderId"?: number;
    /**
     * The id of the thread
     */
    "threadId"?: string;
    /**
     * The date the chat message was updated
     */
    "updatedDate"?: number;
}

export type ChatMessageResourceRecipientTypeEnum = "user" | "topic";
export interface ChatThreadResource {
    /**
     * The number of active users in the thread
     */
    "activeUsers"?: number;
    /**
     * The number of messages in the thread
     */
    "count"?: number;
    /**
     * The date the thread was created
     */
    "createdDate"?: number;
    /**
     * The id for this thread
     */
    "id"?: string;
    /**
     * The id of the recipient
     */
    "recipientId": string;
    /**
     * The recipient type of the thread
     */
    "recipientType": ChatThreadResourceRecipientTypeEnum;
    /**
     * The subject of the thread
     */
    "subject"?: string;
    /**
     * The date the thread was updated
     */
    "updatedDate"?: number;
}

export type ChatThreadResourceRecipientTypeEnum = "user" | "topic";
export interface ChatUserThreadResource {
    /**
     * The date the user thread was created
     */
    "createdDate"?: number;
    /**
     * The number of messages read in the thread
     */
    "readCount"?: number;
    /**
     * The details about the thread
     */
    "thread"?: ChatThreadResource;
    /**
     * The id of the thread
     */
    "threadId"?: string;
    /**
     * The date the user thread was updated
     */
    "updatedDate"?: number;
    /**
     * The id of the user
     */
    "userId"?: number;
}

export interface ClientResource {
    /**
     * The expiration time of an initial oauth token in seconds
     */
    "accessTokenValiditySeconds"?: number;
    /**
     * The client_id field of the oauth token request
     */
    "clientKey": string;
    /**
     * The oauth grant type as in: password (username/password auth), client_credentials (server-to-server, private clients), refresh_token (to allow clients to refresh their initial token), facebook, google, etc) See documentation for a complete list. Use dedicated endpoint PUT /grant-types to edit this list
     */
    "grantTypes"?: Array<string>;
    /**
     * Generated unique ID for the client
     */
    "id"?: number;
    /**
     * Set to true if the client is public i.e the secret key can be secured
     */
    "isPublic"?: boolean;
    /**
     * Used to flag system clients that are not meant to be tinkered with
     */
    "locked"?: boolean;
    /**
     * The friendly name of the client
     */
    "name": string;
    /**
     * A redirection URL to use when granting access to third-parties (seldomly used)
     */
    "redirectUris"?: Array<string>;
    /**
     * The expiration time of a refresh oauth token in seconds
     */
    "refreshTokenValiditySeconds"?: number;
    /**
     * The client-secret field of the oauth request when creating a private client
     */
    "secret": string;
}

export interface CommentResource {
    /**
     * The comment content of that resource
     */
    "content": string;
    /**
     * The type of object this comment applies to (ex: video, article, etc). Required when passed to /comments
     */
    "context"?: string;
    /**
     * The id of the object this comment applies to.  Required when passed to /comments
     */
    "contextId"?: number;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The summary of that resource
     */
    "summary"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The user who created the comment
     */
    "user"?: SimpleUserResource;
}

export interface Config {
    /**
     * The description of the config.  Max 255 characters
     */
    "description"?: string;
    /**
     * The name of the config
     */
    "name": string;
    /**
     * Whether the config is public for viewing. True means that it can be publicly viewed by all. Default: false
     */
    "publicRead"?: boolean;
    /**
     * The value of the config
     */
    "value"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface ConfigLookupResource {
    "definition"?: string;
    "lookupKey"?: ExpressionResource;
    "requiredKeyType"?: string;
    "type"?: string;
    "valueType"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface ConstantResource {
    "definition"?: string;
    "type"?: string;
    "value"?: any;
    "valueType"?: string;
}

export interface ContributionResource {
    /**
     * A reference to the contributing artist
     */
    "artist": SimpleReferenceResourcelong;
    /**
     * A reference to the media being contributed to
     */
    "media": SimpleReferenceResourcelong;
    /**
     * The nature of the contribution (role of the artist as in 'producer', 'performer', etc)
     */
    "role": string;
}

export interface CoreActivityOccurrenceSettings {
    /**
     * Whether the host can boot another user while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
     */
    "bootInPlay"?: boolean;
    /**
     * A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this occurrence rather than the usual game server. Could be the ip address of the host for peer-to-peer play. Can only be set if the activity/challenge custom_launch_address_allowed is true. Max length: 255
     */
    "customLaunchAddress"?: string;
    /**
     * Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Cannot be true if activity/challenge has it false. Null to inherit
     */
    "hostStatusControl"?: boolean;
    /**
     * Whether users can join while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
     */
    "joinInPlay"?: boolean;
    /**
     * Whether users can leave while the status is PLAYING. Must be false or null unless this setting is true in activity (or challenge if applicable). Null to inherit
     */
    "leaveInPlay"?: boolean;
    /**
     * The maximum number of players the game can hold. Must be equal or less than activity (or must match challenge if applicable)
     */
    "maxPlayers"?: number;
    /**
     * The minimum number of players the game can hold. Must be equal or greater than activity (or must match challenge if applicable)
     */
    "minPlayers"?: number;
    /**
     * Restriction for whether the non-host players can control of the status in place of the host. Default: false
     */
    "nonHostStatusControl"?: boolean;
    /**
     * Restriction for who is able to report game end and results. Admin is always able to send results as well. Must be equal or more restrictive than activity (or must match challenge if applicable). Default inherits
     */
    "resultsTrust"?: CoreActivityOccurrenceSettingsResultsTrustEnum;
}

export type CoreActivityOccurrenceSettingsResultsTrustEnum = "none" | "host" | "all";
export interface CoreActivitySettings {
    /**
     * Whether the host can boot a user while the status is PLAYING. Default false
     */
    "bootInPlay"?: boolean;
    /**
     * Restriction for whether the host creating an occurrence can specify a custom launch address (such as their own ip address). Default 'false'
     */
    "customLaunchAddressAllowed"?: boolean;
    /**
     * Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Default 'player'
     */
    "hostOption"?: CoreActivitySettingsHostOptionEnum;
    /**
     * Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Default 'false'
     */
    "hostStatusControl"?: boolean;
    /**
     * Whether users can join while the status is PLAYING. Default false
     */
    "joinInPlay"?: boolean;
    /**
     * Whether users can leave while the status is PLAYING. Default false
     */
    "leaveInPlay"?: boolean;
    /**
     * The maximum number of players the game can hold
     */
    "maxPlayers"?: number;
    /**
     * The minimum number of players the game can hold
     */
    "minPlayers"?: number;
    /**
     * Restriction for who is able to report game end and results. Admin is always able to send results as well. Default 'none'
     */
    "resultsTrust"?: CoreActivitySettingsResultsTrustEnum;
}

export type CoreActivitySettingsHostOptionEnum = "admin_only" | "player" | "non_player";
export type CoreActivitySettingsResultsTrustEnum = "none" | "host" | "all";
export interface CoreChallengeActivitySettings {
    /**
     * Whether the host can boot a user while the status is PLAYING. Null to inherit from activity
     */
    "bootInPlay"?: boolean;
    /**
     * A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this challenge rather than the usual game server. Max length: 255
     */
    "customLaunchAddress"?: string;
    /**
     * Restriction for whether the host creating an occurrence can specify a custom launch address (such as their own ip address). Will override the challenge's custom_launch_address if they do. Null to inherit from activity
     */
    "customLaunchAddressAllowed"?: boolean;
    /**
     * Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit
     */
    "hostOption"?: CoreChallengeActivitySettingsHostOptionEnum;
    /**
     * Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Max length: 255. Null to inherit from activity
     */
    "hostStatusControl"?: boolean;
    /**
     * Whether users can join while the status is PLAYING. Null to inherit from activity
     */
    "joinInPlay"?: boolean;
    /**
     * Whether users can leave while the status is PLAYING. Null to inherit from activity
     */
    "leaveInPlay"?: boolean;
    /**
     * The maximum number of players the game can hold. Null to inherit from activity
     */
    "maxPlayers"?: number;
    /**
     * The minimum number of players the game can hold. Null to inherit from activity
     */
    "minPlayers"?: number;
    /**
     * Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity
     */
    "resultsTrust"?: CoreChallengeActivitySettingsResultsTrustEnum;
}

export type CoreChallengeActivitySettingsHostOptionEnum = "admin_only" | "player" | "non_player";
export type CoreChallengeActivitySettingsResultsTrustEnum = "none" | "host" | "all";
export interface Country {
    "id"?: number;
    "iso2"?: string;
    "iso3"?: string;
    "name"?: string;
}

export interface CountryResource {
    /**
     * The iso2 of the country
     */
    "iso2"?: string;
    /**
     * The iso3 of the country
     */
    "iso3"?: string;
    /**
     * The name of the country resource
     */
    "name"?: string;
}

export interface CountryTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface CouponDefinition {
    /**
     * A unique identifier for the discount. Can be used to remove the discount, and uniqueness within the cart will be enforced.
     */
    "code": string;
    /**
     * A description for the discount.
     */
    "description"?: string;
    /**
     * The type of discount in terms of how it deducts price.
     */
    "discountType": CouponDefinitionDiscountTypeEnum;
    /**
     * Whether this discount is exclusive and cannot be used in conjunction with other discounts/coupons. default=false
     */
    "exclusive"?: boolean;
    /**
     * For coupon_cart, a minimum total price that the cart must meet to be valid.
     */
    "maxDiscount"?: number;
    /**
     * The maximum number of items to count this discount for (not for cart_coupon).
     */
    "maxQuantity"?: number;
    /**
     * For coupon_cart, a minimum total price that the cart must meet to be valid.
     */
    "minCartTotal"?: number;
    /**
     * A name for the discount.
     */
    "name": string;
    /**
     * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
     */
    "selfExclusive"?: boolean;
    /**
     * The id of the item this discount applies to, which must be present in the cart. Applies if coupon_type_hint is coupon_single_item or coupon_voucher.
     */
    "targetItemId"?: number;
    /**
     * The type of discount in terms of what it applies to. coupon_cart applies to the cart as a whole, other types apply to specific items based on different criteria.
     */
    "type": CouponDefinitionTypeEnum;
    /**
     * A unique identifier string for the discount.
     */
    "uniqueKey": string;
    /**
     * Which tags this applies for (item must have at least one of them), if coupon_type is coupon_tag.
     */
    "validForTags"?: Array<string>;
    /**
     * The amount of the discount. If discount_type is value then this is the raw currency amount to remove. If discount_type is percentage then this will be multiplied by the cart total or item price to get the discount amount (0.5 is half price).
     */
    "value": number;
    /**
     * Which vendor this applies for, if coupon_type is coupon_vendor.
     */
    "vendorId"?: number;
}

export type CouponDefinitionDiscountTypeEnum = "value" | "percentage";
export type CouponDefinitionTypeEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
/**
 * A occurrence of an activity (the actual game for example). Used to track scores, participants, and provide settings
 */
export interface CreateActivityOccurrenceRequest {
    /**
     * The id of the activity, only needed when outside of challenge/event
     */
    "activityId"?: number;
    /**
     * The id of the challenge activity (required if playing in a challenge/event). Note that this is the challenge_activity_id in case the same activity apears twice in the challenge.
     */
    "challengeActivityId"?: number;
    /**
     * Defines core settings about the activity that affect how it can be created/played by users.
     */
    "coreSettings"?: CoreActivityOccurrenceSettings;
    /**
     * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
     */
    "entitlement"?: ItemIdRequest;
    /**
     * The id of the event this occurence is a part of, if any
     */
    "eventId"?: number;
    /**
     * The host of the occurrence, if not a participant (will be left out of users array). Must be the caller that creates the occurrence unless admin. Requires activity/challenge to allow host_option of 'non_player' if not admin as well
     */
    "host"?: number;
    /**
     * The values selected from the available settings defined for the activity. Ex: difficulty: hard. Can be left out if the activity is played during an event and the settings are already set at the event level. Ex: every monday, difficulty: hard, number of questions: 10, category: sport. Otherwise, the set must exactly match those of the activity.
     */
    "settings"?: Array<SelectedSettingRequest>;
    /**
     * Whether this occurrence will be ran as a simulation. Simulations will not be rewarded. Useful for bot play or trials
     */
    "simulated"?: boolean;
    /**
     * The current status of the occurrence (default: SETUP).
     */
    "status"?: CreateActivityOccurrenceRequestStatusEnum;
    /**
     * The list of users participating in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
     */
    "users"?: Array<Participant>;
}

export type CreateActivityOccurrenceRequestStatusEnum = "SETUP" | "OPEN" | "LAUNCHING" | "PLAYING" | "FINISHED" | "ABANDONED";
export interface CreateBillingAgreementRequest {
    /**
     * The endpoint URL to which PayPal should forward the user if they cancel (do not accept) the agreement
     */
    "cancelUrl": string;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept the agreement. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface CreatePayPalPaymentRequest {
    /**
     * The endpoint URL to which PayPal should forward the user to if they cancel the checkout process
     */
    "cancelUrl": string;
    /**
     * The ID of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
}

export interface CurrencyResource {
    /**
     * Whether the currency is active. Default true
     */
    "active"?: boolean;
    /**
     * The unique id code for the currency. Maximum 5 characters
     */
    "code": string;
    /**
     * The unix timestamp in seconds the currency was added to the system
     */
    "createdDate"?: number;
    /**
     * Whether this is the default currency. All real money wallets will be in this currency, and the 'factor' on each currency is in relation to the default. There must be one default currency and the current will be changed if you set another as the default. Cannot be combined with virtual currency. Take extreme caution when changing
     */
    "defaultCurrency"?: boolean;
    /**
     * The decimal to multiply the default currency to localize to this one. Should be 1 for the default currency itself.
     */
    "factor": number;
    /**
     * The url for an icon of the currency
     */
    "icon"?: string;
    /**
     * The name of the currency
     */
    "name": string;
    /**
     * The type of currency. Default 'real'
     */
    "type"?: CurrencyResourceTypeEnum;
    /**
     * The unix timestamp in seconds the currency was last updated in the system.
     */
    "updatedDate"?: number;
}

export type CurrencyResourceTypeEnum = "real" | "virtual";
export interface CustomerConfig {
    "aliases"?: string;
    "database"?: DatabaseConfig;
    "name"?: string;
    "s3Config"?: S3Config;
}

export interface DatabaseConfig {
    "mongo"?: MongoDatabaseConfig;
    "sql"?: SqlDatabaseConfig;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface DateOperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface DefaultOperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface DeltaResource {
    /**
     * The id of the category for question
     */
    "categoryId"?: string;
    /**
     * The media type of the question
     */
    "mediaType"?: string;
    /**
     * The id of the question
     */
    "questionId"?: string;
    /**
     * Whether the question was updated or removed
     */
    "state"?: DeltaResourceStateEnum;
    /**
     * The tags for the question
     */
    "tags"?: Array<string>;
    /**
     * The date this question was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type DeltaResourceStateEnum = "UPDATED" | "REMOVED";
export interface DeviceResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template if one is specified
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the device log was created
     */
    "createdDate"?: number;
    /**
     * The description of the device
     */
    "description"?: string;
    /**
     * The type of device. Use mobile_device to specifically register mobile devices. This particular type will be used to send and receive notifications
     */
    "deviceType"?: string;
    /**
     * The unique ID for this device. Cannot be changed after creation. Default: random
     */
    "id"?: string;
    /**
     * The physical location of the device, coordinates or named place (office, living room, etc)
     */
    "location"?: string;
    /**
     * The MAC (media access control) address of the device
     */
    "macAddress"?: string;
    /**
     * The make of the device
     */
    "make"?: string;
    /**
     * The model of the device
     */
    "model"?: string;
    /**
     * The name of the device
     */
    "name"?: string;
    /**
     * The OS (operating system) on the device
     */
    "os"?: string;
    /**
     * The user that owns the device
     */
    "owner"?: SimpleUserResource;
    /**
     * The serial number of the device
     */
    "serial"?: string;
    /**
     * Random tags to facilitate search
     */
    "tags"?: Array<string>;
    /**
     * Use to describe and validate custom properties (custom schema). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date the device log was updated
     */
    "updatedDate"?: number;
    /**
     * The users currently using the device
     */
    "users"?: Array<SimpleUserResource>;
}

export interface Discount {
    "description"?: string;
    "name"?: string;
    "sku"?: string;
    "uniqueKey"?: string;
    "value"?: number;
}

export interface DispositionCount {
    /**
     * The number of users that have expressed this disposition
     */
    "count"?: number;
    /**
     * The name of the disposition this count is for
     */
    "name"?: string;
}

export interface DispositionResource {
    /**
     * The context of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "context"?: string;
    /**
     * The context_id of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The name of the disposition, 1-20 characters. (ex: like/dislike/favorite, etc)
     */
    "name": string;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface DoubleOperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface EntitlementGrantRequest {
    /**
     * The ID of the entitlement item to grant
     */
    "entitlementId": number;
}

export interface ErrorResource {
    /**
     * Extra details about the error, if needed
     */
    "details"?: any;
    /**
     * The JSON key the message pertains to
     */
    "field"?: any;
    /**
     * The message explaining the error
     */
    "message"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface EventContextResource {
    "definition"?: string;
    "eventName"?: string;
    "parameters"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface ExpressionResource {
    "definition"?: string;
    "type"?: string;
}

export interface Expressionobject {
}

export interface FacebookToken {
    /**
     * A valid access token from facebook. See facebook documention for how to obtain one.
     */
    "accessToken": string;
}

export interface FattMerchantPaymentMethod {
    "address1"?: string;
    "address2"?: string;
    "addressCity"?: string;
    "addressCountry"?: string;
    "addressState"?: string;
    "addressZip"?: string;
    /**
     * Last four digits of the credit card
     */
    "cardLastFour": string;
    "createdAt"?: string;
    /**
     * Unique FattMerchant customer ID
     */
    "customerId": string;
    "deletedAt"?: string;
    "id"?: string;
    /**
     * Nickname given to the FattMerchant payment method
     */
    "nickname": string;
    "updatedAt"?: string;
}

export interface FattMerchantPaymentMethodRequest {
    /**
     * The FattMerchant payment method being created/updated
     */
    "method": FattMerchantPaymentMethod;
    /**
     * ID of the JSAPI user for whom the payment method is being created/updated. If ID is not that of the currently logged in user, FATMMERCHANT_ADMIN privilege is required. If ID is null, will use the currently logged in user's ID.
     */
    "userId"?: number;
}

export interface FinalizeBillingAgreementRequest {
    /**
     * The ID of the invoice being paid along with the creation of this agreement
     */
    "invoiceId"?: number;
    /**
     * Whether the new payment method created should be the user's default
     */
    "newDefault"?: boolean;
    /**
     * The payer ID from PayPal (passed as a parameter in the return URL). Only required if an invoice ID was included
     */
    "payerId"?: string;
    /**
     * The token from PayPal (passed as a parameter in the return URL)
     */
    "token": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface FinalizePayPalPaymentRequest {
    /**
     * The ID of the invoice that is being paid. Must match the invoice sent in originally
     */
    "invoiceId": number;
    /**
     * The ID of the payer that PayPal returned with the user at the return URL
     */
    "payerId": string;
    /**
     * The token that PayPal returned with the user in the return URL
     */
    "token": string;
}

export interface FlagReportResource {
    /**
     * The context of that resource 
     */
    "context"?: string;
    /**
     * The context ID of that resource
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The reason of that resource required only in case of active resolution
     */
    "reason"?: string;
    /**
     * The resolution of that resource
     */
    "resolution": FlagReportResourceResolutionEnum;
    /**
     * The date/time this report was resolved in seconds since epoch. Null if not resolved yet
     */
    "resolved"?: number;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
}

export type FlagReportResourceResolutionEnum = "banned" | "ignored";
export interface FlagResource {
    /**
     * The context of that resource
     */
    "context": string;
    /**
     * The context_id of that resource
     */
    "contextId": string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The flag reason of that resource
     */
    "reason"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The basic user resource
     */
    "user"?: SimpleUserResource;
}

export interface ForwardLog {
    /**
     * The end date of the forward log entry
     */
    "endDate"?: number;
    "errorMsg"?: string;
    "eventId"?: string;
    "headers"?: string;
    /**
     * The http status code the forward log entry
     */
    "httpStatusCode"?: number;
    /**
     * The id of the forward log entry
     */
    "id"?: string;
    "method"?: string;
    /**
     * The payload of the forward log entry
     */
    "payload"?: any;
    /**
     * The response string of the forward log entry
     */
    "response"?: string;
    /**
     * The retry count of the forward log entry
     */
    "retryCount"?: number;
    "retryable"?: boolean;
    "ruleId"?: string;
    /**
     * The start date of the forward log entry
     */
    "startDate"?: number;
    "success"?: boolean;
    /**
     * The endpoint url of the forward log entry
     */
    "url"?: string;
}

export interface FulfillmentType {
    /**
     * Whether the type is core and cannot be altered/deleted, read-only
     */
    "core"?: boolean;
    /**
     * A description of the type
     */
    "description"?: string;
    /**
     * The unique id of the type, read-only
     */
    "id"?: number;
    /**
     * The name of the type
     */
    "name": string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface GlobalCheckAndIncrementResource {
    "checkValueResource"?: ExpressionResource;
    "definition"?: string;
    "globalResource"?: ExpressionResource;
    "type"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface GlobalResource {
    "definition"?: string;
    "globalDefId"?: string;
    "scopes"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

export interface GoogleToken {
    /**
     * A valid authorization code from google. See google documention for how to obtain one.
     */
    "authorizationCode": string;
}

export interface GrantTypeResource {
    /**
     * The description of the grant type
     */
    "description"?: string;
    /**
     * The name of the grant type
     */
    "name"?: string;
}

export interface GroupMemberResource {
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The group. Id is the unique name
     */
    "group"?: SimpleGroupResource;
    /**
     * Whether this membership is explicit (the user was added directly to the group) or implicit (the user was added only to one or more child groups)
     */
    "implicit"?: boolean;
    /**
     * The id of the membership entry
     */
    "membershipId"?: number;
    /**
     * The position of the member in the group if applicable. Read notes for details
     */
    "order"?: string;
    /**
     * The member's access level. Default: member
     */
    "status"?: GroupMemberResourceStatusEnum;
    /**
     * A template this member additional properties are validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export type GroupMemberResourceStatusEnum = "moderator" | "member";
export interface GroupMemberStatusWrapper {
    "value"?: GroupMemberStatusWrapperValueEnum;
}

export type GroupMemberStatusWrapperValueEnum = "moderator" | "member";
export interface GroupResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * A description of the group
     */
    "description"?: string;
    /**
     * The number of users in the group
     */
    "memberCount"?: number;
    /**
     * A message of the day for members of the group
     */
    "messageOfTheDay"?: string;
    /**
     * The name of the group. Max 50 characters
     */
    "name": string;
    /**
     * The unique name of another group that this group is a subset of
     */
    "parent"?: string;
    /**
     * The status which describes whether other users can freely join the group or not
     */
    "status": GroupResourceStatusEnum;
    /**
     * The number of users in child groups
     */
    "subMemberCount"?: number;
    /**
     * Tags for search
     */
    "tags"?: Array<string>;
    /**
     * A group template this group is validated against. May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created. Default: random UUID
     */
    "uniqueName"?: string;
}

export type GroupResourceStatusEnum = "open" | "closed";
export interface IdRef {
    "id"?: number;
}

export interface ImportJobOutputResource {
    /**
     * The description of the import job
     */
    "description"?: string;
    /**
     * The line number of the import job
     */
    "lineNumber"?: number;
}

export interface ImportJobResource {
    /**
     * The id of the category to assign all questions in the import to
     */
    "categoryId": string;
    /**
     * The date the job was created in seconds since unix epoc
     */
    "createdDate"?: number;
    /**
     * The id of the job
     */
    "id"?: number;
    /**
     * A name for this import for later reference
     */
    "name": string;
    /**
     * Error information from validation
     */
    "output"?: Array<ImportJobOutputResource>;
    /**
     * The number of questions form the CSV file. Filled in after validation
     */
    "recordCount"?: number;
    /**
     * The status of the job
     */
    "status"?: ImportJobResourceStatusEnum;
    /**
     * The date the job was last updated in seconds since unix epoc
     */
    "updatedDate"?: number;
    /**
     * The url of a CSV file to pull trivia questions from. Cannot be changed after initial POST
     */
    "url": string;
    /**
     * The vendor who supplied this set of questions
     */
    "vendor": string;
}

export type ImportJobResourceStatusEnum = "PENDING_VALIDATION" | "VALIDATING" | "VALID" | "INVALID" | "PENDING_PROCESS" | "PROCESSING" | "PROCESSED" | "FAILED";
export interface IntWrapper {
    "value"?: number;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface IntegerOperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface InventoryStatusWrapper {
    "value"?: InventoryStatusWrapperValueEnum;
}

export type InventoryStatusWrapperValueEnum = "pending" | "active" | "inactive";
export interface InventorySubscriptionResource {
    /**
     * The date the subscription will be billed
     */
    "billDate"?: number;
    /**
     * A credit of money already applied to a subscription for the next bill, or a debt if negative
     */
    "credit"?: number;
    /**
     * A record of past and present credit/debt changes
     */
    "creditLog"?: Array<SubscriptionCreditResource>;
    /**
     * The date the grace period ends
     */
    "graceEnd"?: number;
    /**
     * The id of the inventory
     */
    "inventoryId"?: number;
    /**
     * The inventory status object
     */
    "inventoryStatus"?: InventorySubscriptionResourceInventoryStatusEnum;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The payment method object
     */
    "paymentMethod"?: PaymentMethodResource;
    /**
     * The recurring price that has been set to override the base price. Null if not overriding
     */
    "priceOverride"?: number;
    /**
     * An explanation for the reason the price is being overridden
     */
    "priceOverrideReason"?: string;
    /**
     * The default recurring price
     */
    "recurringPrice"?: number;
    /**
     * The recurring sku of the subscription
     */
    "sku"?: string;
    /**
     * The date the subscription will start
     */
    "startDate"?: number;
    /**
     * The status of the subscription
     */
    "subscriptionStatus"?: number;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

export type InventorySubscriptionResourceInventoryStatusEnum = "pending" | "active" | "inactive";
export interface InvoiceCreateRequest {
    /**
     * The guid of a cart to create a new invoice for
     */
    "cartGuid": string;
}

export interface InvoiceItemResource {
    "bundleSku"?: string;
    "currentFulfillmentStatus"?: string;
    "id"?: number;
    "invoiceId"?: number;
    "itemId"?: number;
    "itemName"?: string;
    "originalTotalPrice"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "systemPrice"?: number;
    "totalPrice"?: number;
    "typeHint"?: string;
    "unitPrice"?: number;
}

export interface InvoiceLogEntry {
    /**
     * The date this event occurred as a unix timestamp in seconds
     */
    "date"?: number;
    /**
     * The ID of the invoice
     */
    "invoiceId"?: number;
    /**
     * A message describing the event
     */
    "message"?: string;
    /**
     * The type of event
     */
    "type"?: string;
}

export interface InvoicePaymentStatusRequest {
    /**
     * If included, will set the payment method used on the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The new status for the invoice. Additional options may be available based on configuration.  Allowable values: 'new', 'paid', 'hold', 'canceled', 'payment failed', 'partial refund', 'refund'
     */
    "status": string;
}

export interface InvoiceResource {
    /**
     * Line one of the customer's billing address
     */
    "billingAddress1"?: string;
    /**
     * Line two of the customer's billing address
     */
    "billingAddress2"?: string;
    /**
     * The city for the customer's billing address
     */
    "billingCityName"?: string;
    /**
     * The country for the customer's billing address
     */
    "billingCountryName"?: string;
    /**
     * The customer's name for the billing address
     */
    "billingFullName"?: string;
    /**
     * The postal code for the customer's billing address
     */
    "billingPostalCode"?: string;
    /**
     * The state for the customer's billing address
     */
    "billingStateName"?: string;
    /**
     * The guid of the cart this invoice came from
     */
    "cartId"?: string;
    /**
     * The date the invoice was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The code for the currency invoice prices are in
     */
    "currency"?: string;
    /**
     * The fulfillment status of the invoice
     */
    "currentFulfillmentStatus"?: string;
    /**
     * The payment status of the invoice
     */
    "currentPaymentStatus"?: string;
    /**
     * The amount of money saved through coupons
     */
    "discount"?: number;
    /**
     * The customer's email address
     */
    "email"?: string;
    /**
     * An external reference to filter on
     */
    "externalRef"?: string;
    /**
     * The amount of federal tax added
     */
    "fedTax"?: number;
    /**
     * The final price of the invoice
     */
    "grandTotal"?: number;
    /**
     * The id of the invoice
     */
    "id"?: number;
    /**
     * A reference number for the invoice
     */
    "invoiceNumber"?: string;
    /**
     * A list of items within the invoice
     */
    "items"?: Array<InvoiceItemResource>;
    /**
     * The customer's name prefix
     */
    "namePrefix"?: string;
    /**
     * Notes about the order
     */
    "orderNotes"?: string;
    /**
     * The id of an invoice this is a child of
     */
    "parentInvoiceId"?: number;
    /**
     * The id of a saved payment method used to pay for the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The customer's phone number
     */
    "phone"?: string;
    /**
     * The customer's phone number
     */
    "phoneNumber"?: string;
    /**
     * The remaining price of the invoice (after any payments made so far)
     */
    "remainingBalance"?: number;
    /**
     * The shipping cost
     */
    "shipping"?: number;
    /**
     * Line one of the customer's shipping address
     */
    "shippingAddress1"?: string;
    /**
     * Line two of the customer's shipping address
     */
    "shippingAddress2"?: string;
    /**
     * The city for the customer's shipping address
     */
    "shippingCityName"?: string;
    /**
     * The country for the customer's shipping address
     */
    "shippingCountryName"?: string;
    /**
     * The customer's name for the shipping address
     */
    "shippingFullName"?: string;
    /**
     * The postal code for the customer's shipping address
     */
    "shippingPostalCode"?: string;
    /**
     * The state for the customer's shipping address
     */
    "shippingStateName"?: string;
    /**
     * A number to use in sorting items. default 500.
     */
    "sort"?: number;
    /**
     * The amount of state tax added
     */
    "stateTax"?: number;
    /**
     * The sum price of all items before shipping, coupons and tax
     */
    "subtotal"?: number;
    /**
     * The date the invoice was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The owner of the invoice
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the vendor
     */
    "vendorId"?: number;
    /**
     * The name of the invoice
     */
    "vendorName"?: string;
}

export interface Item {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface ItemBehaviorDefinitionResource {
    /**
     * The default version of the behavior
     */
    "behavior": Behavior;
    /**
     * Whether the behavior's values can be modified
     */
    "modifiable": boolean;
    /**
     * Whether the behavior can be removed
     */
    "required": boolean;
}

export interface ItemIdRequest {
    "itemId"?: number;
}

export interface ItemTemplateResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface KeyValuePairstringstring {
    "key"?: string;
    "value"?: string;
}

export interface LeaderboardEntryResource {
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * The date this score was recorded or updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface LeaderboardResource {
    /**
     * The paginated list of user results, in order from best to worst
     */
    "entries"?: Array<LeaderboardEntryResource>;
    /**
     * The id of the leaderboard
     */
    "id"?: number;
    /**
     * The name of the strategy that defines how entries are stored and compared
     */
    "strategy"?: string;
}

export interface LevelingResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the leveling schema was created
     */
    "createdDate"?: number;
    /**
     * The description of the leveling schema
     */
    "description"?: string;
    /**
     * The name of the leveling schema.  IMMUTABLE
     */
    "name": string;
    /**
     * A set of tiers that contain experience boundaries
     */
    "tiers"?: Array<TierResource>;
    /**
     * The name of an event that will add one progress to this level when fired
     */
    "triggerEventName"?: string;
    /**
     * The date the leveling schema was updated
     */
    "updatedDate"?: number;
}

export interface LimitedGettableGroup {
    /**
     * Whether to get active items only
     */
    "activeOnly": boolean;
    /**
     * The name of the group. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that owned_limit and active_only will be the same for all, but this is not enforced and the item being recieved will use its settings.
     */
    "name"?: string;
    /**
     * The max number of items that can be purchased
     */
    "ownedLimit": number;
}

export interface LocationLogResource {
    "country"?: string;
    "ip"?: string;
    "time"?: number;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface LookupResource {
    "definition"?: string;
    "lookupKey"?: ExpressionResource;
    "requiredKeyType"?: string;
    "type"?: string;
    "valueType"?: string;
}

export interface Maintenance {
    /**
     * Whether access to the system has been locked
     */
    "accessLocked": boolean;
    /**
     * A simple object of any schema for client side use and processing
     */
    "details"?: any;
    /**
     * User displayable message about the maintenance
     */
    "message": string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface MapResource {
    "definition"?: string;
    "map"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

export interface MessageContentResource {
    /**
     * The content of the email
     */
    "email"?: string;
    /**
     * The content of the mobile app push notification
     */
    "push"?: string;
    /**
     * The content of the sms
     */
    "sms"?: string;
    /**
     * The content of the templated email
     */
    "templatedEmail"?: TemplatedEmail;
    /**
     * The content of the websocket message
     */
    "websocket"?: any;
}

export interface MessageResource {
    /**
     * The content of the message in various formats
     */
    "content": MessageContentResource;
    /**
     * The id of the recipient, dependent on the recipient_type. The user's id or the topic's id. Required if sending directly to messaging service
     */
    "recipient"?: string;
    /**
     * The type of recipient for the message. Either a user, or all users in a topic. Required if sending directly to messaging service
     */
    "recipientType"?: MessageResourceRecipientTypeEnum;
    /**
     * The subject of the message. Required for email messages
     */
    "subject"?: string;
    /**
     * The type of message for websocket type hinting. will be added to the payload with the key _type
     */
    "type"?: string;
}

export type MessageResourceRecipientTypeEnum = "user" | "topic";
export interface MessageTemplateBulkRequest {
    /**
     * The data to fill the templates with
     */
    "data": any;
    /**
     * A list of message template ids
     */
    "ids": Array<string>;
}

export interface MessageTemplateResource {
    /**
     * The content of the template. See Apache Velocity documentation for formatting
     */
    "content": string;
    /**
     * The id of the template. Cannot be changed after creation. default: auto generated
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * A list of tags for search purposes. Will be converted to lower case
     */
    "tags"?: Array<string>;
}

export interface MetricResource {
    /**
     * The id of the activity occurence where this score/metric occurred
     */
    "activityOccurenceId": number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 10 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The id of the user this metric is for. Default to caller and requires METRICS_ADMIN permission to specify another
     */
    "userId"?: number;
    /**
     * The value/score of the metric
     */
    "value": number;
}

export interface MongoDatabaseConfig {
    "dbName"?: string;
    "options"?: string;
    "password"?: string;
    "servers"?: string;
    "username"?: string;
}

export interface NestedCategory {
    /**
     * Whether the category is active
     */
    "active"?: boolean;
    /**
     * The id of the category
     */
    "id": string;
    /**
     * The name of the category
     */
    "name"?: string;
}

export interface NewPasswordRequest {
    /**
     * The new password in plain text
     */
    "password": string;
    /**
     * The secret provided after the password reset
     */
    "secret": string;
}

export interface NotificationResource {
    /**
     * The data to send to websockets. Also used to fill in the templates
     */
    "data"?: any;
    /**
     * The id of this individual notification. Default: random
     */
    "notificationId"?: string;
    /**
     * The id of the notification type which will define message templates
     */
    "notificationTypeId": string;
    /**
     * The id of the recipient, dependent on the recipient_type. The user's id or the topic's id
     */
    "recipient": string;
    /**
     * The type of recipient for the notification. Either a user, or all users in a topic
     */
    "recipientType": NotificationResourceRecipientTypeEnum;
    /**
     * The date this notification was sent
     */
    "sendDate"?: number;
}

export type NotificationResourceRecipientTypeEnum = "user" | "topic";
export interface NotificationTypeResource {
    /**
     * The date the type was created, as a unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether the email body should be resolved. If true, the external email delivery system will be expected to handle the templating (Mandrill/Mailchimp). default: false
     */
    "emailBodyTemplateExternal"?: boolean;
    /**
     * The id of a message template to resolve the email body. If null, no websocket message wil be sent
     */
    "emailBodyTemplateId"?: string;
    /**
     * The id of a message template to resolve the email subject. If null, no websocket message wil be sent
     */
    "emailSubjectTemplateId"?: string;
    /**
     * The id of the notification type. Default: random
     */
    "id"?: string;
    /**
     * The name of the notification type
     */
    "name": string;
    /**
     * The id of a message template to resolve the SMS message. If null, no sms message wil be sent
     */
    "smsTemplateId"?: string;
    /**
     * The date the type was last updated, as a unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface NotificationUserTypeResource {
    /**
     * Whether the user has muted direct notification of this type. Notifications can still be retrieved via the api
     */
    "silenced"?: boolean;
    /**
     * The notification type id
     */
    "type"?: string;
    /**
     * The user's id
     */
    "userId"?: number;
}

export interface OAuth2Resource {
    /**
     * The access token issued by the authorization server
     */
    "accessToken"?: string;
    /**
     * The lifetime in seconds of the access token
     */
    "expiresIn"?: string;
    /**
     * The refresh token issued by the authorization server
     */
    "refreshToken"?: string;
    /**
     * The scope of the access token. Currently these values can be ignored, as security defaults to roles and permissions
     */
    "scope"?: string;
    /**
     * The type of the token issued
     */
    "tokenType"?: string;
}

export interface OauthAccessTokenResource {
    /**
     * The key of the client assosciated with the token
     */
    "clientId"?: string;
    /**
     * The token.  Not shown in list view
     */
    "token"?: string;
    /**
     * The username of the user associated with the token
     */
    "username"?: string;
}

export interface ObjectResource {
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A map of additional data. The template will define requirements for the object
     */
    "data"?: any;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface OperationDefinitionResource {
    "arguments"?: Array<ArgumentResource>;
    "description"?: string;
    "operator"?: Operator;
    "returnType"?: string;
    "template"?: string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface OperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface Operator {
}

export interface OptimalPaymentRequest {
    /**
     * The email address of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The url to redirect the user to after declining payment
     */
    "onDecline": string;
    /**
     * The url to redirect the user to after an error in payment
     */
    "onError": string;
    /**
     * The url to redirect the user to after successful payment
     */
    "onSuccess": string;
}

export interface Order {
    "ascending"?: boolean;
    "descending"?: boolean;
    "direction"?: OrderDirectionEnum;
    "ignoreCase"?: boolean;
    "nullHandling"?: OrderNullHandlingEnum;
    "property"?: string;
}

export type OrderDirectionEnum = "ASC" | "DESC";
export type OrderNullHandlingEnum = "NATIVE" | "NULLS_FIRST" | "NULLS_LAST";
export interface PageResourceAchievementDefinitionResource {
    "content"?: Array<AchievementDefinitionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceActivityOccurrenceResource {
    "content"?: Array<ActivityOccurrenceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateCountResource {
    "content"?: Array<AggregateCountResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateInvoiceReportResource {
    "content"?: Array<AggregateInvoiceReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArticleResource {
    "content"?: Array<ArticleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArtistResource {
    "content"?: Array<ArtistResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareActivityResource {
    "content"?: Array<BareActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareChallengeActivityResource {
    "content"?: Array<BareChallengeActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBillingReport {
    "content"?: Array<BillingReport>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreEventLog {
    "content"?: Array<BreEventLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreGlobalResource {
    "content"?: Array<BreGlobalResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreRule {
    "content"?: Array<BreRule>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreTriggerResource {
    "content"?: Array<BreTriggerResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCampaignResource {
    "content"?: Array<CampaignResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCartSummary {
    "content"?: Array<CartSummary>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCatalogSale {
    "content"?: Array<CatalogSale>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCategoryResource {
    "content"?: Array<CategoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventParticipantResource {
    "content"?: Array<ChallengeEventParticipantResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventResource {
    "content"?: Array<ChallengeEventResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeResource {
    "content"?: Array<ChallengeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChatMessageResource {
    "content"?: Array<ChatMessageResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChatUserThreadResource {
    "content"?: Array<ChatUserThreadResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceClientResource {
    "content"?: Array<ClientResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCommentResource {
    "content"?: Array<CommentResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceConfig {
    "content"?: Array<Config>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCountryTaxResource {
    "content"?: Array<CountryTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCurrencyResource {
    "content"?: Array<CurrencyResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDeviceResource {
    "content"?: Array<DeviceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDispositionResource {
    "content"?: Array<DispositionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceEntitlementItem {
    "content"?: Array<EntitlementItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFlagReportResource {
    "content"?: Array<FlagReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFlagResource {
    "content"?: Array<FlagResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceForwardLog {
    "content"?: Array<ForwardLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFulfillmentType {
    "content"?: Array<FulfillmentType>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupMemberResource {
    "content"?: Array<GroupMemberResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupResource {
    "content"?: Array<GroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceImportJobResource {
    "content"?: Array<ImportJobResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceLogEntry {
    "content"?: Array<InvoiceLogEntry>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceResource {
    "content"?: Array<InvoiceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceItemTemplateResource {
    "content"?: Array<ItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLevelingResource {
    "content"?: Array<LevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLocationLogResource {
    "content"?: Array<LocationLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceMessageTemplateResource {
    "content"?: Array<MessageTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceNotificationTypeResource {
    "content"?: Array<NotificationTypeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceNotificationUserTypeResource {
    "content"?: Array<NotificationUserTypeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceOauthAccessTokenResource {
    "content"?: Array<OauthAccessTokenResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceObjectResource {
    "content"?: Array<ObjectResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePaymentMethodTypeResource {
    "content"?: Array<PaymentMethodTypeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePermissionResource {
    "content"?: Array<PermissionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePollResource {
    "content"?: Array<PollResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionResource {
    "content"?: Array<QuestionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionTemplateResource {
    "content"?: Array<QuestionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueCountryReportResource {
    "content"?: Array<RevenueCountryReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueProductReportResource {
    "content"?: Array<RevenueProductReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRewardSetResource {
    "content"?: Array<RewardSetResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRoleResource {
    "content"?: Array<RoleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSavedAddressResource {
    "content"?: Array<SavedAddressResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleReferenceResourceobject {
    "content"?: Array<SimpleReferenceResourceobject>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleUserResource {
    "content"?: Array<SimpleUserResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleWallet {
    "content"?: Array<SimpleWallet>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStateTaxResource {
    "content"?: Array<StateTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItem {
    "content"?: Array<StoreItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItemTemplateResource {
    "content"?: Array<StoreItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionResource {
    "content"?: Array<SubscriptionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionTemplateResource {
    "content"?: Array<SubscriptionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTemplateResource {
    "content"?: Array<TemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTopicResource {
    "content"?: Array<TopicResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTransactionResource {
    "content"?: Array<TransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUsageInfo {
    "content"?: Array<UsageInfo>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserAchievementGroupResource {
    "content"?: Array<UserAchievementGroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserActionLog {
    "content"?: Array<UserActionLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserBaseResource {
    "content"?: Array<UserBaseResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserInventoryResource {
    "content"?: Array<UserInventoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserItemLogResource {
    "content"?: Array<UserItemLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserLevelingResource {
    "content"?: Array<UserLevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserNotificationResource {
    "content"?: Array<UserNotificationResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserRelationshipResource {
    "content"?: Array<UserRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVendorResource {
    "content"?: Array<VendorResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoRelationshipResource {
    "content"?: Array<VideoRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoResource {
    "content"?: Array<VideoResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTotalResponse {
    "content"?: Array<WalletTotalResponse>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTransactionResource {
    "content"?: Array<WalletTransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcestring {
    "content"?: Array<string>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface ParameterResource {
    "definition"?: string;
    "of"?: string;
    "type"?: string;
    "value"?: any;
}

export interface Participant {
    /**
     * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
     */
    "host"?: boolean;
    /**
     * The current status of the user in the occurrence (default: present)
     */
    "status"?: ParticipantStatusEnum;
    /**
     * The user
     */
    "user": IdRef;
}

export type ParticipantStatusEnum = "present" | "ready" | "left" | "surrendered" | "disconnected";
/**
 * A request to reset a user's password by using a known user property
 */
export interface PasswordResetRequest {
    /**
     * The user's email address
     */
    "email"?: string;
    /**
     * The user's mobile phone number
     */
    "mobileNumber"?: string;
    /**
     * The user's username
     */
    "username"?: string;
}

export interface PayBySavedMethodRequest {
    /**
     * The id of the payment method to use. Must belong to the caller, be public or have PAYMENTS_ADMIN permission
     */
    "paymentMethod": number;
    /**
     * The id of a user to bill. Must have PAYMENTS_ADMIN permission
     */
    "userId"?: number;
}

export interface PaymentAuthorizationResource {
    /**
     * Whether this authorization has been captured
     */
    "captured"?: boolean;
    /**
     * The date this authorization was received, unix timestamp in seconds
     */
    "created"?: number;
    /**
     * The details for this authorization. Format dependent on payment provider
     */
    "details"?: any;
    /**
     * The id of the authorization
     */
    "id"?: number;
    /**
     * The invoice this authorization is intended to pay
     */
    "invoice"?: number;
    /**
     * The payment type (which provider) this payment is through
     */
    "paymentType": SimpleReferenceResourceint;
}

export interface PaymentMethodDetails {
    "default"?: boolean;
    /**
     * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
     */
    "expirationDate"?: number;
    /**
     * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
     */
    "expirationMonth"?: number;
    /**
     * The expiration year for the payment method. Typically used for credit card payment methods
     */
    "expirationYear"?: number;
    /**
     * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
     */
    "last4"?: string;
    /**
     * The sort value for the payment method
     */
    "sort"?: number;
    /**
     * An optional unique identifier
     */
    "uniqueKey"?: string;
    "verified"?: boolean;
}

export interface PaymentMethodResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    "default"?: boolean;
    /**
     * Whether this payment method is disabled or not
     */
    "disabled"?: boolean;
    /**
     * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
     */
    "expirationDate"?: number;
    /**
     * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
     */
    "expirationMonth"?: number;
    /**
     * The expiration year for the payment method. Typically used for credit card payment methods
     */
    "expirationYear"?: number;
    /**
     * The unique ID of the resource
     */
    "id"?: number;
    /**
     * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
     */
    "last4"?: string;
    /**
     * The user friendly name of the resource
     */
    "name": string;
    /**
     * The type of payment method. Must be a pre-existing value
     */
    "paymentMethodType": PaymentMethodTypeResource;
    /**
     * The generic payment type. Default is card
     */
    "paymentType"?: PaymentMethodResourcePaymentTypeEnum;
    /**
     * The sort value for the payment method
     */
    "sort"?: number;
    /**
     * The unique token for the payment method
     */
    "token"?: string;
    /**
     * An optional unique identifier
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user's id. If null, indicates a shared payment method that any user can use (i.e., 'wallet')
     */
    "userId"?: number;
    "verified"?: boolean;
}

export type PaymentMethodResourcePaymentTypeEnum = "card" | "bank_account";
export interface PaymentMethodTypeResource {
    /**
     * The id of the payment method type
     */
    "id": number;
    /**
     * The maximum timelimit in hours for an invoice in the processing status while waiting on this payment method type. Defaults to the global config invoice.processing_expiration_hours if null
     */
    "invoiceProcessingHours"?: number;
    /**
     * The name of the payment method type
     */
    "name": string;
    /**
     * Whether the payment handler supports the authorize and capture flow
     */
    "supportsCapture"?: boolean;
    /**
     * Whether the payment handler supports paying for part of an invoice, rather than the full grand_total
     */
    "supportsPartial"?: boolean;
    /**
     * Whether the payment handler supports rebilling the method later (for saved payments or subscriptions)
     */
    "supportsRebill"?: boolean;
    /**
     * Whether the payment handler supports refunding
     */
    "supportsRefunds"?: boolean;
}

export interface PermissionResource {
    /**
     * The date the permission was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The description of the permission
     */
    "description"?: string;
    /**
     * Whether a permission is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the permission used for display purposes
     */
    "name": string;
    /**
     * The name of the parent of the permission
     */
    "parent"?: string;
    /**
     * The keyword that defines the permission
     */
    "permission": string;
    /**
     * The date the permission was updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface PollAnswerResource {
    /**
     * The number of users that selected this answer
     */
    "count"?: number;
    /**
     * The key to the answer (for code reference)
     */
    "key": string;
    /**
     * The text of the answer (for user display)
     */
    "text": string;
}

export interface PollResource {
    /**
     * Whether the poll is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The answers to the poll
     */
    "answers": Array<PollAnswerResource>;
    /**
     * The category for the poll
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the poll
     */
    "id"?: string;
    /**
     * The tags for the poll
     */
    "tags"?: Array<string>;
    /**
     * A poll template this poll is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The text of the poll
     */
    "text": string;
    /**
     * The media type of the poll
     */
    "type": PollResourceTypeEnum;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type PollResourceTypeEnum = "TEXT" | "IMAGE" | "VIDEO" | "AUDIO";
export interface PollResponseResource {
    /**
     * The answer to the poll
     */
    "answer": string;
    /**
     * The date the poll was answered, in seconds since unix epoc
     */
    "answeredDate"?: number;
    /**
     * The id of the poll response
     */
    "id"?: string;
    /**
     * The id of the poll
     */
    "pollId": string;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface PredicateResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface Property {
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface PropertyDefinitionResource {
    /**
     * The description of the property
     */
    "description"?: string;
    /**
     * A list of the fields on both the property definition and property of this type
     */
    "fieldList"?: PropertyFieldListResource;
    /**
     * The friendly front-facing name of the property
     */
    "friendlyName"?: string;
    /**
     * The name of the property
     */
    "name": string;
    /**
     * The JSON path to the option label
     */
    "optionLabelPath"?: string;
    /**
     * The JSON path to the option value
     */
    "optionValuePath"?: string;
    /**
     * URL of service containing the property options (assumed JSON array)
     */
    "optionsUrl"?: string;
    /**
     * Whether the property is required
     */
    "required": boolean;
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface PropertyFieldListResource {
    /**
     * A list of fields for the property definition.
     */
    "propertyDefinitionFields"?: Array<PropertyFieldResource>;
    /**
     * A list of fields for the property.
     */
    "propertyFields"?: Array<PropertyFieldResource>;
    /**
     * The type for the property this describes.
     */
    "propertyType"?: string;
}

export interface PropertyFieldResource {
    /**
     * A description of the field
     */
    "description"?: string;
    /**
     * The type of values within a 'list' type field
     */
    "innerType"?: PropertyFieldResourceInnerTypeEnum;
    /**
     * A description of fields within objects within a 'list' type field, when inner_type is 'object'
     */
    "innerTypeFields"?: Array<PropertyFieldResource>;
    /**
     * The name of the field
     */
    "name"?: string;
    /**
     * Whether the field is required
     */
    "required"?: boolean;
    /**
     * The type of the field
     */
    "type"?: PropertyFieldResourceTypeEnum;
    /**
     * A list of valid values for 'enum' type fields
     */
    "validValues"?: Array<string>;
}

export type PropertyFieldResourceInnerTypeEnum = "integer" | "number" | "bool" | "string" | "enumeration" | "list" | "object" | "definition";
export type PropertyFieldResourceTypeEnum = "integer" | "number" | "bool" | "string" | "enumeration" | "list" | "object" | "definition";
export interface QuestionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The list of available answers
     */
    "answers"?: Array<AnswerResource>;
    /**
     * The category for the question
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The difficulty of the question
     */
    "difficulty": number;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
    /**
     * The id of the import job that created the question, or null if not from an import
     */
    "importId"?: number;
    /**
     * When the question becomes available, null for never, in seconds since epoch
     */
    "publishedDate"?: number;
    /**
     * The question. Different 'type' values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
     */
    "question": Property;
    /**
     * The first source of the question
     */
    "source1"?: string;
    /**
     * The second source of the question
     */
    "source2"?: string;
    /**
     * The list of tags
     */
    "tags"?: Array<string>;
    /**
     * A question template this question is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The supplier of the question
     */
    "vendor"?: string;
}

export interface QuestionTemplateResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * A property definition for all answers. If included each answer must match this definition's type and be valid
     */
    "answerProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A property definition for the question itself. If included the answer must match this definition's type and be valid
     */
    "questionProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface QuickBuyRequest {
    /**
     * SKU of item being purchased
     */
    "sku": string;
    /**
     * ID of the user making the purchase. If null, currently logged in user will be used.
     */
    "userId"?: number;
}

export interface RawEmailResource {
    /**
     * The body of the outgoing message.
     */
    "body": string;
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * Whether the body is to be treated as html. Default false.
     */
    "html"?: boolean;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The subject of the outgoing message.
     */
    "subject": string;
}

export interface RawPushResource {
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The body of the outgoing message.
     */
    "text": string;
}

export interface RawSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The body of the outgoing text message.
     */
    "text": string;
}

export interface ReactivateSubscriptionRequest {
    /**
     * The inventory to reactivate. Only required if using the deprecated subscriptions service
     */
    "inventoryId"?: number;
    /**
     * Whether to add the additional reactivation fee in addition to the recurring fee
     */
    "reactivationFee"?: boolean;
}

export interface RefundRequest {
    /**
     * The amount to refund. If left off, will refund the remaining balance of the transaction or specific item balance (if SKU provided), whichever is less.
     */
    "amount"?: number;
    /**
     * The SKU of a bundle item from the invoice that the target item is within.
     */
    "bundleSku"?: string;
    /**
     * Notes about or reason for the refund
     */
    "notes": string;
    /**
     * The SKU of a specific item from the invoice to refund. Affects the maximum refund amount (not to exceed the price of this item times quantity on invoice). Transaction must be tied to an invoice if used.
     */
    "sku"?: string;
}

export interface RefundResource {
    /**
     * The amount refunded
     */
    "amount"?: number;
    /**
     * The id of the refund transaction
     */
    "refundTransactionId"?: number;
    /**
     * The id of the original transaction
     */
    "transactionId"?: number;
}

export interface ResourceTypeDescription {
    /**
     * The field on the resource that the id is in
     */
    "idField": string;
    /**
     * The unique name for the resource in swagger. This serves as the unique identifier. Cannot be changed after creation
     */
    "name": string;
    /**
     * The base path of the service
     */
    "servicePath": string;
}

export interface Result {
    /**
     * The JSAPI error code
     */
    "code"?: number;
    /**
     * The id used for debugging lookup
     */
    "requestId"?: string;
    /**
     * The error object
     */
    "result"?: Array<ErrorResource>;
}

export interface RevenueCountryReportResource {
    "country"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueProductReportResource {
    "itemId"?: number;
    "itemName"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueReportResource {
    "customerCount"?: number;
    "saleCount"?: number;
    "salesAverage"?: number;
    "salesTotal"?: number;
}

export interface RewardCurrencyResource {
    /**
     * The code of the currency type to give
     */
    "currencyCode": string;
    /**
     * The name of the currency reward to give.  Set by currency_code)
     */
    "currencyName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * True if the value is actually a percentage of the intake
     */
    "percent": boolean;
    /**
     * The amount of currency to give. For percentage values, 0.5 is 50%
     */
    "value": number;
}

export interface RewardItemResource {
    /**
     * The id of the item to reward
     */
    "itemId": number;
    /**
     * The name of the item to reward (read only, set by id)
     */
    "itemName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * How many copies to give
     */
    "quantity": number;
}

export interface RewardSetResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The currency to give as rewards
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * The assigned unique ID for this reward set
     */
    "id"?: number;
    /**
     * The items to give as rewards
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * A longer describe the reward set, usually included in details
     */
    "longDescription"?: string;
    /**
     * The maximum placing that will receive a reward
     */
    "maxPlacing"?: number;
    /**
     * The user friendly name for this reward set
     */
    "name": string;
    /**
     * A short paragraph to describe the reward set, usually included in listings.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A provided unique key for this reward set
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface RoleResource {
    /**
     * The number of clients this role is assigned to
     */
    "clientCount"?: number;
    /**
     * The date the role was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether a role is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the role used for display purposes
     */
    "name": string;
    /**
     * The keyword that defines the role
     */
    "role": string;
    /**
     * The list of permissions this role has
     */
    "rolePermission"?: Array<PermissionResource>;
    /**
     * The number of users this role is assigned to
     */
    "userCount"?: number;
}

export interface S3Config {
    "bucketName"?: string;
    "cdnUrl"?: string;
    "region"?: string;
    "uploadPrefix"?: string;
}

export interface SampleCountriesResponse {
    "vendorId1"?: Array<Country>;
    "vendorId2"?: Array<Country>;
}

export interface SavedAddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    "default"?: boolean;
    /**
     * The first name of the user
     */
    "firstName": string;
    /**
     * The id of the address
     */
    "id"?: number;
    /**
     * The last name of the user
     */
    "lastName": string;
    /**
     * The name of the address
     */
    "name": string;
    /**
     * The first phone number of the user
     */
    "phone1"?: string;
    /**
     * The second phone number of the user
     */
    "phone2"?: string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface Schedule {
    /**
     * The duration of the repeatable events
     */
    "duration": number;
    /**
     * The unit of time for the duration field
     */
    "durationUnit": ScheduleDurationUnitEnum;
    /**
     * How often the event is scheduled
     */
    "repeat": ScheduleRepeatEnum;
}

export type ScheduleDurationUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type ScheduleRepeatEnum = "DAILY" | "WEEKLY";
export interface SelectedSettingRequest {
    /**
     * The unique ID for the setting
     */
    "key": string;
    /**
     * The unique ID for the option. Must match one of the options from this setting in the activity, if not part of a challenge
     */
    "value": string;
}

export interface SelectedSettingResource {
    /**
     * The unique ID for the setting
     */
    "key": string;
    /**
     * The textual name of the setting
     */
    "keyName": string;
    /**
     * The unique ID for the option. Must match one of the options from this setting in the activity, if not part of a challenge
     */
    "value": string;
    /**
     * The textual name of the option
     */
    "valueName": string;
}

export interface SettingOption {
    /**
     * The textual name of the option: Ex: Hard (level 10)
     */
    "name": string;
    /**
     * The value of the option. Ex: 10
     */
    "value"?: string;
}

export interface SimpleGroupResource {
    /**
     * The name of the group. Max 50 characters
     */
    "name": string;
    /**
     * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created. Default: random UUID
     */
    "uniqueName"?: string;
}

export interface SimpleReferenceResourceint {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcelong {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourceobject {
    /**
     * The id of the referenced object
     */
    "id": any;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcestring {
    /**
     * The id of the referenced object
     */
    "id": string;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleUserResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface SimpleWallet {
    /**
     * The current balance of the wallet
     */
    "balance"?: number;
    /**
     * The ISO currency code for the wallet
     */
    "code"?: string;
    /**
     * The name of the currency stored in the wallet
     */
    "currencyName"?: string;
    /**
     * The unique ID of the wallet
     */
    "id"?: number;
    /**
     * The ID of the user to whom the wallet belongs
     */
    "userId"?: number;
}

export interface Sku {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The currency code for the SKU, a three letter string (ISO3)
     */
    "currencyCode": string;
    /**
     * The friendly name of the SKU as it will appear on invoices and reports. Typically represents the option name like red, large, etc
     */
    "description": string;
    /**
     * The number of SKUs currently in stock
     */
    "inventory"?: number;
    /**
     * Alerts vendor when SKU inventory drops below this value
     */
    "minInventoryThreshold"?: number;
    "notAvailable"?: boolean;
    "notDisplayable"?: boolean;
    /**
     * The base price before any sale
     */
    "originalPrice": number;
    /**
     * The current price of the SKU with sales, if any. Set original_price for the base
     */
    "price"?: number;
    /**
     * Whether or not the SKU is currently visible to users. This will not block users from purchase. Use start_date or stop_date to prevent purchase. Default: true
     */
    "published"?: boolean;
    /**
     * The id of a sale affecting the price, if any
     */
    "saleId"?: number;
    /**
     * The name of a sale affecting the price, if any
     */
    "saleName"?: string;
    /**
     * The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters
     */
    "sku": string;
    /**
     * The date the sku becomes visible (if published) and available for purchase, unix timestamp in seconds.  If set to null, sku will become available immediately
     */
    "startDate"?: number;
    /**
     * The date the sku becomes hidden and unavailable for purchase, unix timestamp in seconds.  If set to null, sku is always available
     */
    "stopDate"?: number;
}

export interface SkuRequest {
    /**
     * SKU code of the item
     */
    "sku": string;
}

export interface SqlDatabaseConfig {
    "connectionPoolSize"?: number;
    "dbName"?: string;
    "hostname"?: string;
    "password"?: string;
    "port"?: number;
    "username"?: string;
}

export interface StateResource {
    /**
     * The code of the state
     */
    "code"?: string;
    /**
     * The iso3 of the country this state is in
     */
    "countryCodeIso3"?: string;
    /**
     * The unique ID for the state
     */
    "id"?: number;
    /**
     * The name of the state
     */
    "name"?: string;
}

export interface StateTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * Whether the state is exempt from paying the country tax
     */
    "federallyExempt": boolean;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * The code of the state, cannot be changed
     */
    "stateCode": string;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface StoreItemTemplateResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A template to apply to all skus on an item using this template
     */
    "skuTemplate"?: TemplateResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface StringOperationResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    "definition"?: string;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "returnType"?: string;
    /**
     * The operators supported by this expression
     */
    "supportedOperators"?: Array<OperationDefinitionResource>;
    "type"?: string;
}

export interface StringWrapper {
    "value"?: string;
}

export interface StripeCreatePaymentMethod {
    /**
     * Additional optional details to store on the payment method. If included, all fields in the details will override any defaults
     */
    "details"?: PaymentMethodDetails;
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
    /**
     * The id of the user, if null the logged in user is used. Admin privilege need to specify other users
     */
    "userId"?: number;
}

export interface StripePaymentRequest {
    /**
     * The amount to pay, if not the full remaining balance (leave out to pay in full, but be careful no other partial payment has been started)
     */
    "amount"?: number;
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
}

export interface SubscriptionCreditResource {
    /**
     * The amount of the credit, negative for debt
     */
    "amount": number;
    /**
     * The date this credit was added, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the credit record
     */
    "id"?: number;
    /**
     * The id of the subscription inventory entry
     */
    "inventoryId"?: number;
    /**
     * The reason for the subscription credit
     */
    "reason": string;
}

export interface SubscriptionPlan {
    "additionalProperties"?: { [key: string]: Property; };
    "availability"?: SubscriptionPlanAvailabilityEnum;
    "billGraceDays"?: number;
    "consolidated"?: boolean;
    "firstBill"?: number;
    "firstBillUnitOfTime"?: SubscriptionPlanFirstBillUnitOfTimeEnum;
    "id"?: string;
    "latePaymentSku"?: string;
    "locked"?: boolean;
    "maxAutoRenew"?: number;
    "maxBillAttempts"?: number;
    "migrationPlan"?: string;
    "minimumTerm"?: number;
    "name"?: string;
    "primarySku"?: string;
    "reactivationSku"?: string;
    "recurringSku"?: string;
    "renewPeriod"?: number;
    "renewPeriodUnitOfTime"?: SubscriptionPlanRenewPeriodUnitOfTimeEnum;
    "subscriptionId"?: number;
}

export type SubscriptionPlanAvailabilityEnum = "all" | "new_subscribers";
export type SubscriptionPlanFirstBillUnitOfTimeEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type SubscriptionPlanRenewPeriodUnitOfTimeEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export interface SubscriptionPlanResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The length of the billing cycle in number of billing cycle unit
     */
    "billingCycleLength": number;
    /**
     * The time period unit to apply to the length of billing cycles
     */
    "billingCycleUnit": SubscriptionPlanResourceBillingCycleUnitEnum;
    /**
     * Whether this plan will be renewed on the consolidated billing cycle
     */
    "consolidated": boolean;
    /**
     * The ISO3 currency code to use for the fees
     */
    "currencyCode": string;
    /**
     * Used to schedule plan availability end date
     */
    "endDate"?: number;
    /**
     * Optional override for the length of the first billing cycle before the first recurring billing
     */
    "firstBillingCycleLength"?: number;
    /**
     * The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified
     */
    "firstBillingCycleUnit"?: SubscriptionPlanResourceFirstBillingCycleUnitEnum;
    /**
     * The number of late payment days before a subscription is canceled
     */
    "gracePeriod": number;
    /**
     * The id of the plan used to generate the SKUs
     */
    "id"?: string;
    /**
     * The fee charged when the subscription is purchased
     */
    "initialFee": number;
    /**
     * The SKU to be used when purchasing the subscription through the cart
     */
    "initialSku"?: string;
    /**
     * The fee to add to the bill when an invoice has gone unpaid passed the grace period
     */
    "latePaymentFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is delinquent
     */
    "latePaymentSku"?: string;
    /**
     * Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed
     */
    "locked"?: boolean;
    /**
     * The number of charge attempts before the subscription becomes delinquent
     */
    "maxBillAttempts": number;
    /**
     * Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached
     */
    "maxCycles"?: number;
    /**
     * Automatically migrate to the specified plan when the subscription is first renewed
     */
    "migrateToPlan"?: string;
    /**
     * The minimum number of renewals to charge for
     */
    "minCycles"?: number;
    /**
     * The name of the plan used to generate the SKUs
     */
    "name": string;
    /**
     * Whether this plan is currently available
     */
    "published": boolean;
    /**
     * The fee to charge when a suspended subscription is to be re-activated
     */
    "reactivationFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is re-activated after a suspension
     */
    "reactivationSku"?: string;
    /**
     * The recurring fee to charge for each renewal
     */
    "recurringFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is activated
     */
    "recurringSku"?: string;
    /**
     * Used to schedule plan availability start date
     */
    "startDate"?: number;
}

export type SubscriptionPlanResourceBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type SubscriptionPlanResourceFirstBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export interface SubscriptionPriceOverrideRequest {
    /**
     * The recurring price that has been set to override the base price. Null if not overriding
     */
    "newPrice"?: number;
    /**
     * An explanation for the reason the price is being overridden
     */
    "reason"?: string;
}

export interface SubscriptionResource {
    /**
     * The additional properties for the subscription
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * Who can purchase this subscription
     */
    "availability"?: SubscriptionResourceAvailabilityEnum;
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * The category of the subscription
     */
    "category"?: string;
    /**
     * The day of the month 1..31 this subscription will renew
     */
    "consolidationDayOfMonth"?: number;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether or not the item is currently visible to users. Does not block purchase; Use store_start or store_end to block purchase.  Default = true
     */
    "displayable"?: boolean;
    /**
     * The geo country list for the subscription
     */
    "geoCountryList"?: Array<string>;
    /**
     * The geo policy type for the subscription
     */
    "geoPolicyType"?: SubscriptionResourceGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the subscription
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * The billing options for this subscription
     */
    "plans"?: Array<SubscriptionPlanResource>;
    /**
     * A short description of the subscription.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * Used to schedule removal from store.  Null means the subscription will never be removed
     */
    "storeEnd"?: number;
    /**
     * Used to schedule appearance in store.  Null means the subscription will appear now
     */
    "storeStart"?: number;
    /**
     * The tags for the subscription
     */
    "tags"?: Array<string>;
    /**
     * The template being used
     */
    "template"?: string;
    /**
     * The unique key of the subscription
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated
     */
    "updatedDate"?: number;
    /**
     * The id of the vendor
     */
    "vendorId": number;
}

export type SubscriptionResourceAvailabilityEnum = "all" | "new_subscribers";
export type SubscriptionResourceGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface SubscriptionStatusWrapper {
    "value"?: SubscriptionStatusWrapperValueEnum;
}

export type SubscriptionStatusWrapperValueEnum = "current" | "canceled" | "stopped" | "payment_failed" | "suspended";
export interface SubscriptionTemplateResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * A template to apply to all plans on a subscription using this template
     */
    "planTemplate"?: TemplateResource;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateEmailResource {
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The subject for email
     */
    "subject"?: string;
    /**
     * The key for the template
     */
    "templateKey": string;
    /**
     * A list of variables to fill in the template
     */
    "templateVars"?: Array<KeyValuePairstringstring>;
}

export interface TemplatePushResource {
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * A mustache template
     */
    "template": string;
    /**
     * A map of values to fill in the template
     */
    "templateVars"?: any;
}

export interface TemplateResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * A mustache template
     */
    "template": string;
    /**
     * A map of values to fill in the template
     */
    "templateVars"?: any;
}

export interface TemplatedEmail {
    /**
     * The external template ID used by the email provider
     */
    "externalTemplateId"?: string;
    /**
     * The map of data used by the template
     */
    "templateData"?: any;
}

export interface TierResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The name of the tier
     */
    "name"?: string;
    /**
     * The required progress for the tier
     */
    "requiredProgress": number;
}

export interface TokenDetailsResource {
    "clientId"?: string;
    "roles"?: Array<string>;
    "userId"?: number;
}

export interface Topic {
    "createdDate"?: number;
    "displayName"?: string;
    "id"?: string;
    "locked"?: boolean;
    "tags"?: Array<string>;
    "topicMap"?: any;
    "updatedDate"?: number;
    "userCount"?: number;
}

export interface TopicResource {
    /**
     * The created date of the topic
     */
    "createdDate"?: number;
    /**
     * The display name of the topic
     */
    "displayName"?: string;
    /**
     * The unique ID for this topic
     */
    "id"?: string;
    /**
     * Whether this topic is locked or not.
     */
    "locked"?: boolean;
    /**
     * Random tags to facilitate search
     */
    "tags"?: Array<string>;
    /**
     * The last time the topic was updated
     */
    "updatedDate"?: number;
    /**
     * The subscribed user count of the topic
     */
    "userCount"?: number;
}

export interface TopicSubscriber {
    "disabled"?: boolean;
    "email"?: string;
    "joinDate"?: number;
    "mobileNumber"?: string;
    "topicId"?: string;
    "topicSubscriberMap"?: any;
    "userId"?: number;
    "username"?: string;
}

export interface TopicSubscriberResource {
    /**
     * Whether the user has disabled messages from the topic
     */
    "disabled"?: boolean;
    /**
     * The ID for this topic
     */
    "topicId": string;
    /**
     * The user ID subscribed to the topic
     */
    "userId"?: number;
    /**
     * The username subscribed to the topic
     */
    "username"?: string;
}

export interface TransactionResource {
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: TransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
}

export type TransactionResourceSourceEnum = "digital" | "physical";
/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface TypeHintLookupResource {
    "definition"?: string;
    "lookupKey"?: ExpressionResource;
    "requiredKeyType"?: string;
    "type"?: string;
    "valueType"?: string;
}

export interface UsageInfo {
    /**
     * The number of requests within the range
     */
    "count"?: number;
    /**
     * The date at the start of the range (see granularity)
     */
    "date"?: number;
    /**
     * The http method
     */
    "method"?: string;
    /**
     * The url path
     */
    "url"?: string;
}

export interface UserAchievementGroupResource {
    /**
     * The list of achievements associated with the group
     */
    "achievements": Array<UserAchievementResource>;
    /**
     * The name of the group.  If used by Leveling, this will represent the level name
     */
    "groupName": string;
    /**
     * The id of the achievement progress
     */
    "id"?: string;
    /**
     * The current progress of the user on the group
     */
    "progress": number;
    /**
     * The id of the user whose progress is being tracked
     */
    "userId": number;
}

export interface UserAchievementResource {
    /**
     * Flag indicating whether the user has earned the achievement
     */
    "achieved"?: boolean;
    /**
     * The achievement being tracked.  If used for Leveling, this represents the tier name
     */
    "achievementName": string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The date/time the achievement was earned as a unix timestamp in seconds
     */
    "earnedDate"?: number;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface UserActionLog {
    /**
     * A description of the action taken
     */
    "actionDescription": string;
    /**
     * The name of the action taken
     */
    "actionName": string;
    /**
     * The date of the action, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A map of additional details such as the target of the action
     */
    "details"?: { [key: string]: string; };
    /**
     * The id of the log entry
     */
    "id"?: string;
    /**
     * The id of the api request that spawned the action, if generated internally
     */
    "requestId"?: string;
    /**
     * The id of the user that took the action, if any. Read-only if not posting with LOGS_ADMIN
     */
    "userId"?: number;
}

export interface UserActivityResults {
    /**
     * Any currency rewarded to this user
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * Any items rewarded to this user
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 10 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The number of users tied at this rank, including this user. 1 means no tie
     */
    "ties"?: number;
    /**
     * The date this score was recorded or updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface UserActivityResultsResource {
    /**
     * The raw score. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The id of the player
     */
    "userId": number;
}

export interface UserBaseResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The date the user last interacted with the API (private)
     */
    "lastActivity"?: number;
    /**
     * The date the user's info was last updated as a unix timestamp
     */
    "lastUpdated"?: number;
    /**
     * The user's date of registration as a unix timestamp
     */
    "memberSince"?: number;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

export interface UserInventoryAddRequest {
    /**
     * A note to be passed to the invoice or transaction
     */
    "note": string;
    /**
     * A list of behaviors to ignore explicitely.  Ex: 'limited_gettable'
     */
    "overrides"?: Array<string>;
    /**
     * If set to true will cause the endpoint to skip creation of cart and invoice to track the inventory change
     */
    "skipInvoice": boolean;
    /**
     * The specific SKU of the item to be added to the inventory
     */
    "sku": string;
}

export interface UserInventoryResource {
    /**
     * A map of data for behaviors
     */
    "behaviorData"?: any;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The date/time this resource exires in seconds since epoch. Null for no expiration. For subscriptions, this is the end of the 'grace period' if left unpaid
     */
    "expires"?: number;
    /**
     * The id of the inventory
     */
    "id"?: number;
    /**
     * The id of the invoice that resulted in this inventory, if any
     */
    "invoiceId"?: number;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The name of the item
     */
    "itemName"?: string;
    /**
     * The type hint of the item
     */
    "itemTypeHint"?: string;
    /**
     * The status of the inventory. Pending inventory is not yet ready for use. Inactive inventory has expired or been used up
     */
    "status"?: UserInventoryResourceStatusEnum;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The id of the user this inventory belongs to
     */
    "user"?: SimpleUserResource;
}

export type UserInventoryResourceStatusEnum = "pending" | "active" | "inactive";
export interface UserItemLogResource {
    /**
     * The log entry id
     */
    "id"?: number;
    /**
     * Additional information defined by the type
     */
    "info"?: string;
    /**
     * The item interacted with
     */
    "item"?: SimpleReferenceResourceint;
    /**
     * The date/time this event occurred in seconds since epoch
     */
    "logDate"?: number;
    /**
     * The type of event
     */
    "type"?: string;
    /**
     * The user making the interaction
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the inventory entry this event is related to, if any
     */
    "userInventory"?: number;
}

export interface UserLevelingResource {
    /**
     * The name of the last tier the user has qualified for
     */
    "lastTierName": string;
    /**
     * The progress level of the last tier the user has qualified for
     */
    "lastTierProgress": number;
    /**
     * The name of the level schema
     */
    "levelName": string;
    /**
     * The name of the next tier the user can qualify for
     */
    "nextTierName": string;
    /**
     * The progress needed to qualify for the next tier
     */
    "nextTierProgress": number;
    /**
     * The amount of progress the user has
     */
    "progress": number;
    /**
     * The names of the tiers the user has qualified for
     */
    "tierNames": Array<string>;
    /**
     * The ID of the user
     */
    "userId": number;
}

export interface UserNotificationResource {
    /**
     * The data to send and fill templates
     */
    "data"?: any;
    /**
     * The id of the notification
     */
    "notificationId": string;
    /**
     * The id of the notification type
     */
    "notificationTypeId": string;
    /**
     * The id of the recipient, dependent on the recipient_type. The user's id or the topic's id
     */
    "recipient": string;
    /**
     * The type of recipient for the notification. Either a user, or all users in a topic
     */
    "recipientType": UserNotificationResourceRecipientTypeEnum;
    /**
     * The date this notification was first retrieved
     */
    "retrieveDate"?: number;
    /**
     * The date this notification was sent
     */
    "sendDate"?: number;
    /**
     * The user's status for this notification
     */
    "status"?: UserNotificationResourceStatusEnum;
    /**
     * The id of the user
     */
    "userId": number;
}

export type UserNotificationResourceRecipientTypeEnum = "user" | "topic";
export type UserNotificationResourceStatusEnum = "pending" | "read" | "hidden";
export interface UserNotificationStatusWrapper {
    "value"?: UserNotificationStatusWrapperValueEnum;
}

export type UserNotificationStatusWrapperValueEnum = "pending" | "read" | "hidden";
export interface UserRelationshipReferenceResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The context of the relationship
     */
    "context"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The id of the relationship
     */
    "relationshipId"?: number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface UserRelationshipResource {
    /**
     * The child in the relationship
     */
    "child": SimpleUserResource;
    /**
     * Context about the relationship or its type
     */
    "context"?: string;
    /**
     * A generated unique id. Read-Only
     */
    "id"?: number;
    /**
     * The parent in the relationship
     */
    "parent": SimpleUserResource;
}

export interface UserResource {
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The first line of the user's address (private)
     */
    "address"?: string;
    /**
     * The second line of user's address (private)
     */
    "address2"?: string;
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * Relationships where this user is the parent. Read-Only, manage through separate endpoints
     */
    "children"?: Array<UserRelationshipReferenceResource>;
    /**
     * The user's city (private)
     */
    "city"?: string;
    /**
     * The ISO3 code for the country from the user's address (private). Will be filled in based on GeoIP country at registration if not provided.
     */
    "countryCode"?: string;
    /**
     * The code for the user's real money currency (private)
     */
    "currencyCode"?: string;
    /**
     * The user's date of birth (private) as a unix timestamp
     */
    "dateOfBirth"?: number;
    /**
     * The user's self description (private)
     */
    "description"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's first name (private)
     */
    "firstName"?: string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The user's gender (private)
     */
    "gender"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The ISO3 code for the user's currency (private)
     */
    "languageCode"?: string;
    /**
     * The date the user last interacted with the API (private)
     */
    "lastActivity"?: number;
    /**
     * The user's last name (private)
     */
    "lastName"?: string;
    /**
     * The date the user's info was last updated as a unix timestamp
     */
    "lastUpdated"?: number;
    /**
     * The user's date of registration as a unix timestamp
     */
    "memberSince"?: number;
    /**
     * The user's mobile phone number (private)
     */
    "mobileNumber"?: string;
    /**
     * Relationships where this user is the child. Read-Only, manage through separate endpoints
     */
    "parents"?: Array<UserRelationshipReferenceResource>;
    /**
     * The plain text password for the new user account. Required for registration; ignored on profile update.  Use password specific endpoints for editing
     */
    "password"?: string;
    /**
     * The user's postal code (private)
     */
    "postalCode"?: string;
    /**
     * The user's state (private)
     */
    "state"?: string;
    /**
     * Tags on the user. Can only be set by admin. Max length per tag is 64 characters
     */
    "tags"?: Array<string>;
    /**
     * A user template this user is validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The code for the user's timezone (private)
     */
    "timezoneCode"?: string;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface UsernameLookupResource {
    "definition"?: string;
    "lookupKey"?: ExpressionResource;
    "requiredKeyType"?: string;
    "type"?: string;
    "valueType"?: string;
}

export interface ValueWrapperboolean {
    "value"?: boolean;
}

export interface VariableTypeResource {
    /**
     * The base class of the type
     */
    "base": VariableTypeResourceBaseEnum;
    /**
     * Whether the type comes from a set of valid values that the system can provided (such as users)
     */
    "enumerable"?: boolean;
    /**
     * The name of the variable type. Used as the unique id
     */
    "name": string;
}

export type VariableTypeResourceBaseEnum = "NUMBER" | "INTEGER" | "STRING" | "DATE" | "BOOLEAN";
/**
 * Expressions are instructions for the rule engine to resolve certain values. For example instead of `user 1` it'd state `user provided by the event`. Full list and definitions available at GET /bre/expressions.
 */
export interface VendorEmailLookupResource {
    "definition"?: string;
    "lookupKey"?: ExpressionResource;
    "requiredKeyType"?: string;
    "type"?: string;
    "valueType"?: string;
}

export interface VendorResource {
    /**
     * Whether the vendor is active.  Default = true
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the vendor was added. Unix timestamp in seconds
     */
    "createDate"?: number;
    /**
     * A description of the vendor
     */
    "description"?: string;
    /**
     * The id of the vendor
     */
    "id"?: number;
    /**
     * The url of an image for the vendor
     */
    "imageUrl"?: string;
    /**
     * Whether the vendor needs to manually approve invoices before they are paid.  A separate checkout flow is required in this case.  Default: false
     */
    "manualApproval"?: boolean;
    /**
     * The name of the vendor
     */
    "name": string;
    /**
     * The primary email address for the vendor
     */
    "primaryContactEmail"?: string;
    /**
     * The name of the primary contact for the vendor
     */
    "primaryContactName"?: string;
    /**
     * The primary phone number for the vendor
     */
    "primaryContactPhone"?: string;
    /**
     * The email address for sale inquiries for the vendor
     */
    "salesEmail"?: string;
    /**
     * The email address for support inquiries for the vendor
     */
    "supportEmail"?: string;
    /**
     * A user template this user is validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The date the vendor was last updated. Unix timestamp in seconds
     */
    "updateDate"?: number;
    /**
     * The url for the vendor's site
     */
    "url"?: string;
}

export interface Version {
    "version"?: string;
}

export interface VideoRelationshipResource {
    /**
     * The owner of the relationship
     */
    "from"?: SimpleReferenceResourcelong;
    /**
     * The id of the relationship
     */
    "id"?: number;
    /**
     * Details about the relationship such as type or other information. Max length 10 characters
     */
    "relationshipDetails": string;
    /**
     * The target of the relationship.
     */
    "to": SimpleReferenceResourcelong;
}

export interface VideoResource {
    /**
     * Whether the video is available, based on various factors
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The original artist of the media
     */
    "author"?: SimpleReferenceResourcelong;
    /**
     * The date the media was created as a unix timestamp in seconds
     */
    "authored"?: number;
    /**
     * Whether the video has been banned or not
     */
    "banned"?: boolean;
    /**
     * The category of the video
     */
    "category": SimpleReferenceResourcestring;
    /**
     * The comments of the video
     */
    "comments"?: Array<CommentResource>;
    /**
     * Artists that contributed to the creation. See separate endpoint to add to list
     */
    "contributors"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The country of an embedable version
     */
    "embed"?: string;
    /**
     * The file extension of the media file. 1-5 characters
     */
    "extension": string;
    /**
     * The height of the video in px
     */
    "height": number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The length of the video in seconds
     */
    "length": number;
    /**
     * The country of the media. Typically a url. Cannot be blank
     */
    "location": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The mime-type of the media
     */
    "mimeType"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order of the video. default: 100
     */
    "priority"?: number;
    /**
     * The privacy setting. default: private
     */
    "privacy"?: VideoResourcePrivacyEnum;
    /**
     * Whether the video has been made public. Default true
     */
    "published"?: boolean;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The size of the media. Minimum 0 if supplied
     */
    "size"?: number;
    /**
     * The tags for the video
     */
    "tags"?: Array<string>;
    /**
     * A video template this video is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The country of a thumbnail version. Typically a url
     */
    "thumbnail"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user the media was uploaded by. May be null for system uploaded media. May only be set to a user other than the current caller if VIDEOS_ADMIN permission. Null will mean the caller is the uploader unless the caller has VIDEOS_ADMIN permission, in which case it will be set to null
     */
    "uploader"?: SimpleUserResource;
    /**
     * The view count of the video
     */
    "views"?: number;
    /**
     * The width of the video in px
     */
    "width": number;
}

export type VideoResourcePrivacyEnum = "private" | "friends" | "public";
export interface WalletAlterRequest {
    /**
     * The amount of currency to add/remove. positive to add, negative to remove
     */
    "delta": number;
    /**
     * The id of an invoice to attribute the transaction to
     */
    "invoiceId"?: number;
    /**
     * The admin entered or system generated reason
     */
    "reason": string;
    /**
     * The transaction type to allow for search/etc
     */
    "type"?: string;
}

export interface WalletTotalResponse {
    /**
     * The currency code
     */
    "currencyCode"?: string;
    /**
     * The sum of all wallets in the system for this currency
     */
    "total"?: number;
}

export interface WalletTransactionResource {
    /**
     * The new balance of the wallet after the transaction
     */
    "balance"?: number;
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: WalletTransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The owner of the wallet
     */
    "user"?: SimpleUserResource;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
    /**
     * The id of the wallet this transaction affected
     */
    "walletId"?: number;
}

export type WalletTransactionResourceSourceEnum = "digital" | "physical";
export interface WebsocketMessageResource {
    /**
     * The body of the outgoing message.
     */
    "content": any;
    /**
     * A message type to inform websocket recipient how to parse content
     */
    "messageType"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
}

export interface XsollaPaymentRequest {
    /**
     * The id of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL xsolla should forward the user to after they pay
     */
    "returnUrl": string;
}

export interface AudioPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum length of the audio
     */
    "maxLength"?: number;
    /**
     * If provided, the minimum length of the audio
     */
    "minLength"?: number;
}

export interface BooleanProperty extends Property {
    /**
     * The value
     */
    "value"?: boolean;
}

export interface BooleanPropertyDefinitionResource extends PropertyDefinitionResource {
}

export interface CacheClearEvent extends BroadcastableEvent {
    "teardown"?: boolean;
}

export interface Consumable extends Behavior {
    /**
     * The maximum number of times an item can be used
     */
    "maxUse"?: number;
}

export interface DateProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface DatePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface DoubleProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface DoublePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface EntitlementItem extends Item {
}

export interface Expirable extends Behavior {
    /**
     * The length of time
     */
    "timeLength"?: number;
    /**
     * The unit of time
     */
    "unitOfTime"?: string;
}

export interface FileGroupProperty extends Property {
    /**
     * The list of files
     */
    "files"?: Array<FileProperty>;
}

export interface FileGroupPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum number of files in the group
     */
    "maxCount"?: number;
    /**
     * If provided, the maximum allowed size per file in bytes
     */
    "maxFileSize"?: number;
    /**
     * If provided, the minimum number of files in the group
     */
    "minCount"?: number;
}

export interface FileProperty extends Property {
    /**
     * A crc value for file integrity verification
     */
    "crc"?: string;
    /**
     * A description of the file
     */
    "description"?: string;
    /**
     * The type of file such as txt, mp3, mov or csv
     */
    "fileType"?: string;
    /**
     * The url of the file
     */
    "url"?: string;
}

export interface FilePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum allowed file size in bytes
     */
    "maxFileSize"?: number;
}

export interface FormattedTextProperty extends Property {
    /**
     * The value
     */
    "value"?: string;
}

export interface FormattedTextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum length of the text
     */
    "maxLength"?: number;
}

export interface Fulfillable extends Behavior {
    /**
     * The name of the fulfillment type that describes how the item should be fulfilled.  Examples: inventory, wallet, amazon
     */
    "typeName": string;
}

export interface GuestPlayable extends Behavior {
    /**
     * Whether guests are allowed to use items
     */
    "allowed"?: boolean;
    /**
     * Whether guests are allowed on the leaderboard
     */
    "leaderboard"?: boolean;
}

export interface ImagePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum height of the image
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum width of the image
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of the image
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum width of the image
     */
    "minWidth"?: number;
}

export interface IntegerProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface IntegerPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface LimitedGettable extends Behavior {
    "group"?: LimitedGettableGroup;
}

export interface ListProperty extends Property {
    /**
     * The list of properties
     */
    "values": Array<Property>;
}

export interface ListPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum number of files in the group
     */
    "maxCount"?: number;
    /**
     * If provided, the minimum number of files in the group
     */
    "minCount"?: number;
    /**
     * If provided, a property definition for validating values within list
     */
    "valueDefinition"?: PropertyDefinitionResource;
}

export interface LogLevelEvent extends BroadcastableEvent {
    "level"?: string;
    "name"?: string;
}

export interface LongProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface LongPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface MapProperty extends Property {
    /**
     * A map/object of string to sub-property
     */
    "map": { [key: string]: Property; };
}

export interface MapPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * Whether to allow additional properties beyond those specified or not
     */
    "allowAdditional"?: boolean;
    /**
     * If provided, a list of property definitions for each map entry
     */
    "properties"?: Array<PropertyDefinitionResource>;
}

export interface MobileDeviceResource extends DeviceResource {
    /**
     * The authorization code for push notifications provided by the provider platform (APNS, GCM, etc).
     */
    "authorization"?: string;
    "imei"?: string;
    /**
     * The platform used for push notifications. Only Apple and Android are supported at the moment.
     */
    "notificationPlatform"?: MobileDeviceResourceNotificationPlatformEnum;
    /**
     * The phone number associated with this device if applicable, in international format
     */
    "number"?: string;
}

export type MobileDeviceResourceNotificationPlatformEnum = "APNS" | "GCM";
export interface NewCustomerEvent extends BroadcastableEvent {
    "customerConfig"?: CustomerConfig;
}

export interface PreReqEntitlement extends Behavior {
    /**
     * The item ids that must already be in the user's inventory
     */
    "itemIds": Array<number>;
}

export interface PriceOverridable extends Behavior {
    /**
     * The maximum price allowed
     */
    "maxPrice"?: number;
    /**
     * The minimum price allowed
     */
    "minPrice"?: number;
}

export interface RemoveCustomerEvent extends BroadcastableEvent {
    "customerConfig"?: CustomerConfig;
}

export interface ServiceDeployedEvent extends BroadcastableEvent {
    /**
     * The events fired by this service
     */
    "events": Array<BreTriggerResource>;
    /**
     * The resources managed by this service
     */
    "resources": Array<ResourceTypeDescription>;
    /**
     * The unique name for the service. This serves as the unique identifier. Cannot be changed after creation
     */
    "serviceName": string;
    /**
     * The url of the swagger doc
     */
    "swaggerUrl": string;
}

export interface Spendable extends Behavior {
    /**
     * The code of the currency
     */
    "currencyCode"?: string;
    /**
     * The spendable value
     */
    "value"?: number;
}

export interface StoreItem extends Item {
    /**
     * Whether or not the item is currently visible to users. Does not block purchase; Use store_start or store_end to block purchase.  Default = true
     */
    "displayable"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: StoreItemGeoPolicyTypeEnum;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * The date the item will become hidden and unavailable for purchase, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will become visible (if displayable) and available for purchase, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type StoreItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface TextProperty extends Property {
    /**
     * The value
     */
    "value"?: string;
}

export interface TextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum length of the text
     */
    "maxLength"?: number;
}

export interface TimePeriodGettable extends Behavior {
    /**
     * The time period limit
     */
    "getLimit": number;
    /**
     * The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings.
     */
    "groupName"?: string;
    /**
     * The length of time
     */
    "timeLength": number;
    /**
     * The unit of time
     */
    "unitOfTime": string;
}

export interface TimePeriodUsable extends Behavior {
    /**
     * The amount of times it can be used
     */
    "maxUse"?: number;
    /**
     * The length of time
     */
    "timeLength"?: number;
    /**
     * The unit of time
     */
    "unitOfTime"?: string;
}

export interface VideoPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that teh property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum height of the video
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum length of the video
     */
    "maxLength"?: number;
    /**
     * If provided, the maximum width of the video
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of the video
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum length of the video
     */
    "minLength"?: number;
    /**
     * If provided, the minimum width of the video
     */
    "minWidth"?: number;
}

export interface WebsocketRemoveTopicEvent extends BroadcastableEvent {
    "topic"?: Topic;
}

export interface WebsocketSendMessageEvent extends BroadcastableEvent {
    "content"?: any;
    "usernames"?: Array<string>;
}

export interface WebsocketSendTopicMessageEvent extends BroadcastableEvent {
    "content"?: any;
    "topic"?: string;
}

export interface WebsocketSubscribeEvent extends BroadcastableEvent {
    "topic"?: Topic;
    "userResource"?: UserResource;
}

export interface WebsocketUnsubscribeEvent extends BroadcastableEvent {
    "topic"?: Topic;
    "topicSubscriber"?: TopicSubscriber;
}

export interface AudioGroupProperty extends FileGroupProperty {
}

export interface AudioGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum length of the audio
     */
    "maxLength"?: number;
    /**
     * If provided, the minimum length of the audio
     */
    "minLength"?: number;
}

export interface AudioProperty extends FileProperty {
}

export interface BundleItem extends StoreItem {
    /**
     * The skus of items to be included in this bundle, and how they influence the bundle total price.  Must have at least one SKU
     */
    "bundledSkus": Array<BundledSku>;
}

export interface CouponItem extends StoreItem {
    /**
     * The type of coupon
     */
    "couponTypeHint": CouponItemCouponTypeHintEnum;
    /**
     * The amount this coupon is maxed out at.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMax"?: number;
    /**
     * The minimium amount needed in the cart for the coupon to apply.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMinCartValue"?: number;
    /**
     * The type of discount in terms of how it deducts price. Value based discount not available for coupon_cart type coupons
     */
    "discountType": CouponItemDiscountTypeEnum;
    /**
     * The amount the coupon will discount the item. If discount_type is 'value' this will be a flat amount of currency. If discount type is 'percentage' this will be a fraction (0.2 for 20% off) multiplied by the price of the matching item or items.
     */
    "discountValue": number;
    /**
     * Whether this coupon is exclusive or not (true means cannot be in same cart as another).  Default = false
     */
    "exclusive"?: boolean;
    /**
     * The id of the item the coupon is applied to.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "itemId"?: number;
    /**
     * The maximum quantity of items the coupon can apply to, null if no limit and minimum 1 otherwise.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "maxQuantity"?: number;
    /**
     * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
     */
    "selfExclusive"?: boolean;
    /**
     * A list of tags for a coupon.  The coupon can only apply to an item that has at least one of these tags.  Applies if coupon_type_hint is coupon_tag
     */
    "validForTags"?: Array<string>;
}

export type CouponItemCouponTypeHintEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
export type CouponItemDiscountTypeEnum = "value" | "percentage";
export interface ImageGroupProperty extends FileGroupProperty {
}

export interface ImageGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum height of each image
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum width of each image
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of each image
     */
    "minHeight"?: number;
    /**
     * If provided, the minumum width of each image
     */
    "minWidth"?: number;
}

export interface ImageProperty extends FileProperty {
}

export interface ShippingItem extends StoreItem {
    /**
     * A unique list of country iso3 codes that allow the shipping option
     */
    "countries"?: Array<string>;
    /**
     * An abstract max value that the values of item's shipping_tier work against to decide whether an order can be fulfilled
     */
    "maxTierTotal": number;
    /**
     * Whether tax should be applied to the shipping price.  Default = false
     */
    "taxable"?: boolean;
}

export interface Subscription extends StoreItem {
    "availability"?: SubscriptionAvailabilityEnum;
    "consolidationDayOfMonth"?: number;
    "subscriptionPlans"?: Array<SubscriptionPlan>;
}

export type SubscriptionAvailabilityEnum = "all" | "new_subscribers";
export interface VideoGroupProperty extends FileGroupProperty {
}

export interface VideoGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum height of each video
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum length of each video
     */
    "maxLength"?: number;
    /**
     * If provided, the maximum width of each video
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of each video
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum length of each video
     */
    "minLength"?: number;
    /**
     * If provided, the minimum width of each video
     */
    "minWidth"?: number;
}

export interface VideoProperty extends FileProperty {
}



/**
 * Access_TokenApi - fetch parameter creator
 */
export const Access_TokenApiFetchParamCreator = {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client. Used only with a grant_type of password
     * @param password The password of the client. Used only with a grant_type of password
     * @param token The 3rd party authentication token. Used only with a grant_type of facebook, google, etc (social plugins)
     * @param refreshToken The refresh token obtained during prior authentication. Used only with a grant_type of refresh_token
     */
    getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; token?: string; refreshToken?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling getOAuthToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling getOAuthToken");
        }
        const baseUrl = `/oauth/token`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "grant_type": params["grantType"],
            "client_id": params["clientId"],
            "client_secret": params["clientSecret"],
            "username": params["username"],
            "password": params["password"],
            "token": params["token"],
            "refresh_token": params["refreshToken"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Access_TokenApi - functional programming interface
 */
export const Access_TokenApiFp = {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client. Used only with a grant_type of password
     * @param password The password of the client. Used only with a grant_type of password
     * @param token The 3rd party authentication token. Used only with a grant_type of facebook, google, etc (social plugins)
     * @param refreshToken The refresh token obtained during prior authentication. Used only with a grant_type of refresh_token
     */
    getOAuthToken(params: { grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; token?: string; refreshToken?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OAuth2Resource> {
        const fetchArgs = Access_TokenApiFetchParamCreator.getOAuthToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Access_TokenApi - object-oriented interface
 */
export class Access_TokenApi extends BaseAPI {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client. Used only with a grant_type of password
     * @param password The password of the client. Used only with a grant_type of password
     * @param token The 3rd party authentication token. Used only with a grant_type of facebook, google, etc (social plugins)
     * @param refreshToken The refresh token obtained during prior authentication. Used only with a grant_type of refresh_token
     */
    getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; token?: string; refreshToken?: string; }, options: any = {}) {
        return Access_TokenApiFp.getOAuthToken(params, options)(this.fetch, this.basePath);
    }
};

/**
 * Access_TokenApi - factory interface
 */
export const Access_TokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get access token
         * @param grantType Grant type
         * @param clientId The id of the client
         * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
         * @param username The username of the client. Used only with a grant_type of password
         * @param password The password of the client. Used only with a grant_type of password
         * @param token The 3rd party authentication token. Used only with a grant_type of facebook, google, etc (social plugins)
         * @param refreshToken The refresh token obtained during prior authentication. Used only with a grant_type of refresh_token
         */
        getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; token?: string; refreshToken?: string; }, options: any = {}) {
            return Access_TokenApiFp.getOAuthToken(params, options)(fetch, basePath);
        },
    };
};


/**
 * ActivitiesApi - fetch parameter creator
 */
export const ActivitiesApiFetchParamCreator = {
    /**
     * If called with no body, defaults to the user making the call.
     * @summary Add a user to an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param test if true, indicates that the user should NOT be added. This can be used to test for eligibility
     * @param bypassRestrictions if true, indicates that restrictions such as max player count should be ignored. Can only be used with ACTIVITIES_ADMIN
     * @param userId The id of the user, or null for &#39;caller&#39;
     */
    addUser(params: {  activityOccurrenceId: number; test?: boolean; bypassRestrictions?: boolean; userId?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling addUser");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/users`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["test"] !== undefined) {
            urlObj.query["test"] = params["test"];
        }
        if (params["bypassRestrictions"] !== undefined) {
            urlObj.query["bypass_restrictions"] = params["bypassRestrictions"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  activityResource?: ActivityResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Has to enforce extra rules if not used as an admin. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: CreateActivityOccurrenceRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activity-occurrences`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["test"] !== undefined) {
            urlObj.query["test"] = params["test"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResource"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Activity Templates define a type of activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["activityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterId"] !== undefined) {
            urlObj.query["filter_id"] = params["filterId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Load a single activity occurrence details
     * @param activityOccurrenceId The id of the activity occurrence
     */
    getActivityOccurrenceDetails(params: {  activityOccurrenceId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling getActivityOccurrenceDetails");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary List activity occurrences
     * @param filterActivity Filter for occurrences of the given activity ID
     * @param filterStatus Filter for occurrences in the given status
     * @param filterEvent Filter for occurrences played during the given event
     * @param filterChallenge Filter for occurrences played within the given challenge
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listActivityOccurrences(params: {  filterActivity?: string; filterStatus?: string; filterEvent?: number; filterChallenge?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/activity-occurrences`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActivity"] !== undefined) {
            urlObj.query["filter_activity"] = params["filterActivity"];
        }
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["filterEvent"] !== undefined) {
            urlObj.query["filter_event"] = params["filterEvent"];
        }
        if (params["filterChallenge"] !== undefined) {
            urlObj.query["filter_challenge"] = params["filterChallenge"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove a user from an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user, or &#39;me&#39;
     * @param ban if true, indicates that the user should not be allowed to re-join. Can only be set by host or admin
     * @param bypassRestrictions if true, indicates that restrictions such as current status should be ignored. Can only be used with ACTIVITIES_ADMIN
     */
    removeUser(params: {  activityOccurrenceId: number; userId: string; ban?: boolean; bypassRestrictions?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling removeUser");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeUser");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/users/{user_id}`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["ban"] !== undefined) {
            urlObj.query["ban"] = params["ban"];
        }
        if (params["bypassRestrictions"] !== undefined) {
            urlObj.query["bypass_restrictions"] = params["bypassRestrictions"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * In addition to user permissions requirements there is security based on the core_settings.results_trust setting. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling setActivityOccurrenceResults");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/results`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResults"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResults"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Sets the settings of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param settings The new settings
     */
    setActivityOccurrenceSettings(params: {  activityOccurrenceId: number; settings?: ActivityOccurrenceSettingsResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling setActivityOccurrenceSettings");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/settings`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["settings"]) {
            fetchOptions.body = JSON.stringify(params["settings"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set a user's status within an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user
     * @param status The new status
     */
    setUserStatus(params: {  activityOccurrenceId: number; userId: string; status?: ActivityUserStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling setUserStatus");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserStatus");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/users/{user_id}/status`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  id: number; activityResource?: ActivityResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If setting to 'FINISHED' reward will be run based on current metrics that have been recorded already. Alternatively, see results endpoint to finish and record all metrics at once. Can be called by non-host participants if non_host_status_control is true. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Update the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrenceStatus(params: {  activityOccurrenceId: number; activityOccurrenceStatus?: ActivityOccurrenceStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling updateActivityOccurrenceStatus");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/status`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceStatus"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["activityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ActivitiesApi - functional programming interface
 */
export const ActivitiesApiFp = {
    /**
     * If called with no body, defaults to the user making the call.
     * @summary Add a user to an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param test if true, indicates that the user should NOT be added. This can be used to test for eligibility
     * @param bypassRestrictions if true, indicates that restrictions such as max player count should be ignored. Can only be used with ACTIVITIES_ADMIN
     * @param userId The id of the user, or null for &#39;caller&#39;
     */
    addUser(params: { activityOccurrenceId: number; test?: boolean; bypassRestrictions?: boolean; userId?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.addUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: { activityResource?: ActivityResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Has to enforce extra rules if not used as an admin. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: { test?: boolean; activityOccurrenceResource?: CreateActivityOccurrenceRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivityOccurrence(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Activity Templates define a type of activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: { activityTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.deleteActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.deleteActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: { filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBareActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivities(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Load a single activity occurrence details
     * @param activityOccurrenceId The id of the activity occurrence
     */
    getActivityOccurrenceDetails(params: { activityOccurrenceId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivityOccurrenceDetails(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivityTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary List activity occurrences
     * @param filterActivity Filter for occurrences of the given activity ID
     * @param filterStatus Filter for occurrences in the given status
     * @param filterEvent Filter for occurrences played during the given event
     * @param filterChallenge Filter for occurrences played within the given challenge
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listActivityOccurrences(params: { filterActivity?: string; filterStatus?: string; filterEvent?: number; filterChallenge?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.listActivityOccurrences(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove a user from an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user, or &#39;me&#39;
     * @param ban if true, indicates that the user should not be allowed to re-join. Can only be set by host or admin
     * @param bypassRestrictions if true, indicates that restrictions such as current status should be ignored. Can only be used with ACTIVITIES_ADMIN
     */
    removeUser(params: { activityOccurrenceId: number; userId: string; ban?: boolean; bypassRestrictions?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.removeUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * In addition to user permissions requirements there is security based on the core_settings.results_trust setting. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: { activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResults> {
        const fetchArgs = ActivitiesApiFetchParamCreator.setActivityOccurrenceResults(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Sets the settings of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param settings The new settings
     */
    setActivityOccurrenceSettings(params: { activityOccurrenceId: number; settings?: ActivityOccurrenceSettingsResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.setActivityOccurrenceSettings(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set a user's status within an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user
     * @param status The new status
     */
    setUserStatus(params: { activityOccurrenceId: number; userId: string; status?: ActivityUserStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityUserResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.setUserStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: { id: number; activityResource?: ActivityResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If setting to 'FINISHED' reward will be run based on current metrics that have been recorded already. Alternatively, see results endpoint to finish and record all metrics at once. Can be called by non-host participants if non_host_status_control is true. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Update the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrenceStatus(params: { activityOccurrenceId: number; activityOccurrenceStatus?: ActivityOccurrenceStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivityOccurrenceStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: { id: string; activityTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ActivitiesApi - object-oriented interface
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * If called with no body, defaults to the user making the call.
     * @summary Add a user to an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param test if true, indicates that the user should NOT be added. This can be used to test for eligibility
     * @param bypassRestrictions if true, indicates that restrictions such as max player count should be ignored. Can only be used with ACTIVITIES_ADMIN
     * @param userId The id of the user, or null for &#39;caller&#39;
     */
    addUser(params: {  activityOccurrenceId: number; test?: boolean; bypassRestrictions?: boolean; userId?: IntWrapper; }, options: any = {}) {
        return ActivitiesApiFp.addUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  activityResource?: ActivityResource; }, options: any = {}) {
        return ActivitiesApiFp.createActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Has to enforce extra rules if not used as an admin. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: CreateActivityOccurrenceRequest; }, options: any = {}) {
        return ActivitiesApiFp.createActivityOccurrence(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Activity Templates define a type of activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, options: any = {}) {
        return ActivitiesApiFp.createActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  id: number; }, options: any = {}) {
        return ActivitiesApiFp.deleteActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return ActivitiesApiFp.deleteActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivities(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  id: number; }, options: any = {}) {
        return ActivitiesApiFp.getActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Load a single activity occurrence details
     * @param activityOccurrenceId The id of the activity occurrence
     */
    getActivityOccurrenceDetails(params: {  activityOccurrenceId: number; }, options: any = {}) {
        return ActivitiesApiFp.getActivityOccurrenceDetails(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: {  id: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivityTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary List activity occurrences
     * @param filterActivity Filter for occurrences of the given activity ID
     * @param filterStatus Filter for occurrences in the given status
     * @param filterEvent Filter for occurrences played during the given event
     * @param filterChallenge Filter for occurrences played within the given challenge
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listActivityOccurrences(params: {  filterActivity?: string; filterStatus?: string; filterEvent?: number; filterChallenge?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ActivitiesApiFp.listActivityOccurrences(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove a user from an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user, or &#39;me&#39;
     * @param ban if true, indicates that the user should not be allowed to re-join. Can only be set by host or admin
     * @param bypassRestrictions if true, indicates that restrictions such as current status should be ignored. Can only be used with ACTIVITIES_ADMIN
     */
    removeUser(params: {  activityOccurrenceId: number; userId: string; ban?: boolean; bypassRestrictions?: boolean; }, options: any = {}) {
        return ActivitiesApiFp.removeUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * In addition to user permissions requirements there is security based on the core_settings.results_trust setting. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, options: any = {}) {
        return ActivitiesApiFp.setActivityOccurrenceResults(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Sets the settings of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param settings The new settings
     */
    setActivityOccurrenceSettings(params: {  activityOccurrenceId: number; settings?: ActivityOccurrenceSettingsResource; }, options: any = {}) {
        return ActivitiesApiFp.setActivityOccurrenceSettings(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set a user's status within an occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param userId The id of the user
     * @param status The new status
     */
    setUserStatus(params: {  activityOccurrenceId: number; userId: string; status?: ActivityUserStatusWrapper; }, options: any = {}) {
        return ActivitiesApiFp.setUserStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  id: number; activityResource?: ActivityResource; }, options: any = {}) {
        return ActivitiesApiFp.updateActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If setting to 'FINISHED' reward will be run based on current metrics that have been recorded already. Alternatively, see results endpoint to finish and record all metrics at once. Can be called by non-host participants if non_host_status_control is true. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
     * @summary Update the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrenceStatus(params: {  activityOccurrenceId: number; activityOccurrenceStatus?: ActivityOccurrenceStatusWrapper; }, options: any = {}) {
        return ActivitiesApiFp.updateActivityOccurrenceStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, options: any = {}) {
        return ActivitiesApiFp.updateActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * ActivitiesApi - factory interface
 */
export const ActivitiesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * If called with no body, defaults to the user making the call.
         * @summary Add a user to an occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param test if true, indicates that the user should NOT be added. This can be used to test for eligibility
         * @param bypassRestrictions if true, indicates that restrictions such as max player count should be ignored. Can only be used with ACTIVITIES_ADMIN
         * @param userId The id of the user, or null for &#39;caller&#39;
         */
        addUser(params: {  activityOccurrenceId: number; test?: boolean; bypassRestrictions?: boolean; userId?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.addUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
         * @summary Create an activity
         * @param activityResource The activity resource object
         */
        createActivity(params: {  activityResource?: ActivityResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.createActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * Has to enforce extra rules if not used as an admin. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
         * @summary Create a new activity occurrence. Ex: start a game
         * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
         * @param activityOccurrenceResource The activity occurrence object
         */
        createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: CreateActivityOccurrenceRequest; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.createActivityOccurrence(params, configuration, options)(fetch, basePath);
        },
        /**
         * Activity Templates define a type of activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a activity template
         * @param activityTemplateResource The activity template resource object
         */
        createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.createActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
         * @summary Delete an activity
         * @param id The id of the activity
         */
        deleteActivity(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.deleteActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a activity template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteActivityTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.deleteActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List activity definitions
         * @param filterTemplate Filter for activities that are templates, or specifically not if false
         * @param filterName Filter for activities that have a name starting with specified string
         * @param filterId Filter for activities with an id in the given comma separated list of ids
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.getActivities(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single activity
         * @param id The id of the activity
         */
        getActivity(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.getActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
         * @summary Load a single activity occurrence details
         * @param activityOccurrenceId The id of the activity occurrence
         */
        getActivityOccurrenceDetails(params: {  activityOccurrenceId: number; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.getActivityOccurrenceDetails(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
         * @summary Get a single activity template
         * @param id The id of the template
         */
        getActivityTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.getActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACTIVITIES_ADMIN
         * @summary List and search activity templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.getActivityTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
         * @summary List activity occurrences
         * @param filterActivity Filter for occurrences of the given activity ID
         * @param filterStatus Filter for occurrences in the given status
         * @param filterEvent Filter for occurrences played during the given event
         * @param filterChallenge Filter for occurrences played within the given challenge
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        listActivityOccurrences(params: {  filterActivity?: string; filterStatus?: string; filterEvent?: number; filterChallenge?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.listActivityOccurrences(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a user from an occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param userId The id of the user, or &#39;me&#39;
         * @param ban if true, indicates that the user should not be allowed to re-join. Can only be set by host or admin
         * @param bypassRestrictions if true, indicates that restrictions such as current status should be ignored. Can only be used with ACTIVITIES_ADMIN
         */
        removeUser(params: {  activityOccurrenceId: number; userId: string; ban?: boolean; bypassRestrictions?: boolean; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.removeUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * In addition to user permissions requirements there is security based on the core_settings.results_trust setting. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER or ACTIVITIES_ADMIN
         * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityOccurrenceResults The activity occurrence object
         */
        setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.setActivityOccurrenceResults(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
         * @summary Sets the settings of an activity occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param settings The new settings
         */
        setActivityOccurrenceSettings(params: {  activityOccurrenceId: number; settings?: ActivityOccurrenceSettingsResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.setActivityOccurrenceSettings(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a user's status within an occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param userId The id of the user
         * @param status The new status
         */
        setUserStatus(params: {  activityOccurrenceId: number; userId: string; status?: ActivityUserStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.setUserStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACTIVITIES_ADMIN
         * @summary Update an activity
         * @param id The id of the activity
         * @param activityResource The activity resource object
         */
        updateActivity(params: {  id: number; activityResource?: ActivityResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.updateActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * If setting to 'FINISHED' reward will be run based on current metrics that have been recorded already. Alternatively, see results endpoint to finish and record all metrics at once. Can be called by non-host participants if non_host_status_control is true. <br><br><b>Permissions Needed:</b> ACTIVITIES_USER and host or ACTIVITIES_ADMIN
         * @summary Update the status of an activity occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityOccurrenceStatus The activity occurrence status object
         */
        updateActivityOccurrenceStatus(params: {  activityOccurrenceId: number; activityOccurrenceStatus?: ActivityOccurrenceStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.updateActivityOccurrenceStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an activity template
         * @param id The id of the template
         * @param activityTemplateResource The activity template resource object
         */
        updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return ActivitiesApiFp.updateActivityTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Amazon_Web_Services_S3Api - fetch parameter creator
 */
export const Amazon_Web_Services_S3ApiFetchParamCreator = {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details. <br><br><b>Permissions Needed:</b> S3_ADMIN
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative to the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/amazon/s3/downloadurl`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["bucket"] !== undefined) {
            urlObj.query["bucket"] = params["bucket"];
        }
        if (params["path"] !== undefined) {
            urlObj.query["path"] = params["path"];
        }
        if (params["expiration"] !== undefined) {
            urlObj.query["expiration"] = params["expiration"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after. <br><br><b>Permissions Needed:</b> S3_USER or S3_ADMIN
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  filename?: string; contentType?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/amazon/s3/signedposturl`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filename"] !== undefined) {
            urlObj.query["filename"] = params["filename"];
        }
        if (params["contentType"] !== undefined) {
            urlObj.query["content_type"] = params["contentType"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Amazon_Web_Services_S3Api - functional programming interface
 */
export const Amazon_Web_Services_S3ApiFp = {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details. <br><br><b>Permissions Needed:</b> S3_ADMIN
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative to the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: { bucket?: string; path?: string; expiration?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Amazon_Web_Services_S3ApiFetchParamCreator.getDownloadURL(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after. <br><br><b>Permissions Needed:</b> S3_USER or S3_ADMIN
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: { filename?: string; contentType?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AmazonS3Activity> {
        const fetchArgs = Amazon_Web_Services_S3ApiFetchParamCreator.getSignedS3URL(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Amazon_Web_Services_S3Api - object-oriented interface
 */
export class Amazon_Web_Services_S3Api extends BaseAPI {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details. <br><br><b>Permissions Needed:</b> S3_ADMIN
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative to the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, options: any = {}) {
        return Amazon_Web_Services_S3ApiFp.getDownloadURL(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after. <br><br><b>Permissions Needed:</b> S3_USER or S3_ADMIN
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  filename?: string; contentType?: string; }, options: any = {}) {
        return Amazon_Web_Services_S3ApiFp.getSignedS3URL(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Amazon_Web_Services_S3Api - factory interface
 */
export const Amazon_Web_Services_S3ApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details. <br><br><b>Permissions Needed:</b> S3_ADMIN
         * @summary Get a temporary signed S3 URL for download
         * @param bucket S3 bucket name
         * @param path The path to the file relative to the bucket (the s3 object key)
         * @param expiration The number of seconds this URL will be valid. Default to 60
         */
        getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, configuration: Configuration, options: any = {}) {
            return Amazon_Web_Services_S3ApiFp.getDownloadURL(params, configuration, options)(fetch, basePath);
        },
        /**
         * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after. <br><br><b>Permissions Needed:</b> S3_USER or S3_ADMIN
         * @summary Get a signed S3 URL for upload
         * @param filename The file name
         * @param contentType The content type
         */
        getSignedS3URL(params: {  filename?: string; contentType?: string; }, configuration: Configuration, options: any = {}) {
            return Amazon_Web_Services_S3ApiFp.getSignedS3URL(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Auth_ClientsApi - fetch parameter creator
 */
export const Auth_ClientsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  clientResource?: ClientResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  clientKey: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling deleteClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  clientKey: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List available client grant types
     */
    getClientGrantTypes(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients/grant-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientGrantTypes");
        }
        const baseUrl = `/auth/clients/{client_key}/grant-types`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantList"]) {
            fetchOptions.body = JSON.stringify(params["grantList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRedirectUris");
        }
        const baseUrl = `/auth/clients/{client_key}/redirect-uris`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redirectList"]) {
            fetchOptions.body = JSON.stringify(params["redirectList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling updateClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Auth_ClientsApi - functional programming interface
 */
export const Auth_ClientsApiFp = {
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: { clientResource?: ClientResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.createClient(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: { clientKey: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.deleteClient(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: { clientKey: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.getClient(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List available client grant types
     */
    getClientGrantTypes(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<GrantTypeResource>> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.getClientGrantTypes(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceClientResource> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.getClients(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: { clientKey: string; grantList?: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.setClientGrantTypes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: { clientKey: string; redirectList?: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.setClientRedirectUris(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: { clientKey: string; clientResource?: ClientResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = Auth_ClientsApiFetchParamCreator.updateClient(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Auth_ClientsApi - object-oriented interface
 */
export class Auth_ClientsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  clientResource?: ClientResource; }, options: any = {}) {
        return Auth_ClientsApiFp.createClient(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  clientKey: string; }, options: any = {}) {
        return Auth_ClientsApiFp.deleteClient(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  clientKey: string; }, options: any = {}) {
        return Auth_ClientsApiFp.getClient(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List available client grant types
     */
    getClientGrantTypes(options: any = {}) {
        return Auth_ClientsApiFp.getClientGrantTypes(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Auth_ClientsApiFp.getClients(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, options: any = {}) {
        return Auth_ClientsApiFp.setClientGrantTypes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, options: any = {}) {
        return Auth_ClientsApiFp.setClientRedirectUris(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CLIENTS_ADMIN
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, options: any = {}) {
        return Auth_ClientsApiFp.updateClient(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Auth_ClientsApi - factory interface
 */
export const Auth_ClientsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Create a new client
         * @param clientResource The client resource object
         */
        createClient(params: {  clientResource?: ClientResource; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.createClient(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Delete a client
         * @param clientKey The key of the client
         */
        deleteClient(params: {  clientKey: string; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.deleteClient(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Get a single client
         * @param clientKey The key of the client
         */
        getClient(params: {  clientKey: string; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.getClient(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary List available client grant types
         */
        getClientGrantTypes(configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.getClientGrantTypes(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary List and search clients
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getClients(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.getClients(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Set grant types for a client
         * @param clientKey The key of the client
         * @param grantList A list of unique grant types
         */
        setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.setClientGrantTypes(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Set redirect uris for a client
         * @param clientKey The key of the client
         * @param redirectList A list of unique redirect uris
         */
        setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.setClientRedirectUris(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CLIENTS_ADMIN
         * @summary Update a client
         * @param clientKey The key of the client
         * @param clientResource The client resource object
         */
        updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, configuration: Configuration, options: any = {}) {
            return Auth_ClientsApiFp.updateClient(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Auth_PermissionsApi - fetch parameter creator
 */
export const Auth_PermissionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  permissionResource?: PermissionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  permission: string; force?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling deletePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["force"] !== undefined) {
            urlObj.query["force"] = params["force"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  permission: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling getPermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling updatePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Auth_PermissionsApi - functional programming interface
 */
export const Auth_PermissionsApiFp = {
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: { permissionResource?: PermissionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = Auth_PermissionsApiFetchParamCreator.createPermission(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: { permission: string; force?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_PermissionsApiFetchParamCreator.deletePermission(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: { permission: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = Auth_PermissionsApiFetchParamCreator.getPermission(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcePermissionResource> {
        const fetchArgs = Auth_PermissionsApiFetchParamCreator.getPermissions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: { permission: string; permissionResource?: PermissionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = Auth_PermissionsApiFetchParamCreator.updatePermission(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Auth_PermissionsApi - object-oriented interface
 */
export class Auth_PermissionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  permissionResource?: PermissionResource; }, options: any = {}) {
        return Auth_PermissionsApiFp.createPermission(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  permission: string; force?: boolean; }, options: any = {}) {
        return Auth_PermissionsApiFp.deletePermission(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  permission: string; }, options: any = {}) {
        return Auth_PermissionsApiFp.getPermission(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Auth_PermissionsApiFp.getPermissions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, options: any = {}) {
        return Auth_PermissionsApiFp.updatePermission(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Auth_PermissionsApi - factory interface
 */
export const Auth_PermissionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
         * @summary Create a new permission
         * @param permissionResource The permission resource object
         */
        createPermission(params: {  permissionResource?: PermissionResource; }, configuration: Configuration, options: any = {}) {
            return Auth_PermissionsApiFp.createPermission(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
         * @summary Delete a permission
         * @param permission The permission value
         * @param force If true, removes permission assigned to roles
         */
        deletePermission(params: {  permission: string; force?: boolean; }, configuration: Configuration, options: any = {}) {
            return Auth_PermissionsApiFp.deletePermission(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
         * @summary Get a single permission
         * @param permission The permission value
         */
        getPermission(params: {  permission: string; }, configuration: Configuration, options: any = {}) {
            return Auth_PermissionsApiFp.getPermission(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
         * @summary List and search permissions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPermissions(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Auth_PermissionsApiFp.getPermissions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PERMISSIONS_ADMIN
         * @summary Update a permission
         * @param permission The permission value
         * @param permissionResource The permission resource object
         */
        updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, configuration: Configuration, options: any = {}) {
            return Auth_PermissionsApiFp.updatePermission(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Auth_RolesApi - fetch parameter creator
 */
export const Auth_RolesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  roleResource?: RoleResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  role: string; force?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling deleteRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["force"] !== undefined) {
            urlObj.query["force"] = params["force"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  clientKey: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: {  role: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling getRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterRole"] !== undefined) {
            urlObj.query["filter_role"] = params["filterRole"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling setPermissionsForRole");
        }
        const baseUrl = `/auth/roles/{role}/permissions`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionsList"]) {
            fetchOptions.body = JSON.stringify(params["permissionsList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  role: string; roleResource?: RoleResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling updateRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Auth_RolesApi - functional programming interface
 */
export const Auth_RolesApiFp = {
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: { roleResource?: RoleResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.createRole(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: { role: string; force?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.deleteRole(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: { clientKey: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.getClientRoles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: { role: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.getRole(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: { filterName?: string; filterRole?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRoleResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.getRoles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: { userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.getUserRoles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: { clientKey: string; rolesList?: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.setClientRoles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: { role: string; permissionsList?: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.setPermissionsForRole(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: { userId: number; rolesList?: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.setUserRoles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: { role: string; roleResource?: RoleResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = Auth_RolesApiFetchParamCreator.updateRole(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Auth_RolesApi - object-oriented interface
 */
export class Auth_RolesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  roleResource?: RoleResource; }, options: any = {}) {
        return Auth_RolesApiFp.createRole(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  role: string; force?: boolean; }, options: any = {}) {
        return Auth_RolesApiFp.deleteRole(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  clientKey: string; }, options: any = {}) {
        return Auth_RolesApiFp.getClientRoles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: {  role: string; }, options: any = {}) {
        return Auth_RolesApiFp.getRole(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Auth_RolesApiFp.getRoles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  userId: number; }, options: any = {}) {
        return Auth_RolesApiFp.getUserRoles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, options: any = {}) {
        return Auth_RolesApiFp.setClientRoles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, options: any = {}) {
        return Auth_RolesApiFp.setPermissionsForRole(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, options: any = {}) {
        return Auth_RolesApiFp.setUserRoles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ROLES_ADMIN
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  role: string; roleResource?: RoleResource; }, options: any = {}) {
        return Auth_RolesApiFp.updateRole(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Auth_RolesApi - factory interface
 */
export const Auth_RolesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Create a new role
         * @param roleResource The role resource object
         */
        createRole(params: {  roleResource?: RoleResource; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.createRole(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Delete a role
         * @param role The role value
         * @param force If true, removes role from users/clients
         */
        deleteRole(params: {  role: string; force?: boolean; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.deleteRole(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Get roles for a client
         * @param clientKey The client key
         */
        getClientRoles(params: {  clientKey: string; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.getClientRoles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Get a single role
         * @param role The role value
         */
        getRole(params: {  role: string; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.getRole(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary List and search roles
         * @param filterName Filter for roles that have a name starting with specified string
         * @param filterRole Filter for roles that have a role starting with specified string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.getRoles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Get roles for a user
         * @param userId The user&#39;s id
         */
        getUserRoles(params: {  userId: number; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.getUserRoles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Set roles for a client
         * @param clientKey The client key
         * @param rolesList The list of unique roles
         */
        setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.setClientRoles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Set permissions for a role
         * @param role The role value
         * @param permissionsList The list of unique permissions
         */
        setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.setPermissionsForRole(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Set roles for a user
         * @param userId The user&#39;s id
         * @param rolesList The list of unique roles
         */
        setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.setUserRoles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ROLES_ADMIN
         * @summary Update a role
         * @param role The role value
         * @param roleResource The role resource object
         */
        updateRole(params: {  role: string; roleResource?: RoleResource; }, configuration: Configuration, options: any = {}) {
            return Auth_RolesApiFp.updateRole(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Auth_TokensApi - fetch parameter creator
 */
export const Auth_TokensApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: {  username?: string; clientId?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/tokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["username"] !== undefined) {
            urlObj.query["username"] = params["username"];
        }
        if (params["clientId"] !== undefined) {
            urlObj.query["client_id"] = params["clientId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  username: string; clientId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling getToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling getToken");
        }
        const baseUrl = `/auth/tokens/{username}/{client_id}`
            .replace(`{${"username"}}`, `${ params["username"] }`)
            .replace(`{${"client_id"}}`, `${ params["clientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Token value not shown. <br><br><b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/auth/tokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterClientId"] !== undefined) {
            urlObj.query["filter_client_id"] = params["filterClientId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Auth_TokensApi - functional programming interface
 */
export const Auth_TokensApiFp = {
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: { username?: string; clientId?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Auth_TokensApiFetchParamCreator.deleteTokens(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: { username: string; clientId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OauthAccessTokenResource> {
        const fetchArgs = Auth_TokensApiFetchParamCreator.getToken(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Token value not shown. <br><br><b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: { filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceOauthAccessTokenResource> {
        const fetchArgs = Auth_TokensApiFetchParamCreator.getTokens(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Auth_TokensApi - object-oriented interface
 */
export class Auth_TokensApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: {  username?: string; clientId?: string; }, options: any = {}) {
        return Auth_TokensApiFp.deleteTokens(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  username: string; clientId: string; }, options: any = {}) {
        return Auth_TokensApiFp.getToken(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Token value not shown. <br><br><b>Permissions Needed:</b> TOKENS_ADMIN
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Auth_TokensApiFp.getTokens(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Auth_TokensApi - factory interface
 */
export const Auth_TokensApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> TOKENS_ADMIN
         * @summary Delete tokens by username, client id, or both
         * @param username The username of the user
         * @param clientId The id of the client
         */
        deleteTokens(params: {  username?: string; clientId?: string; }, configuration: Configuration, options: any = {}) {
            return Auth_TokensApiFp.deleteTokens(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TOKENS_ADMIN
         * @summary Get a single token by username and client id
         * @param username The username of the user
         * @param clientId The id of the client
         */
        getToken(params: {  username: string; clientId: string; }, configuration: Configuration, options: any = {}) {
            return Auth_TokensApiFp.getToken(params, configuration, options)(fetch, basePath);
        },
        /**
         * Token value not shown. <br><br><b>Permissions Needed:</b> TOKENS_ADMIN
         * @summary List usernames and client ids
         * @param filterClientId Filters for token whose client id matches provided string
         * @param filterUsername Filters for token whose username matches provided string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Auth_TokensApiFp.getTokens(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsApi - fetch parameter creator
 */
export const CampaignsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  id: number; challengeId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addChallengeToCampaign");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeId"]) {
            fetchOptions.body = JSON.stringify(params["challengeId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  campaignResource?: CampaignResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Campaign Templates define a type of campaign and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignChallenges");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActive"] !== undefined) {
            urlObj.query["filter_active"] = params["filterActive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling removeChallengeFromCampaign");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeChallengeFromCampaign");
        }
        const baseUrl = `/campaigns/{campaign_id}/challenges/{id}`
            .replace(`{${"campaign_id"}}`, `${ params["campaignId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsApi - functional programming interface
 */
export const CampaignsApiFp = {
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: { id: number; challengeId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.addChallengeToCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: { campaignResource?: CampaignResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Campaign Templates define a type of campaign and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: { campaignTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaignTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaignTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: { id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignChallenges(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: { filterActive?: boolean; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaigns(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: { campaignId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.removeChallengeFromCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: { id: number; campaignResource?: CampaignResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaign(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: { id: string; campaignTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaignTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsApi - object-oriented interface
 */
export class CampaignsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  id: number; challengeId?: number; }, options: any = {}) {
        return CampaignsApiFp.addChallengeToCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  campaignResource?: CampaignResource; }, options: any = {}) {
        return CampaignsApiFp.createCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Campaign Templates define a type of campaign and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsApiFp.createCampaignTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  id: number; }, options: any = {}) {
        return CampaignsApiFp.deleteCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CampaignsApiFp.deleteCampaignTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  id: number; }, options: any = {}) {
        return CampaignsApiFp.getCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignChallenges(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  id: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaigns(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, options: any = {}) {
        return CampaignsApiFp.removeChallengeFromCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, options: any = {}) {
        return CampaignsApiFp.updateCampaign(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsApiFp.updateCampaignTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsApi - factory interface
 */
export const CampaignsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
         * @summary Add a challenge to a campaign
         * @param id The id of the campaign
         * @param challengeId The id of the challenge
         */
        addChallengeToCampaign(params: {  id: number; challengeId?: number; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.addChallengeToCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
         * @summary Create a campaign
         * @param campaignResource The campaign resource object
         */
        createCampaign(params: {  campaignResource?: CampaignResource; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.createCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * Campaign Templates define a type of campaign and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a campaign template
         * @param campaignTemplateResource The campaign template resource object
         */
        createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.createCampaignTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
         * @summary Delete a campaign
         * @param id The campaign id
         */
        deleteCampaign(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.deleteCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a campaign template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCampaignTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.deleteCampaignTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a single campaign
         * @param id The campaign id
         */
        getCampaign(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.getCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List the challenges associated with a campaign
         * @param id The campaign id
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.getCampaignChallenges(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
         * @summary Get a single campaign template
         * @param id The id of the template
         */
        getCampaignTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.getCampaignTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CAMPAIGNS_ADMIN
         * @summary List and search campaign templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.getCampaignTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search campaigns
         * @param filterActive Filter for campaigns that are active
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.getCampaigns(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
         * @summary Remove a challenge from a campaign
         * @param campaignId The campaign id
         * @param id The challenge id
         */
        removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.removeChallengeFromCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CAMPAIGNS_ADMIN
         * @summary Update a campaign
         * @param id The campaign id
         * @param campaignResource The campaign resource object
         */
        updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.updateCampaign(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an campaign template
         * @param id The id of the template
         * @param campaignTemplateResource The campaign template resource object
         */
        updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return CampaignsApiFp.updateCampaignTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Campaigns_ChallengesApi - fetch parameter creator
 */
export const Campaigns_ChallengesApiFetchParamCreator = {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  challengeResource?: ChallengeResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling createChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["validateSettings"] !== undefined) {
            urlObj.query["validate_settings"] = params["validateSettings"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenge-activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Challenge Templates define a type of challenge and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  id: number; challengeId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling deleteChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling getChallengeActivities");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: {  id: number; challengeId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling getChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenge-activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/events`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["filterCampaigns"] !== undefined) {
            urlObj.query["filter_campaigns"] = params["filterCampaigns"];
        }
        if (params["filterChallenge"] !== undefined) {
            urlObj.query["filter_challenge"] = params["filterChallenge"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenges
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: {  filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActiveCampaign"] !== undefined) {
            urlObj.query["filter_active_campaign"] = params["filterActiveCampaign"];
        }
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling updateChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["validateSettings"] !== undefined) {
            urlObj.query["validateSettings"] = params["validateSettings"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Campaigns_ChallengesApi - functional programming interface
 */
export const Campaigns_ChallengesApiFp = {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: { challengeResource?: ChallengeResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.createChallenge(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: { challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.createChallengeActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: { challengeActivityTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.createChallengeActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Challenge Templates define a type of challenge and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: { challengeTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.createChallengeTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.deleteChallenge(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: { id: number; challengeId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.deleteChallengeActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.deleteChallengeActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.deleteChallengeEvent(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.deleteChallengeTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallenge(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: { challengeId: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBareChallengeActivityResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeActivities(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: { id: number; challengeId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeActivityTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeEventResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeEvent(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: { filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeEvents(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallengeTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenges
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: { filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.getChallenges(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: { id: number; challengeResource?: ChallengeResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.updateChallenge(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    updateChallengeActivity(params: { id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.updateChallengeActivity(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: { id: string; challengeActivityTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.updateChallengeActivityTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: { id: string; challengeTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Campaigns_ChallengesApiFetchParamCreator.updateChallengeTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Campaigns_ChallengesApi - object-oriented interface
 */
export class Campaigns_ChallengesApi extends BaseAPI {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  challengeResource?: ChallengeResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.createChallenge(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.createChallengeActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.createChallengeActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Challenge Templates define a type of challenge and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.createChallengeTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  id: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.deleteChallenge(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.deleteChallengeActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.deleteChallengeActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  id: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.deleteChallengeEvent(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.deleteChallengeTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  id: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallenge(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeActivities(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: {  id: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeActivityTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  id: number; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeEvent(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeEvents(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  id: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallengeTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a list of challenges
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: {  filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.getChallenges(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.updateChallenge(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.updateChallengeActivity(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.updateChallengeActivityTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, options: any = {}) {
        return Campaigns_ChallengesApiFp.updateChallengeTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Campaigns_ChallengesApi - factory interface
 */
export const Campaigns_ChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Challenges do not run on their own.  They must be added to a campaign before events will spawn. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Create a challenge
         * @param challengeResource The challenge resource object
         */
        createChallenge(params: {  challengeResource?: ChallengeResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.createChallenge(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Create a challenge activity
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
         */
        createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.createChallengeActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * Challenge Activity Templates define a type of challenge activity and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a challenge activity template
         * @param challengeActivityTemplateResource The challengeActivity template resource object
         */
        createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.createChallengeActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Challenge Templates define a type of challenge and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a challenge template
         * @param challengeTemplateResource The challenge template resource object
         */
        createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.createChallengeTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Delete a challenge
         * @param id The challenge id
         */
        deleteChallenge(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.deleteChallenge(params, configuration, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Delete a challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         */
        deleteChallengeActivity(params: {  id: number; challengeId: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.deleteChallengeActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a challenge activity template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.deleteChallengeActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Delete a challenge event
         * @param id The challenge event id
         */
        deleteChallengeEvent(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.deleteChallengeEvent(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a challenge template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteChallengeTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.deleteChallengeTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Retrieve a challenge
         * @param id The challenge id
         */
        getChallenge(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallenge(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search challenge activities
         * @param challengeId The challenge id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeActivities(params, configuration, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get a single challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         */
        getChallengeActivity(params: {  id: number; challengeId: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
         * @summary Get a single challenge activity template
         * @param id The id of the template
         */
        getChallengeActivityTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
         * @summary List and search challenge activity templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeActivityTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Retrieve a single challenge event details
         * @param id The challenge event id
         */
        getChallengeEvent(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeEvent(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Retrieve a list of challenge events
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterCampaigns check only for events from currently running campaigns
         * @param filterChallenge check only for events from the challenge specified by id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeEvents(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
         * @summary Get a single challenge template
         * @param id The id of the template
         */
        getChallengeTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CHALLENGES_ADMIN
         * @summary List and search challenge templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallengeTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Retrieve a list of challenges
         * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallenges(params: {  filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.getChallenges(params, configuration, options)(fetch, basePath);
        },
        /**
         * If the challenge is a copy, changes will propagate to all the related challenges. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Update a challenge
         * @param id The challenge id
         * @param challengeResource The challenge resource object
         */
        updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.updateChallenge(params, configuration, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge. <br><br><b>Permissions Needed:</b> CHALLENGES_ADMIN
         * @summary Update a challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
         */
        updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.updateChallengeActivity(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an challenge activity template
         * @param id The id of the template
         * @param challengeActivityTemplateResource The challengeActivity template resource object
         */
        updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.updateChallengeActivityTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a challenge template
         * @param id The id of the template
         * @param challengeTemplateResource The challenge template resource object
         */
        updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_ChallengesApiFp.updateChallengeTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Campaigns_RewardsApi - fetch parameter creator
 */
export const Campaigns_RewardsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Campaigns_RewardsApi - functional programming interface
 */
export const Campaigns_RewardsApiFp = {
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: { rewardSetResource?: RewardSetResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = Campaigns_RewardsApiFetchParamCreator.createRewardSet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Campaigns_RewardsApiFetchParamCreator.deleteRewardSet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = Campaigns_RewardsApiFetchParamCreator.getRewardSet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRewardSetResource> {
        const fetchArgs = Campaigns_RewardsApiFetchParamCreator.getRewardSets(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: { id: number; rewardSetResource?: RewardSetResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = Campaigns_RewardsApiFetchParamCreator.updateRewardSet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Campaigns_RewardsApi - object-oriented interface
 */
export class Campaigns_RewardsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, options: any = {}) {
        return Campaigns_RewardsApiFp.createRewardSet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  id: number; }, options: any = {}) {
        return Campaigns_RewardsApiFp.deleteRewardSet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  id: number; }, options: any = {}) {
        return Campaigns_RewardsApiFp.getRewardSet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Campaigns_RewardsApiFp.getRewardSets(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> REWARDS_ADMIN
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, options: any = {}) {
        return Campaigns_RewardsApiFp.updateRewardSet(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Campaigns_RewardsApi - factory interface
 */
export const Campaigns_RewardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> REWARDS_ADMIN
         * @summary Create a reward set
         * @param rewardSetResource The reward set resource object
         */
        createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_RewardsApiFp.createRewardSet(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> REWARDS_ADMIN
         * @summary Delete a reward set
         * @param id The reward id
         */
        deleteRewardSet(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_RewardsApiFp.deleteRewardSet(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single reward set
         * @param id The reward id
         */
        getRewardSet(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Campaigns_RewardsApiFp.getRewardSet(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search reward sets
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRewardSets(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Campaigns_RewardsApiFp.getRewardSets(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> REWARDS_ADMIN
         * @summary Update a reward set
         * @param id The reward id
         * @param rewardSetResource The reward set resource object
         */
        updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, configuration: Configuration, options: any = {}) {
            return Campaigns_RewardsApiFp.updateRewardSet(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * CategoriesApi - fetch parameter creator
 */
export const CategoriesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: {  category?: CategoryResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Templates define a type of category and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: {  template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterActive"] !== undefined) {
            urlObj.query["filter_active"] = params["filterActive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  id: string; category?: CategoryResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = {
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: { category?: CategoryResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Templates define a type of category and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: { template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategoryTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategoryTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: { filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategories(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: { size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcestring> {
        const fetchArgs = CategoriesApiFetchParamCreator.getTags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: { id: string; category?: CategoryResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: { id: string; template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategoryTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: {  category?: CategoryResource; }, options: any = {}) {
        return CategoriesApiFp.createCategory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Templates define a type of category and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
        return CategoriesApiFp.createCategoryTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.deleteCategory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CategoriesApiFp.deleteCategoryTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CategoriesApiFp.getCategories(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.getCategory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.getCategoryTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CategoriesApiFp.getCategoryTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  size?: number; page?: number; }, options: any = {}) {
        return CategoriesApiFp.getTags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CATEGORIES_ADMIN
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  id: string; category?: CategoryResource; }, options: any = {}) {
        return CategoriesApiFp.updateCategory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
        return CategoriesApiFp.updateCategoryTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> CATEGORIES_ADMIN
         * @summary Create a new category
         * @param category The category to create
         */
        createCategory(params: {  category?: CategoryResource; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.createCategory(params, configuration, options)(fetch, basePath);
        },
        /**
         * Templates define a type of category and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a category template
         * @param template The template to create
         */
        createCategoryTemplate(params: {  template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.createCategoryTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CATEGORIES_ADMIN
         * @summary Delete an existing category
         * @param id The id of the category to be deleted
         */
        deleteCategory(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.deleteCategory(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a category template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCategoryTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.deleteCategoryTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search categories with optional filters
         * @param filterSearch Filter for categories whose names begin with provided string
         * @param filterActive Filter for categories that are specifically active or inactive
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.getCategories(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single category
         * @param id The id of the category to retrieve
         */
        getCategory(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.getCategory(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
         * @summary Get a single category template
         * @param id The id of the template
         */
        getCategoryTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.getCategoryTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or CATEGORIES_ADMIN
         * @summary List and search category templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.getCategoryTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List all trivia tags in the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getTags(params: {  size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.getTags(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CATEGORIES_ADMIN
         * @summary Update an existing category
         * @param id The id of the category
         * @param category The category to update
         */
        updateCategory(params: {  id: string; category?: CategoryResource; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.updateCategory(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a category template
         * @param id The id of the template
         * @param template The updated template information
         */
        updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return CategoriesApiFp.updateCategoryTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * ChatApi - fetch parameter creator
 */
export const ChatApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Acknowledge number of messages in a thread
     * @param id The thread id
     * @param readCount The amount of messages read
     */
    acknowledgeChatMessage(params: {  id: string; readCount?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling acknowledgeChatMessage");
        }
        const baseUrl = `/chat/threads/{id}/acknowledge`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["readCount"]) {
            fetchOptions.body = JSON.stringify(params["readCount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Add a user to a chat message blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    addChatMessageBlacklist(params: {  blacklistedUserId: number; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "blacklistedUserId" is set
        if (params["blacklistedUserId"] == null) {
            throw new Error("Missing required parameter blacklistedUserId when calling addChatMessageBlacklist");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addChatMessageBlacklist");
        }
        const baseUrl = `/chat/users/{id}/blacklist/{blacklisted_user_id}`
            .replace(`{${"blacklisted_user_id"}}`, `${ params["blacklistedUserId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Delete a message
     * @param id The message id
     */
    deleteChatMessage(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChatMessage");
        }
        const baseUrl = `/chat/messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Edit your message
     * @param id The message id
     * @param chatMessageResource The chat message resource
     */
    editChatMessage(params: {  id: string; chatMessageResource?: ChatMessageResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling editChatMessage");
        }
        const baseUrl = `/chat/messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["chatMessageResource"]) {
            fetchOptions.body = JSON.stringify(params["chatMessageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a message
     * @param id The message id
     */
    getChatMessage(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChatMessage");
        }
        const baseUrl = `/chat/messages/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a list of blocked users for chat messaging
     * @param id The user id or &#39;me&#39;
     */
    getChatMessageBlacklist(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChatMessageBlacklist");
        }
        const baseUrl = `/chat/users/{id}/blacklist`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List your threads
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChatThreads(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/chat/threads`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List messages with a user
     * @param id The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDirectMessages(params: {  id: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDirectMessages");
        }
        const baseUrl = `/chat/users/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a thread
     * @param id The thread id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getThreadMessages(params: {  id: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getThreadMessages");
        }
        const baseUrl = `/chat/threads/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a topic
     * @param id The topic id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTopicMessages(params: {  id: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTopicMessages");
        }
        const baseUrl = `/chat/topics/{id}/messages`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Remove a user from a blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    removeChatBlacklist(params: {  blacklistedUserId: number; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "blacklistedUserId" is set
        if (params["blacklistedUserId"] == null) {
            throw new Error("Missing required parameter blacklistedUserId when calling removeChatBlacklist");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeChatBlacklist");
        }
        const baseUrl = `/chat/users/{id}/blacklist/{blacklisted_user_id}`
            .replace(`{${"blacklisted_user_id"}}`, `${ params["blacklistedUserId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Send a message
     * @param chatMessageResource The chat message resource
     */
    sendChatMessage(params: {  chatMessageResource?: ChatMessageResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/chat/messages`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["chatMessageResource"]) {
            fetchOptions.body = JSON.stringify(params["chatMessageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ChatApi - functional programming interface
 */
export const ChatApiFp = {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Acknowledge number of messages in a thread
     * @param id The thread id
     * @param readCount The amount of messages read
     */
    acknowledgeChatMessage(params: { id: string; readCount?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ChatApiFetchParamCreator.acknowledgeChatMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Add a user to a chat message blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    addChatMessageBlacklist(params: { blacklistedUserId: number; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ChatApiFetchParamCreator.addChatMessageBlacklist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Delete a message
     * @param id The message id
     */
    deleteChatMessage(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ChatApiFetchParamCreator.deleteChatMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Edit your message
     * @param id The message id
     * @param chatMessageResource The chat message resource
     */
    editChatMessage(params: { id: string; chatMessageResource?: ChatMessageResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ChatApiFetchParamCreator.editChatMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a message
     * @param id The message id
     */
    getChatMessage(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChatMessageResource> {
        const fetchArgs = ChatApiFetchParamCreator.getChatMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a list of blocked users for chat messaging
     * @param id The user id or &#39;me&#39;
     */
    getChatMessageBlacklist(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<ChatBlacklistResource>> {
        const fetchArgs = ChatApiFetchParamCreator.getChatMessageBlacklist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List your threads
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChatThreads(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatUserThreadResource> {
        const fetchArgs = ChatApiFetchParamCreator.getChatThreads(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List messages with a user
     * @param id The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDirectMessages(params: { id: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatMessageResource> {
        const fetchArgs = ChatApiFetchParamCreator.getDirectMessages(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a thread
     * @param id The thread id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getThreadMessages(params: { id: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatMessageResource> {
        const fetchArgs = ChatApiFetchParamCreator.getThreadMessages(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a topic
     * @param id The topic id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTopicMessages(params: { id: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatMessageResource> {
        const fetchArgs = ChatApiFetchParamCreator.getTopicMessages(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Remove a user from a blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    removeChatBlacklist(params: { blacklistedUserId: number; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ChatApiFetchParamCreator.removeChatBlacklist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Send a message
     * @param chatMessageResource The chat message resource
     */
    sendChatMessage(params: { chatMessageResource?: ChatMessageResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChatMessageResource> {
        const fetchArgs = ChatApiFetchParamCreator.sendChatMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ChatApi - object-oriented interface
 */
export class ChatApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Acknowledge number of messages in a thread
     * @param id The thread id
     * @param readCount The amount of messages read
     */
    acknowledgeChatMessage(params: {  id: string; readCount?: number; }, options: any = {}) {
        return ChatApiFp.acknowledgeChatMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Add a user to a chat message blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    addChatMessageBlacklist(params: {  blacklistedUserId: number; id: string; }, options: any = {}) {
        return ChatApiFp.addChatMessageBlacklist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Delete a message
     * @param id The message id
     */
    deleteChatMessage(params: {  id: string; }, options: any = {}) {
        return ChatApiFp.deleteChatMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Edit your message
     * @param id The message id
     * @param chatMessageResource The chat message resource
     */
    editChatMessage(params: {  id: string; chatMessageResource?: ChatMessageResource; }, options: any = {}) {
        return ChatApiFp.editChatMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a message
     * @param id The message id
     */
    getChatMessage(params: {  id: string; }, options: any = {}) {
        return ChatApiFp.getChatMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Get a list of blocked users for chat messaging
     * @param id The user id or &#39;me&#39;
     */
    getChatMessageBlacklist(params: {  id: string; }, options: any = {}) {
        return ChatApiFp.getChatMessageBlacklist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List your threads
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChatThreads(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ChatApiFp.getChatThreads(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> owner
     * @summary List messages with a user
     * @param id The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDirectMessages(params: {  id: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ChatApiFp.getDirectMessages(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a thread
     * @param id The thread id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getThreadMessages(params: {  id: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ChatApiFp.getThreadMessages(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary List messages in a topic
     * @param id The topic id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTopicMessages(params: {  id: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ChatApiFp.getTopicMessages(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CHAT_ADMIN or owner
     * @summary Remove a user from a blacklist
     * @param blacklistedUserId The user id to blacklist
     * @param id The user id or &#39;me&#39;
     */
    removeChatBlacklist(params: {  blacklistedUserId: number; id: string; }, options: any = {}) {
        return ChatApiFp.removeChatBlacklist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Send a message
     * @param chatMessageResource The chat message resource
     */
    sendChatMessage(params: {  chatMessageResource?: ChatMessageResource; }, options: any = {}) {
        return ChatApiFp.sendChatMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * ChatApi - factory interface
 */
export const ChatApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> owner
         * @summary Acknowledge number of messages in a thread
         * @param id The thread id
         * @param readCount The amount of messages read
         */
        acknowledgeChatMessage(params: {  id: string; readCount?: number; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.acknowledgeChatMessage(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary Add a user to a chat message blacklist
         * @param blacklistedUserId The user id to blacklist
         * @param id The user id or &#39;me&#39;
         */
        addChatMessageBlacklist(params: {  blacklistedUserId: number; id: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.addChatMessageBlacklist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary Delete a message
         * @param id The message id
         */
        deleteChatMessage(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.deleteChatMessage(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> owner
         * @summary Edit your message
         * @param id The message id
         * @param chatMessageResource The chat message resource
         */
        editChatMessage(params: {  id: string; chatMessageResource?: ChatMessageResource; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.editChatMessage(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary Get a message
         * @param id The message id
         */
        getChatMessage(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getChatMessage(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary Get a list of blocked users for chat messaging
         * @param id The user id or &#39;me&#39;
         */
        getChatMessageBlacklist(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getChatMessageBlacklist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> owner
         * @summary List your threads
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChatThreads(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getChatThreads(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> owner
         * @summary List messages with a user
         * @param id The user id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDirectMessages(params: {  id: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getDirectMessages(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary List messages in a thread
         * @param id The thread id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getThreadMessages(params: {  id: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getThreadMessages(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary List messages in a topic
         * @param id The topic id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTopicMessages(params: {  id: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.getTopicMessages(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CHAT_ADMIN or owner
         * @summary Remove a user from a blacklist
         * @param blacklistedUserId The user id to blacklist
         * @param id The user id or &#39;me&#39;
         */
        removeChatBlacklist(params: {  blacklistedUserId: number; id: string; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.removeChatBlacklist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Send a message
         * @param chatMessageResource The chat message resource
         */
        sendChatMessage(params: {  chatMessageResource?: ChatMessageResource; }, configuration: Configuration, options: any = {}) {
            return ChatApiFp.sendChatMessage(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * ConfigsApi - fetch parameter creator
 */
export const ConfigsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: {  config?: Config; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Only configs that are public readable will be shown without admin access. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  name: string; config?: Config; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ConfigsApi - functional programming interface
 */
export const ConfigsApiFp = {
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: { config?: Config;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.createConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.deleteConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Only configs that are public readable will be shown without admin access. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: { filterSearch?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceConfig> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfigs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: { name: string; config?: Config;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.updateConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ConfigsApi - object-oriented interface
 */
export class ConfigsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: {  config?: Config; }, options: any = {}) {
        return ConfigsApiFp.createConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  name: string; }, options: any = {}) {
        return ConfigsApiFp.deleteConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Only configs that are public readable will be shown without admin access. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: {  name: string; }, options: any = {}) {
        return ConfigsApiFp.getConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ConfigsApiFp.getConfigs(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CONFIGS_ADMIN
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  name: string; config?: Config; }, options: any = {}) {
        return ConfigsApiFp.updateConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * ConfigsApi - factory interface
 */
export const ConfigsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> CONFIGS_ADMIN
         * @summary Create a new config
         * @param config The config object
         */
        createConfig(params: {  config?: Config; }, configuration: Configuration, options: any = {}) {
            return ConfigsApiFp.createConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CONFIGS_ADMIN
         * @summary Delete an existing config
         * @param name The config name
         */
        deleteConfig(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return ConfigsApiFp.deleteConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * Only configs that are public readable will be shown without admin access. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get a single config
         * @param name The config name
         */
        getConfig(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return ConfigsApiFp.getConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search configs
         * @param filterSearch Filter for configs whose name contains the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ConfigsApiFp.getConfigs(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CONFIGS_ADMIN
         * @summary Update an existing config
         * @param name The config name
         * @param config The config object
         */
        updateConfig(params: {  name: string; config?: Config; }, configuration: Configuration, options: any = {}) {
            return ConfigsApiFp.updateConfig(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Content_ArticlesApi - fetch parameter creator
 */
export const Content_ArticlesApiFetchParamCreator = {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.<br><br><b>Permissions:</b> ARTICLES_ADMIN
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: {  articleResource?: ArticleResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Article Templates define a type of article and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Create a template
     * @param typeHint The type for the resource this template applies to
     * @param template The template
     */
    createTemplate(params: {  typeHint: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling createTemplate");
        }
        const baseUrl = `/templates/{type_hint}`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Delete a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param cascade How to cascade the delete
     */
    deleteTemplate(params: {  typeHint: string; id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling deleteTemplate");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteTemplate");
        }
        const baseUrl = `/templates/{type_hint}/{id}`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cascade"]) {
            fetchOptions.body = JSON.stringify(params["cascade"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActiveOnly"] !== undefined) {
            urlObj.query["filter_active_only"] = params["filterActiveOnly"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterTagIntersection"] !== undefined) {
            urlObj.query["filter_tag_intersection"] = params["filterTagIntersection"];
        }
        if (params["filterTagExclusion"] !== undefined) {
            urlObj.query["filter_tag_exclusion"] = params["filterTagExclusion"];
        }
        if (params["filterTitle"] !== undefined) {
            urlObj.query["filter_title"] = params["filterTitle"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Get a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     */
    getTemplate(params: {  typeHint: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling getTemplate");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTemplate");
        }
        const baseUrl = `/templates/{type_hint}/{id}`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary List and search templates
     * @param typeHint The type for the resource this template applies to
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTemplates(params: {  typeHint: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling getTemplates");
        }
        const baseUrl = `/templates/{type_hint}`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  id: string; articleResource?: ArticleResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Update a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param template The template
     */
    updateTemplate(params: {  typeHint: string; id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling updateTemplate");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateTemplate");
        }
        const baseUrl = `/templates/{type_hint}/{id}`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Error code thrown if invalid.<br><br><b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Validate a templated resource
     * @param typeHint The type for the resource this template applies to
     * @param resource The resource to validate
     */
    validate(params: {  typeHint: string; resource?: BasicTemplatedResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeHint" is set
        if (params["typeHint"] == null) {
            throw new Error("Missing required parameter typeHint when calling validate");
        }
        const baseUrl = `/templates/{type_hint}/validate`
            .replace(`{${"type_hint"}}`, `${ params["typeHint"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["resource"]) {
            fetchOptions.body = JSON.stringify(params["resource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Content_ArticlesApi - functional programming interface
 */
export const Content_ArticlesApiFp = {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.<br><br><b>Permissions:</b> ARTICLES_ADMIN
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: { articleResource?: ArticleResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.createArticle(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Article Templates define a type of article and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: { articleTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.createArticleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Create a template
     * @param typeHint The type for the resource this template applies to
     * @param template The template
     */
    createTemplate(params: { typeHint: string; template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.createTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.deleteArticle(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.deleteArticleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Delete a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param cascade How to cascade the delete
     */
    deleteTemplate(params: { typeHint: string; id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.deleteTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getArticle(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getArticleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getArticleTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: { filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceArticleResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getArticles(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Get a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     */
    getTemplate(params: { typeHint: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary List and search templates
     * @param typeHint The type for the resource this template applies to
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTemplates(params: { typeHint: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.getTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: { id: string; articleResource?: ArticleResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.updateArticle(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: { id: string; articleTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.updateArticleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Update a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param template The template
     */
    updateTemplate(params: { typeHint: string; id: string; template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.updateTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Error code thrown if invalid.<br><br><b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Validate a templated resource
     * @param typeHint The type for the resource this template applies to
     * @param resource The resource to validate
     */
    validate(params: { typeHint: string; resource?: BasicTemplatedResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_ArticlesApiFetchParamCreator.validate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Content_ArticlesApi - object-oriented interface
 */
export class Content_ArticlesApi extends BaseAPI {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.<br><br><b>Permissions:</b> ARTICLES_ADMIN
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: {  articleResource?: ArticleResource; }, options: any = {}) {
        return Content_ArticlesApiFp.createArticle(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Article Templates define a type of article and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, options: any = {}) {
        return Content_ArticlesApiFp.createArticleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Create a template
     * @param typeHint The type for the resource this template applies to
     * @param template The template
     */
    createTemplate(params: {  typeHint: string; template?: TemplateResource; }, options: any = {}) {
        return Content_ArticlesApiFp.createTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  id: string; }, options: any = {}) {
        return Content_ArticlesApiFp.deleteArticle(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Content_ArticlesApiFp.deleteArticleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Delete a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param cascade How to cascade the delete
     */
    deleteTemplate(params: {  typeHint: string; id: string; cascade?: string; }, options: any = {}) {
        return Content_ArticlesApiFp.deleteTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: {  id: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getArticle(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  id: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getArticleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getArticleTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getArticles(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Get a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     */
    getTemplate(params: {  typeHint: string; id: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary List and search templates
     * @param typeHint The type for the resource this template applies to
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTemplates(params: {  typeHint: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Content_ArticlesApiFp.getTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ARTICLES_ADMIN
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  id: string; articleResource?: ArticleResource; }, options: any = {}) {
        return Content_ArticlesApiFp.updateArticle(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, options: any = {}) {
        return Content_ArticlesApiFp.updateArticleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Update a template
     * @param typeHint The type for the resource this template applies to
     * @param id The id of the template
     * @param template The template
     */
    updateTemplate(params: {  typeHint: string; id: string; template?: TemplateResource; }, options: any = {}) {
        return Content_ArticlesApiFp.updateTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Error code thrown if invalid.<br><br><b>Permissions Needed:</b> TEMPLATES_ADMIN
     * @summary Validate a templated resource
     * @param typeHint The type for the resource this template applies to
     * @param resource The resource to validate
     */
    validate(params: {  typeHint: string; resource?: BasicTemplatedResource; }, options: any = {}) {
        return Content_ArticlesApiFp.validate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Content_ArticlesApi - factory interface
 */
export const Content_ArticlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.<br><br><b>Permissions:</b> ARTICLES_ADMIN
         * @summary Create a new article
         * @param articleResource The new article
         */
        createArticle(params: {  articleResource?: ArticleResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.createArticle(params, configuration, options)(fetch, basePath);
        },
        /**
         * Article Templates define a type of article and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an article template
         * @param articleTemplateResource The article template resource object
         */
        createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.createArticleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary Create a template
         * @param typeHint The type for the resource this template applies to
         * @param template The template
         */
        createTemplate(params: {  typeHint: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.createTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ARTICLES_ADMIN
         * @summary Delete an existing article
         * @param id The article id
         */
        deleteArticle(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.deleteArticle(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an article template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArticleTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.deleteArticleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary Delete a template
         * @param typeHint The type for the resource this template applies to
         * @param id The id of the template
         * @param cascade How to cascade the delete
         */
        deleteTemplate(params: {  typeHint: string; id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.deleteTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single article
         * @param id The article id
         */
        getArticle(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getArticle(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
         * @summary Get a single article template
         * @param id The id of the template
         */
        getArticleTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getArticleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTICLES_ADMIN
         * @summary List and search article templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getArticleTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
         * @summary List and search articles
         * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
         * @param filterCategory Filter for articles from a specific category by id
         * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
         * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
         * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
         * @param filterTitle Filter for articles whose title contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getArticles(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary Get a template
         * @param typeHint The type for the resource this template applies to
         * @param id The id of the template
         */
        getTemplate(params: {  typeHint: string; id: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary List and search templates
         * @param typeHint The type for the resource this template applies to
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTemplates(params: {  typeHint: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.getTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ARTICLES_ADMIN
         * @summary Update an existing article
         * @param id The article id
         * @param articleResource The article object
         */
        updateArticle(params: {  id: string; articleResource?: ArticleResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.updateArticle(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an article template
         * @param id The id of the template
         * @param articleTemplateResource The article template resource object
         */
        updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.updateArticleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary Update a template
         * @param typeHint The type for the resource this template applies to
         * @param id The id of the template
         * @param template The template
         */
        updateTemplate(params: {  typeHint: string; id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.updateTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Error code thrown if invalid.<br><br><b>Permissions Needed:</b> TEMPLATES_ADMIN
         * @summary Validate a templated resource
         * @param typeHint The type for the resource this template applies to
         * @param resource The resource to validate
         */
        validate(params: {  typeHint: string; resource?: BasicTemplatedResource; }, configuration: Configuration, options: any = {}) {
            return Content_ArticlesApiFp.validate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Content_CommentsApi - fetch parameter creator
 */
export const Content_CommentsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  commentResource?: CommentResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "context" is set
        if (params["context"] == null) {
            throw new Error("Missing required parameter context when calling getComments");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getComments");
        }
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["context"] !== undefined) {
            urlObj.query["context"] = params["context"];
        }
        if (params["contextId"] !== undefined) {
            urlObj.query["context_id"] = params["contextId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  id: number; content?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateComment");
        }
        const baseUrl = `/comments/{id}/content`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Content_CommentsApi - functional programming interface
 */
export const Content_CommentsApiFp = {
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: { commentResource?: CommentResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = Content_CommentsApiFetchParamCreator.addComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_CommentsApiFetchParamCreator.deleteComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = Content_CommentsApiFetchParamCreator.getComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: { context: string; contextId: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = Content_CommentsApiFetchParamCreator.getComments(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: { id: number; content?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Content_CommentsApiFetchParamCreator.updateComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Content_CommentsApi - object-oriented interface
 */
export class Content_CommentsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  commentResource?: CommentResource; }, options: any = {}) {
        return Content_CommentsApiFp.addComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  id: number; }, options: any = {}) {
        return Content_CommentsApiFp.deleteComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: {  id: number; }, options: any = {}) {
        return Content_CommentsApiFp.getComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, options: any = {}) {
        return Content_CommentsApiFp.getComments(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  id: number; content?: StringWrapper; }, options: any = {}) {
        return Content_CommentsApiFp.updateComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Content_CommentsApi - factory interface
 */
export const Content_CommentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
         * @summary Add a new comment
         * @param commentResource The comment to be added
         */
        addComment(params: {  commentResource?: CommentResource; }, configuration: Configuration, options: any = {}) {
            return Content_CommentsApiFp.addComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
         * @summary Delete a comment
         * @param id The comment id
         */
        deleteComment(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Content_CommentsApiFp.deleteComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Return a comment
         * @param id The comment id
         */
        getComment(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Content_CommentsApiFp.getComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a page of comments
         * @param context Get comments by context type
         * @param contextId Get comments by context id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Content_CommentsApiFp.getComments(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> COMMENTS_USER or COMMENTS_ADMIN
         * @summary Update a comment
         * @param id The comment id
         * @param content The comment content
         */
        updateComment(params: {  id: number; content?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Content_CommentsApiFp.updateComment(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * CurrenciesApi - fetch parameter creator
 */
export const CurrenciesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  currency?: CurrencyResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  code: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search currencies
     * @param filterDefault Filter for the one currency that is set as default (true), or all that are not (false)
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  filterDefault?: boolean; filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterDefault"] !== undefined) {
            urlObj.query["filter_default"] = params["filterDefault"];
        }
        if (params["filterEnabledCurrencies"] !== undefined) {
            urlObj.query["filter_enabled_currencies"] = params["filterEnabledCurrencies"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  code: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  code: string; currency?: CurrencyResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CurrenciesApi - functional programming interface
 */
export const CurrenciesApiFp = {
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: { currency?: CurrencyResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.createCurrency(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: { code: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.deleteCurrency(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search currencies
     * @param filterDefault Filter for the one currency that is set as default (true), or all that are not (false)
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: { filterDefault?: boolean; filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrencies(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: { code: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrency(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: { code: string; currency?: CurrencyResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.updateCurrency(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CurrenciesApi - object-oriented interface
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  currency?: CurrencyResource; }, options: any = {}) {
        return CurrenciesApiFp.createCurrency(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  code: string; }, options: any = {}) {
        return CurrenciesApiFp.deleteCurrency(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search currencies
     * @param filterDefault Filter for the one currency that is set as default (true), or all that are not (false)
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  filterDefault?: boolean; filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CurrenciesApiFp.getCurrencies(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  code: string; }, options: any = {}) {
        return CurrenciesApiFp.getCurrency(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CURRENCIES_ADMIN
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  code: string; currency?: CurrencyResource; }, options: any = {}) {
        return CurrenciesApiFp.updateCurrency(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * CurrenciesApi - factory interface
 */
export const CurrenciesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> CURRENCIES_ADMIN
         * @summary Create a currency
         * @param currency The currency object
         */
        createCurrency(params: {  currency?: CurrencyResource; }, configuration: Configuration, options: any = {}) {
            return CurrenciesApiFp.createCurrency(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CURRENCIES_ADMIN
         * @summary Delete a currency
         * @param code The currency code
         */
        deleteCurrency(params: {  code: string; }, configuration: Configuration, options: any = {}) {
            return CurrenciesApiFp.deleteCurrency(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search currencies
         * @param filterDefault Filter for the one currency that is set as default (true), or all that are not (false)
         * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
         * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCurrencies(params: {  filterDefault?: boolean; filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return CurrenciesApiFp.getCurrencies(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single currency
         * @param code The currency code
         */
        getCurrency(params: {  code: string; }, configuration: Configuration, options: any = {}) {
            return CurrenciesApiFp.getCurrency(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CURRENCIES_ADMIN
         * @summary Update a currency
         * @param code The currency code
         * @param currency The currency object
         */
        updateCurrency(params: {  code: string; currency?: CurrencyResource; }, configuration: Configuration, options: any = {}) {
            return CurrenciesApiFp.updateCurrency(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * DevicesApi - fetch parameter creator
 */
export const DevicesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userResources" is set
        if (params["userResources"] == null) {
            throw new Error("Missing required parameter userResources when calling addDeviceUsers");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addDeviceUsers");
        }
        const baseUrl = `/devices/{id}/users`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResources"]) {
            fetchOptions.body = JSON.stringify(params["userResources"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Create a device
     * @param device device
     */
    createDevice(params: {  device: DeviceResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling createDevice");
        }
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Device Templates define a type of device and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a device template
     * @param deviceTemplateResource The device template resource object
     */
    createDeviceTemplate(params: {  deviceTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/devices/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["deviceTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["deviceTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an device template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteDeviceTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDeviceTemplate");
        }
        const baseUrl = `/devices/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: {  id: string; userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDeviceUser");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deleteDeviceUser");
        }
        const baseUrl = `/devices/{id}/users/{user_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: {  id: string; filterId?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDeviceUsers");
        }
        const baseUrl = `/devices/{id}/users`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterId"] !== undefined) {
            urlObj.query["filter_id"] = params["filterId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> description
     * @summary Get a single device template
     * @param id The id of the template
     */
    getDeviceTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDeviceTemplate");
        }
        const baseUrl = `/devices/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or DEVICES_ADMIN
     * @summary List and search device templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDeviceTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/devices/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of devices with optional filtering. <br><br><b>Permissions Needed:</b> DEVICES_ADMIN or user
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param filterOs Filter for devices with specified OS
     * @param filterSerial Filter for devices with specified serial
     * @param filterType Filter for devices with specified type
     * @param filterTag A comma separated list without spaces to filter for devices with specified tags (matches any)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  filterMake?: string; filterModel?: string; filterOs?: string; filterSerial?: string; filterType?: string; filterTag?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterMake"] !== undefined) {
            urlObj.query["filter_make"] = params["filterMake"];
        }
        if (params["filterModel"] !== undefined) {
            urlObj.query["filter_model"] = params["filterModel"];
        }
        if (params["filterOs"] !== undefined) {
            urlObj.query["filter_os"] = params["filterOs"];
        }
        if (params["filterSerial"] !== undefined) {
            urlObj.query["filter_serial"] = params["filterSerial"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> CUSTOMERS_ADMIN
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  device: DeviceResource; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling updateDevice");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an device template
     * @param id The id of the template
     * @param deviceTemplateResource The device template resource object
     */
    updateDeviceTemplate(params: {  id: string; deviceTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateDeviceTemplate");
        }
        const baseUrl = `/devices/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["deviceTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["deviceTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = {
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: { userResources: Array<SimpleUserResource>; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.addDeviceUsers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Create a device
     * @param device device
     */
    createDevice(params: { device: DeviceResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.createDevice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Device Templates define a type of device and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a device template
     * @param deviceTemplateResource The device template resource object
     */
    createDeviceTemplate(params: { deviceTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = DevicesApiFetchParamCreator.createDeviceTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDevice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an device template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteDeviceTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDeviceTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: { id: string; userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDeviceUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: { id: string; filterId?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDeviceUsers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> description
     * @summary Get a single device template
     * @param id The id of the template
     */
    getDeviceTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDeviceTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or DEVICES_ADMIN
     * @summary List and search device templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDeviceTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDeviceTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of devices with optional filtering. <br><br><b>Permissions Needed:</b> DEVICES_ADMIN or user
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param filterOs Filter for devices with specified OS
     * @param filterSerial Filter for devices with specified serial
     * @param filterType Filter for devices with specified type
     * @param filterTag A comma separated list without spaces to filter for devices with specified tags (matches any)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: { filterMake?: string; filterModel?: string; filterOs?: string; filterSerial?: string; filterType?: string; filterTag?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevices(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> CUSTOMERS_ADMIN
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: { device: DeviceResource; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.updateDevice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an device template
     * @param id The id of the template
     * @param deviceTemplateResource The device template resource object
     */
    updateDeviceTemplate(params: { id: string; deviceTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = DevicesApiFetchParamCreator.updateDeviceTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: string; }, options: any = {}) {
        return DevicesApiFp.addDeviceUsers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Create a device
     * @param device device
     */
    createDevice(params: {  device: DeviceResource; }, options: any = {}) {
        return DevicesApiFp.createDevice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Device Templates define a type of device and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a device template
     * @param deviceTemplateResource The device template resource object
     */
    createDeviceTemplate(params: {  deviceTemplateResource?: TemplateResource; }, options: any = {}) {
        return DevicesApiFp.createDeviceTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: {  id: string; }, options: any = {}) {
        return DevicesApiFp.deleteDevice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an device template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteDeviceTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return DevicesApiFp.deleteDeviceTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: {  id: string; userId: number; }, options: any = {}) {
        return DevicesApiFp.deleteDeviceUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: {  id: string; filterId?: string; }, options: any = {}) {
        return DevicesApiFp.deleteDeviceUsers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: {  id: string; }, options: any = {}) {
        return DevicesApiFp.getDevice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> description
     * @summary Get a single device template
     * @param id The id of the template
     */
    getDeviceTemplate(params: {  id: string; }, options: any = {}) {
        return DevicesApiFp.getDeviceTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or DEVICES_ADMIN
     * @summary List and search device templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDeviceTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return DevicesApiFp.getDeviceTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of devices with optional filtering. <br><br><b>Permissions Needed:</b> DEVICES_ADMIN or user
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param filterOs Filter for devices with specified OS
     * @param filterSerial Filter for devices with specified serial
     * @param filterType Filter for devices with specified type
     * @param filterTag A comma separated list without spaces to filter for devices with specified tags (matches any)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  filterMake?: string; filterModel?: string; filterOs?: string; filterSerial?: string; filterType?: string; filterTag?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return DevicesApiFp.getDevices(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> CUSTOMERS_ADMIN
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  device: DeviceResource; id: string; }, options: any = {}) {
        return DevicesApiFp.updateDevice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an device template
     * @param id The id of the template
     * @param deviceTemplateResource The device template resource object
     */
    updateDeviceTemplate(params: {  id: string; deviceTemplateResource?: TemplateResource; }, options: any = {}) {
        return DevicesApiFp.updateDeviceTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
         * @summary Add device users
         * @param userResources userResources
         * @param id id
         */
        addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.addDeviceUsers(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Create a device
         * @param device device
         */
        createDevice(params: {  device: DeviceResource; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.createDevice(params, configuration, options)(fetch, basePath);
        },
        /**
         * Device Templates define a type of device and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a device template
         * @param deviceTemplateResource The device template resource object
         */
        createDeviceTemplate(params: {  deviceTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.createDeviceTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
         * @summary Delete a device
         * @param id id
         */
        deleteDevice(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.deleteDevice(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an device template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteDeviceTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.deleteDeviceTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
         * @summary Delete a device user
         * @param id The id of the device
         * @param userId The user id of the device user
         */
        deleteDeviceUser(params: {  id: string; userId: number; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.deleteDeviceUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
         * @summary Delete all device users
         * @param id The id of the device
         * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
         */
        deleteDeviceUsers(params: {  id: string; filterId?: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.deleteDeviceUsers(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> DEVICES_ADMIN or owner
         * @summary Get a single device
         * @param id id
         */
        getDevice(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.getDevice(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> description
         * @summary Get a single device template
         * @param id The id of the template
         */
        getDeviceTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.getDeviceTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or DEVICES_ADMIN
         * @summary List and search device templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDeviceTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.getDeviceTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of devices with optional filtering. <br><br><b>Permissions Needed:</b> DEVICES_ADMIN or user
         * @summary List and search devices
         * @param filterMake Filter for devices with specified make
         * @param filterModel Filter for devices with specified model
         * @param filterOs Filter for devices with specified OS
         * @param filterSerial Filter for devices with specified serial
         * @param filterType Filter for devices with specified type
         * @param filterTag A comma separated list without spaces to filter for devices with specified tags (matches any)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDevices(params: {  filterMake?: string; filterModel?: string; filterOs?: string; filterSerial?: string; filterType?: string; filterTag?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.getDevices(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> CUSTOMERS_ADMIN
         * @summary Update a device
         * @param device device
         * @param id id
         */
        updateDevice(params: {  device: DeviceResource; id: string; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.updateDevice(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an device template
         * @param id The id of the template
         * @param deviceTemplateResource The device template resource object
         */
        updateDeviceTemplate(params: {  id: string; deviceTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return DevicesApiFp.updateDeviceTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * DispositionsApi - fetch parameter creator
 */
export const DispositionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and user, or DISPOSITIONS_ADMIN
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  disposition?: DispositionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["disposition"]) {
            fetchOptions.body = JSON.stringify(params["disposition"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and owner, or DISPOSITIONS_ADMIN
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterOwner"] !== undefined) {
            urlObj.query["filter_owner"] = params["filterOwner"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterOwner"] !== undefined) {
            urlObj.query["filter_owner"] = params["filterOwner"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DispositionsApi - functional programming interface
 */
export const DispositionsApiFp = {
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and user, or DISPOSITIONS_ADMIN
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: { disposition?: DispositionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.addDisposition(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and owner, or DISPOSITIONS_ADMIN
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DispositionsApiFetchParamCreator.deleteDisposition(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDisposition(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: { filterContext?: string; filterOwner?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<DispositionCount>> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositionCounts(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: { filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DispositionsApi - object-oriented interface
 */
export class DispositionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and user, or DISPOSITIONS_ADMIN
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  disposition?: DispositionResource; }, options: any = {}) {
        return DispositionsApiFp.addDisposition(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> DISPOSITIONS_USER and owner, or DISPOSITIONS_ADMIN
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  id: number; }, options: any = {}) {
        return DispositionsApiFp.deleteDisposition(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  id: number; }, options: any = {}) {
        return DispositionsApiFp.getDisposition(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, options: any = {}) {
        return DispositionsApiFp.getDispositionCounts(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return DispositionsApiFp.getDispositions(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * DispositionsApi - factory interface
 */
export const DispositionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> DISPOSITIONS_USER and user, or DISPOSITIONS_ADMIN
         * @summary Add a new disposition
         * @param disposition The new disposition record
         */
        addDisposition(params: {  disposition?: DispositionResource; }, configuration: Configuration, options: any = {}) {
            return DispositionsApiFp.addDisposition(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> DISPOSITIONS_USER and owner, or DISPOSITIONS_ADMIN
         * @summary Delete a disposition
         * @param id The id of the disposition record
         */
        deleteDisposition(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return DispositionsApiFp.deleteDisposition(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a disposition
         * @param id The id of the disposition record
         */
        getDisposition(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return DispositionsApiFp.getDisposition(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a list of disposition counts
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         */
        getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, configuration: Configuration, options: any = {}) {
            return DispositionsApiFp.getDispositionCounts(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a page of dispositions
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return DispositionsApiFp.getDispositions(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * FulfillmentApi - fetch parameter creator
 */
export const FulfillmentApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  type?: FulfillmentType; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["type"]) {
            fetchOptions.body = JSON.stringify(params["type"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Update a fulfillment type
     * @param id The fulfillment id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["fulfillmentType"]) {
            fetchOptions.body = JSON.stringify(params["fulfillmentType"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FulfillmentApi - functional programming interface
 */
export const FulfillmentApiFp = {
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: { type?: FulfillmentType;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.createFulfillmentType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.deleteFulfillmentType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceFulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentTypes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Update a fulfillment type
     * @param id The fulfillment id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: { id: number; fulfillmentType?: FulfillmentType;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.updateFulfillmentType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FulfillmentApi - object-oriented interface
 */
export class FulfillmentApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  type?: FulfillmentType; }, options: any = {}) {
        return FulfillmentApiFp.createFulfillmentType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  id: number; }, options: any = {}) {
        return FulfillmentApiFp.deleteFulfillmentType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  id: number; }, options: any = {}) {
        return FulfillmentApiFp.getFulfillmentType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return FulfillmentApiFp.getFulfillmentTypes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
     * @summary Update a fulfillment type
     * @param id The fulfillment id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, options: any = {}) {
        return FulfillmentApiFp.updateFulfillmentType(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * FulfillmentApi - factory interface
 */
export const FulfillmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
         * @summary Create a fulfillment type
         * @param type The fulfillment type
         */
        createFulfillmentType(params: {  type?: FulfillmentType; }, configuration: Configuration, options: any = {}) {
            return FulfillmentApiFp.createFulfillmentType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
         * @summary Delete a fulfillment type
         * @param id The id
         */
        deleteFulfillmentType(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return FulfillmentApiFp.deleteFulfillmentType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single fulfillment type
         * @param id The id
         */
        getFulfillmentType(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return FulfillmentApiFp.getFulfillmentType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search fulfillment types
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return FulfillmentApiFp.getFulfillmentTypes(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> FULFILLMENT_ADMIN
         * @summary Update a fulfillment type
         * @param id The fulfillment id
         * @param fulfillmentType The fulfillment type
         */
        updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, configuration: Configuration, options: any = {}) {
            return FulfillmentApiFp.updateFulfillmentType(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Gamification_AchievementsApi - fetch parameter creator
 */
export const Gamification_AchievementsApiFetchParamCreator = {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: {  achievement?: AchievementDefinitionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Achievement templates define a type of achievement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will also disable the associated generated rule, if any. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/achievements/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterHidden"] !== undefined) {
            urlObj.query["filter_hidden"] = params["filterHidden"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        if (params["filterDerived"] !== undefined) {
            urlObj.query["filter_derived"] = params["filterDerived"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used by other services that depend on achievements.  <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getDerivedAchievements");
        }
        const baseUrl = `/achievements/derived/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  userId: number; achievementName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUserAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementsProgress");
        }
        const baseUrl = `/users/{user_id}/achievements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUsersAchievementProgress");
        }
        const baseUrl = `/users/achievements/{achievement_name}`
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling incrementAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling incrementAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling setAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Gamification_AchievementsApi - functional programming interface
 */
export const Gamification_AchievementsApiFp = {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: { achievement?: AchievementDefinitionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.createAchievement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Achievement templates define a type of achievement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: { template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.createAchievementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will also disable the associated generated rule, if any. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.deleteAchievement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.deleteAchievementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getAchievement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getAchievementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getAchievementTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getAchievementTriggers(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: { filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAchievementDefinitionResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getAchievements(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used by other services that depend on achievements.  <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<AchievementDefinitionResource>> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getDerivedAchievements(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: { userId: number; achievementName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getUserAchievementProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: { userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getUserAchievementsProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: { achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getUsersAchievementProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: { filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.getUsersAchievementsProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: { userId: number; achievementName: string; progress?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.incrementAchievementProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: { userId: number; achievementName: string; progress?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.setAchievementProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: { name: string; achievement?: AchievementDefinitionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.updateAchievement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: { id: string; template?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Gamification_AchievementsApiFetchParamCreator.updateAchievementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Gamification_AchievementsApi - object-oriented interface
 */
export class Gamification_AchievementsApi extends BaseAPI {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: {  achievement?: AchievementDefinitionResource; }, options: any = {}) {
        return Gamification_AchievementsApiFp.createAchievement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Achievement templates define a type of achievement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
        return Gamification_AchievementsApiFp.createAchievementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will also disable the associated generated rule, if any. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  name: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.deleteAchievement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.deleteAchievementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  name: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getAchievement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  id: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getAchievementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getAchievementTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options: any = {}) {
        return Gamification_AchievementsApiFp.getAchievementTriggers(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getAchievements(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Used by other services that depend on achievements.  <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  name: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getDerivedAchievements(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  userId: number; achievementName: string; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getUserAchievementProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getUserAchievementsProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getUsersAchievementProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return Gamification_AchievementsApiFp.getUsersAchievementsProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
        return Gamification_AchievementsApiFp.incrementAchievementProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
        return Gamification_AchievementsApiFp.setAchievementProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, options: any = {}) {
        return Gamification_AchievementsApiFp.updateAchievement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
        return Gamification_AchievementsApiFp.updateAchievementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Gamification_AchievementsApi - factory interface
 */
export const Gamification_AchievementsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Create a new achievement definition
         * @param achievement The achievement definition
         */
        createAchievement(params: {  achievement?: AchievementDefinitionResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.createAchievement(params, configuration, options)(fetch, basePath);
        },
        /**
         * Achievement templates define a type of achievement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an achievement template
         * @param template The achievement template to be created
         */
        createAchievementTemplate(params: {  template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.createAchievementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Will also disable the associated generated rule, if any. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Delete an achievement definition
         * @param name The name of the achievement
         */
        deleteAchievement(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.deleteAchievement(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an achievement template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteAchievementTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.deleteAchievementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
         * @summary Get a single achievement definition
         * @param name The name of the achievement
         */
        getAchievement(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getAchievement(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary Get a single achievement template
         * @param id The id of the template
         */
        getAchievementTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getAchievementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary List and search achievement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getAchievementTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Get the list of triggers that can be used to trigger an achievement progress update
         */
        getAchievementTriggers(configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getAchievementTriggers(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN or ACHIEVEMENTS_USER
         * @summary Get all achievement definitions in the system
         * @param filterTagset Filter for achievements with specified tags (separated by comma)
         * @param filterName Filter for achievements whose name contains a string
         * @param filterHidden Filter for achievements that are hidden or not
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterDerived Filter for achievements that are derived from other services
         */
        getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getAchievements(params, configuration, options)(fetch, basePath);
        },
        /**
         * Used by other services that depend on achievements.  <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Get a list of derived achievements
         * @param name The name of the derived achievement
         */
        getDerivedAchievements(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getDerivedAchievements(params, configuration, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Retrieve progress on a given achievement for a given user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         */
        getUserAchievementProgress(params: {  userId: number; achievementName: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getUserAchievementProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Retrieve progress on achievements for a given user
         * @param userId The user&#39;s id
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getUserAchievementsProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Retrieve progress on a given achievement for all users
         * @param achievementName The achievement&#39;s name
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getUsersAchievementProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Retrieve progress on achievements for all users
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.getUsersAchievementsProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Increment an achievement progress record for a user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         * @param progress The amount to add to the progress value
         */
        incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.incrementAchievementProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Set an achievement progress record for a user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         * @param progress The new progress value
         */
        setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.setAchievementProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version. <br><br><b>Permissions Needed:</b> ACHIEVEMENTS_ADMIN
         * @summary Update an achievement definition
         * @param name The name of the achievement
         * @param achievement The achievement definition
         */
        updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.updateAchievement(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an achievement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_AchievementsApiFp.updateAchievementTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Gamification_LeaderboardsApi - fetch parameter creator
 */
export const Gamification_LeaderboardsApiFetchParamCreator = {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboard");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboard");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboardRank");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboardRank");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getLeaderboardRank");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}/users/{id}/rank`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/leaderboards/strategies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Gamification_LeaderboardsApi - functional programming interface
 */
export const Gamification_LeaderboardsApiFp = {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: { contextType: string; contextId: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LeaderboardResource> {
        const fetchArgs = Gamification_LeaderboardsApiFetchParamCreator.getLeaderboard(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: { contextType: string; contextId: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LeaderboardEntryResource> {
        const fetchArgs = Gamification_LeaderboardsApiFetchParamCreator.getLeaderboardRank(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = Gamification_LeaderboardsApiFetchParamCreator.getLeaderboardStrategies(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Gamification_LeaderboardsApi - object-oriented interface
 */
export class Gamification_LeaderboardsApi extends BaseAPI {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_LeaderboardsApiFp.getLeaderboard(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. <br><br><b>Permissions Needed:</b> ANY
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, options: any = {}) {
        return Gamification_LeaderboardsApiFp.getLeaderboardRank(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options: any = {}) {
        return Gamification_LeaderboardsApiFp.getLeaderboardStrategies(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Gamification_LeaderboardsApi - factory interface
 */
export const Gamification_LeaderboardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource. <br><br><b>Permissions Needed:</b> ANY
         * @summary Retrieves leaderboard details and paginated entries
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LeaderboardsApiFp.getLeaderboard(params, configuration, options)(fetch, basePath);
        },
        /**
         * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. <br><br><b>Permissions Needed:</b> ANY
         * @summary Retrieves a specific user entry with rank
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param id The id of a user
         */
        getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LeaderboardsApiFp.getLeaderboardRank(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a list of available leaderboard strategy names
         */
        getLeaderboardStrategies(configuration: Configuration, options: any = {}) {
            return Gamification_LeaderboardsApiFp.getLeaderboardStrategies(configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Gamification_LevelingApi - fetch parameter creator
 */
export const Gamification_LevelingApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  level?: LevelingResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["level"]) {
            fetchOptions.body = JSON.stringify(params["level"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_USER
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/leveling/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of levels schemas with optional filtering. <br><br><b>Permissions Needed:</b> LEVELING_USER
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user or &#39;me&#39;
     * @param name The level schema name
     */
    getUserLevel(params: {  userId: string; name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevel");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getUserLevel");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here. <br><br><b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user or &#39;me&#39;
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: {  userId: string; filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevels");
        }
        const baseUrl = `/users/{user_id}/leveling`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling incrementProgress");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling incrementProgress");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setProgress");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling setProgress");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  name: string; newLevel?: LevelingResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newLevel"]) {
            fetchOptions.body = JSON.stringify(params["newLevel"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Gamification_LevelingApi - functional programming interface
 */
export const Gamification_LevelingApiFp = {
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: { level?: LevelingResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.createLevel(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.deleteLevel(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_USER
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.getLevel(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.getLevelTriggers(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of levels schemas with optional filtering. <br><br><b>Permissions Needed:</b> LEVELING_USER
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: { filterName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceLevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.getLevels(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user or &#39;me&#39;
     * @param name The level schema name
     */
    getUserLevel(params: { userId: string; name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserLevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.getUserLevel(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here. <br><br><b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user or &#39;me&#39;
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: { userId: string; filterName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserLevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.getUserLevels(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: { userId: number; name: string; progress?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.incrementProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: { userId: number; name: string; progress?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.setProgress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: { name: string; newLevel?: LevelingResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = Gamification_LevelingApiFetchParamCreator.updateLevel(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Gamification_LevelingApi - object-oriented interface
 */
export class Gamification_LevelingApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  level?: LevelingResource; }, options: any = {}) {
        return Gamification_LevelingApiFp.createLevel(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  name: string; }, options: any = {}) {
        return Gamification_LevelingApiFp.deleteLevel(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LEVELING_USER
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  name: string; }, options: any = {}) {
        return Gamification_LevelingApiFp.getLevel(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options: any = {}) {
        return Gamification_LevelingApiFp.getLevelTriggers(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of levels schemas with optional filtering. <br><br><b>Permissions Needed:</b> LEVELING_USER
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_LevelingApiFp.getLevels(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user or &#39;me&#39;
     * @param name The level schema name
     */
    getUserLevel(params: {  userId: string; name: string; }, options: any = {}) {
        return Gamification_LevelingApiFp.getUserLevel(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here. <br><br><b>Permissions Needed:</b> LEVELING_USER or self
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user or &#39;me&#39;
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: {  userId: string; filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_LevelingApiFp.getUserLevels(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
        return Gamification_LevelingApiFp.incrementProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
        return Gamification_LevelingApiFp.setProgress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LEVELING_ADMIN
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  name: string; newLevel?: LevelingResource; }, options: any = {}) {
        return Gamification_LevelingApiFp.updateLevel(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Gamification_LevelingApi - factory interface
 */
export const Gamification_LevelingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Create a level schema
         * @param level The level schema definition
         */
        createLevel(params: {  level?: LevelingResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.createLevel(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Delete a level
         * @param name The level schema name
         */
        deleteLevel(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.deleteLevel(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LEVELING_USER
         * @summary Retrieve a level
         * @param name The level schema name
         */
        getLevel(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.getLevel(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Get the list of triggers that can be used to trigger a leveling progress update
         */
        getLevelTriggers(configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.getLevelTriggers(configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of levels schemas with optional filtering. <br><br><b>Permissions Needed:</b> LEVELING_USER
         * @summary List and search levels
         * @param filterName Filter for level schemas whose name contains a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.getLevels(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LEVELING_USER or self
         * @summary Get a user's progress for a given level schema
         * @param userId The id of the user or &#39;me&#39;
         * @param name The level schema name
         */
        getUserLevel(params: {  userId: string; name: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.getUserLevel(params, configuration, options)(fetch, basePath);
        },
        /**
         * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here. <br><br><b>Permissions Needed:</b> LEVELING_USER or self
         * @summary Get a user's progress for all level schemas
         * @param userId The id of the user or &#39;me&#39;
         * @param filterName Filter for level schemas whose name contains a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLevels(params: {  userId: string; filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.getUserLevels(params, configuration, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Update or create a leveling progress record for a user
         * @param userId The id of the user
         * @param name The level schema name
         * @param progress The amount of progress to add
         */
        incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.incrementProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>. <br><br><b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Set leveling progress for a user
         * @param userId The id of the user
         * @param name The level schema name
         * @param progress The new progress amount
         */
        setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.setProgress(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LEVELING_ADMIN
         * @summary Update a level
         * @param name The level schema name
         * @param newLevel The level schema definition
         */
        updateLevel(params: {  name: string; newLevel?: LevelingResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_LevelingApiFp.updateLevel(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Gamification_MetricsApi - fetch parameter creator
 */
export const Gamification_MetricsApiFetchParamCreator = {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: {  metric?: MetricResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/metrics`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["metric"]) {
            fetchOptions.body = JSON.stringify(params["metric"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Gamification_MetricsApi - functional programming interface
 */
export const Gamification_MetricsApiFp = {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: { metric?: MetricResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_MetricsApiFetchParamCreator.addMetric(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Gamification_MetricsApi - object-oriented interface
 */
export class Gamification_MetricsApi extends BaseAPI {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: {  metric?: MetricResource; }, options: any = {}) {
        return Gamification_MetricsApiFp.addMetric(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Gamification_MetricsApi - factory interface
 */
export const Gamification_MetricsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Post a new score/stat for an activity occurrence without ending the occurrence itself
         * @summary Add a metric
         * @param metric The new metric
         */
        addMetric(params: {  metric?: MetricResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_MetricsApiFp.addMetric(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Gamification_TriviaApi - fetch parameter creator
 */
export const Gamification_TriviaApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling addQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  id: string; tag?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: {  request?: ImportJobResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: {  question?: QuestionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Question templates define a type of question and the properties they have. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Also deletes all questions that were imported by it. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  questionId: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling deleteQuestionAnswers");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterVendor"] !== undefined) {
            urlObj.query["filter_vendor"] = params["filterVendor"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  questionId: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  questionId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  since?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/delta`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["since"] !== undefined) {
            urlObj.query["since"] = params["since"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTags");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  id: number; publishNow: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling processImportJob");
        }
        // verify required parameter "publishNow" is set
        if (params["publishNow"] == null) {
            throw new Error("Missing required parameter publishNow when calling processImportJob");
        }
        const baseUrl = `/trivia/import/{id}/process`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["publishNow"] !== undefined) {
            urlObj.query["publish_now"] = params["publishNow"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  id: string; tag: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeQuestionTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags/{tag}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeTagToQuestionsBatch");
        }
        const baseUrl = `/trivia/questions/tags/{tag}`
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Changes should be made before process is started for there to be any effect. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  id: number; request?: ImportJobResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  id: string; question?: QuestionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling updateQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Gamification_TriviaApi - functional programming interface
 */
export const Gamification_TriviaApiFp = {
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: { questionId: string; answer?: AnswerResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.addQuestionAnswers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: { id: string; tag?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.addQuestionTag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: { tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.addTagToQuestionsBatch(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: { request?: ImportJobResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.createImportJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: { question?: QuestionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.createQuestion(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Question templates define a type of question and the properties they have. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: { questionTemplateResource?: QuestionTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.createQuestionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Also deletes all questions that were imported by it. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.deleteImportJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.deleteQuestion(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: { questionId: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.deleteQuestionAnswers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.deleteQuestionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getImportJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: { filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceImportJobResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getImportJobs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestion(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: { questionId: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionAnswer(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: { questionId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<AnswerResource>> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionAnswers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: { since?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<DeltaResource>> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionDeltas(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionTags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceQuestionTemplateResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: { size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceQuestionResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: { filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.getQuestionsCount(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: { id: number; publishNow: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.processImportJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: { id: string; tag: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.removeQuestionTag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: { tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.removeTagToQuestionsBatch(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: { filterSearch?: string; filterCategory?: string; filterImportId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.searchQuestionTags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Changes should be made before process is started for there to be any effect. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: { id: number; request?: ImportJobResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.updateImportJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: { id: string; question?: QuestionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.updateQuestion(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: { questionId: string; id: string; answer?: AnswerResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.updateQuestionAnswer(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: { id: string; questionTemplateResource?: QuestionTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.updateQuestionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: { question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = Gamification_TriviaApiFetchParamCreator.updateQuestionsInBulk(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Gamification_TriviaApi - object-oriented interface
 */
export class Gamification_TriviaApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.addQuestionAnswers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  id: string; tag?: StringWrapper; }, options: any = {}) {
        return Gamification_TriviaApiFp.addQuestionTag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.addTagToQuestionsBatch(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: {  request?: ImportJobResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.createImportJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: {  question?: QuestionResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.createQuestion(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Question templates define a type of question and the properties they have. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.createQuestionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Also deletes all questions that were imported by it. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: {  id: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.deleteImportJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.deleteQuestion(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  questionId: string; id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.deleteQuestionAnswers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.deleteQuestionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  id: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.getImportJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getImportJobs(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestion(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  questionId: string; id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionAnswer(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  questionId: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionAnswers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  since?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionDeltas(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionTags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  id: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, options: any = {}) {
        return Gamification_TriviaApiFp.getQuestionsCount(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  id: number; publishNow: boolean; }, options: any = {}) {
        return Gamification_TriviaApiFp.processImportJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  id: string; tag: string; }, options: any = {}) {
        return Gamification_TriviaApiFp.removeQuestionTag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.removeTagToQuestionsBatch(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.searchQuestionTags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Changes should be made before process is started for there to be any effect. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  id: number; request?: ImportJobResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.updateImportJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  id: string; question?: QuestionResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.updateQuestion(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.updateQuestionAnswer(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
        return Gamification_TriviaApiFp.updateQuestionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return Gamification_TriviaApiFp.updateQuestionsInBulk(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Gamification_TriviaApi - factory interface
 */
export const Gamification_TriviaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Add an answer to a question
         * @param questionId The id of the question
         * @param answer The new answer
         */
        addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.addQuestionAnswers(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Add a tag to a question
         * @param id The id of the question
         * @param tag The new tag
         */
        addQuestionTag(params: {  id: string; tag?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.addQuestionTag(params, configuration, options)(fetch, basePath);
        },
        /**
         * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Add a tag to a batch of questions
         * @param tag The tag to add
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.addTagToQuestionsBatch(params, configuration, options)(fetch, basePath);
        },
        /**
         * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Create an import job
         * @param request The new import job
         */
        createImportJob(params: {  request?: ImportJobResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.createImportJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Create a question
         * @param question The new question
         */
        createQuestion(params: {  question?: QuestionResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.createQuestion(params, configuration, options)(fetch, basePath);
        },
        /**
         * Question templates define a type of question and the properties they have. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Create a question template
         * @param questionTemplateResource The question template resource object
         */
        createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.createQuestionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Also deletes all questions that were imported by it. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Delete an import job
         * @param id The id of the job
         */
        deleteImportJob(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.deleteImportJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Delete a question
         * @param id The id of the question
         */
        deleteQuestion(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.deleteQuestion(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Remove an answer from a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        deleteQuestionAnswers(params: {  questionId: string; id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.deleteQuestionAnswers(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a question template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteQuestionTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.deleteQuestionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Get an import job
         * @param id The id of the job
         */
        getImportJob(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getImportJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Get a list of import job
         * @param filterVendor Filter for jobs by vendor id
         * @param filterCategory Filter for jobs by category id
         * @param filterName Filter for jobs which name *STARTS* with the given string
         * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getImportJobs(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Get a single question
         * @param id The id of the question
         */
        getQuestion(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestion(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Get an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        getQuestionAnswer(params: {  questionId: string; id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionAnswer(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary List the answers available for a question
         * @param questionId The id of the question
         */
        getQuestionAnswers(params: {  questionId: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionAnswers(params, configuration, options)(fetch, basePath);
        },
        /**
         * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary List question deltas in ascending order of updated date
         * @param since Timestamp in seconds
         */
        getQuestionDeltas(params: {  since?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionDeltas(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary List the tags for a question
         * @param id The id of the question
         */
        getQuestionTags(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionTags(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
         * @summary Get a single question template
         * @param id The id of the template
         */
        getQuestionTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or TRIVIA_ADMIN
         * @summary List and search question templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary List and search questions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterTag Filter for questions with specified tag
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestions(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is also provided by the list endpoint so you don't need to call this for pagination purposes. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Count questions based on filters
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         */
        getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.getQuestionsCount(params, configuration, options)(fetch, basePath);
        },
        /**
         * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Start processing an import job
         * @param id The id of the job
         * @param publishNow Whether the new questions should be published live immediately
         */
        processImportJob(params: {  id: number; publishNow: boolean; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.processImportJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Remove a tag from a question
         * @param id The id of the question
         * @param tag The tag to remove
         */
        removeQuestionTag(params: {  id: string; tag: string; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.removeQuestionTag(params, configuration, options)(fetch, basePath);
        },
        /**
         * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Remove a tag from a batch of questions
         * @param tag The tag to remove
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.removeTagToQuestionsBatch(params, configuration, options)(fetch, basePath);
        },
        /**
         * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary List and search tags by the beginning of the string
         * @param filterSearch Filter for tags starting with the given text
         * @param filterCategory Filter for tags on questions from a specific category
         * @param filterImportId Filter for tags on questions from a specific import job
         */
        searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.searchQuestionTags(params, configuration, options)(fetch, basePath);
        },
        /**
         * Changes should be made before process is started for there to be any effect. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Update an import job
         * @param id The id of the job
         * @param request The updated job
         */
        updateImportJob(params: {  id: number; request?: ImportJobResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.updateImportJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Update a question
         * @param id The id of the question
         * @param question The updated question
         */
        updateQuestion(params: {  id: string; question?: QuestionResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.updateQuestion(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Update an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         * @param answer The updated answer
         */
        updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.updateQuestionAnswer(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a question template
         * @param id The id of the template
         * @param questionTemplateResource The question template resource object
         */
        updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.updateQuestionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated. <br><br><b>Permissions Needed:</b> TRIVIA_ADMIN
         * @summary Bulk update questions
         * @param question New values for a set of question fields
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, configuration: Configuration, options: any = {}) {
            return Gamification_TriviaApiFp.updateQuestionsInBulk(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * InvoicesApi - fetch parameter creator
 */
export const InvoicesApiFetchParamCreator = {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor. <br><br><b>Permissions Needed:</b> INVOICES_USER or INVOICES_ADMIN
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: {  req?: InvoiceCreateRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/invoices/fulfillment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoice");
        }
        const baseUrl = `/invoices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoiceLogs");
        }
        const baseUrl = `/invoices/{id}/logs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices. <br><br><b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterUser"] !== undefined) {
            urlObj.query["filter_user"] = params["filterUser"];
        }
        if (params["filterEmail"] !== undefined) {
            urlObj.query["filter_email"] = params["filterEmail"];
        }
        if (params["filterFulfillmentStatus"] !== undefined) {
            urlObj.query["filter_fulfillment_status"] = params["filterFulfillmentStatus"];
        }
        if (params["filterPaymentStatus"] !== undefined) {
            urlObj.query["filter_payment_status"] = params["filterPaymentStatus"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterExternalRef"] !== undefined) {
            urlObj.query["filter_external_ref"] = params["filterExternalRef"];
        }
        if (params["filterCreatedDate"] !== undefined) {
            urlObj.query["filter_created_date"] = params["filterCreatedDate"];
        }
        if (params["filterVendorIds"] !== undefined) {
            urlObj.query["filter_vendor_ids"] = params["filterVendorIds"];
        }
        if (params["filterCurrency"] !== undefined) {
            urlObj.query["filter_currency"] = params["filterCurrency"];
        }
        if (params["filterShippingStateName"] !== undefined) {
            urlObj.query["filter_shipping_state_name"] = params["filterShippingStateName"];
        }
        if (params["filterShippingCountryName"] !== undefined) {
            urlObj.query["filter_shipping_country_name"] = params["filterShippingCountryName"];
        }
        if (params["filterShipping"] !== undefined) {
            urlObj.query["filter_shipping"] = params["filterShipping"];
        }
        if (params["filterVendorName"] !== undefined) {
            urlObj.query["filter_vendor_name"] = params["filterVendorName"];
        }
        if (params["filterSku"] !== undefined) {
            urlObj.query["filter_sku"] = params["filterSku"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/invoices/payment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payInvoice");
        }
        const baseUrl = `/invoices/{id}/payments`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "bundleSku" is set
        if (params["bundleSku"] == null) {
            throw new Error("Missing required parameter bundleSku when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setBundledInvoiceItemFulfillmentStatus");
        }
        const baseUrl = `/invoices/{id}/items/{bundleSku}/bundled-skus/{sku}/fulfillment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"bundleSku"}}`, `${ params["bundleSku"] }`)
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setExternalRef");
        }
        const baseUrl = `/invoices/{id}/external-ref`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["externalRef"]) {
            fetchOptions.body = JSON.stringify(params["externalRef"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setInvoiceItemFulfillmentStatus");
        }
        const baseUrl = `/invoices/{id}/items/{sku}/fulfillment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setOrderNotes");
        }
        const baseUrl = `/invoices/{id}/order-notes`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["orderNotes"]) {
            fetchOptions.body = JSON.stringify(params["orderNotes"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPaymentStatus");
        }
        const baseUrl = `/invoices/{id}/payment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBillingInfo");
        }
        const baseUrl = `/invoices/{id}/billing-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billingInfoRequest"]) {
            fetchOptions.body = JSON.stringify(params["billingInfoRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoicesApi - functional programming interface
 */
export const InvoicesApiFp = {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor. <br><br><b>Permissions Needed:</b> INVOICES_USER or INVOICES_ADMIN
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: { req?: InvoiceCreateRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<InvoiceResource>> {
        const fetchArgs = InvoicesApiFetchParamCreator.createInvoice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getFulFillmentStatuses(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: { id: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceLogEntry> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoiceLogs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices. <br><br><b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: { filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoices(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getPaymentStatuses(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: { id: number; request?: PayBySavedMethodRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.payInvoice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: { id: number; bundleSku: string; sku: string; status: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setBundledInvoiceItemFulfillmentStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: { id: number; externalRef?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setExternalRef(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: { id: number; sku: string; status: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setInvoiceItemFulfillmentStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: { id: number; orderNotes?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setOrderNotes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: { id: number; request?: InvoicePaymentStatusRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setPaymentStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: { id: number; billingInfoRequest?: AddressResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.updateBillingInfo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoicesApi - object-oriented interface
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor. <br><br><b>Permissions Needed:</b> INVOICES_USER or INVOICES_ADMIN
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: {  req?: InvoiceCreateRequest; }, options: any = {}) {
        return InvoicesApiFp.createInvoice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options: any = {}) {
        return InvoicesApiFp.getFulFillmentStatuses(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  id: number; }, options: any = {}) {
        return InvoicesApiFp.getInvoice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, options: any = {}) {
        return InvoicesApiFp.getInvoiceLogs(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices. <br><br><b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return InvoicesApiFp.getInvoices(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(options: any = {}) {
        return InvoicesApiFp.getPaymentStatuses(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, options: any = {}) {
        return InvoicesApiFp.payInvoice(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setBundledInvoiceItemFulfillmentStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setExternalRef(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setOrderNotes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, options: any = {}) {
        return InvoicesApiFp.setPaymentStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, options: any = {}) {
        return InvoicesApiFp.updateBillingInfo(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoicesApi - factory interface
 */
export const InvoicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor. <br><br><b>Permissions Needed:</b> INVOICES_USER or INVOICES_ADMIN
         * @summary Create an invoice
         * @param req Invoice to be created
         */
        createInvoice(params: {  req?: InvoiceCreateRequest; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.createInvoice(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Lists available fulfillment statuses
         */
        getFulFillmentStatuses(configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.getFulFillmentStatuses(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
         * @summary Retrieve an invoice
         * @param id The id of the invoice
         */
        getInvoice(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.getInvoice(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
         * @summary List invoice logs
         * @param id The id of the invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.getInvoiceLogs(params, configuration, options)(fetch, basePath);
        },
        /**
         * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices. <br><br><b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
         * @summary Retrieve invoices
         * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
         * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
         * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
         * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
         * @param filterItemName Filters invoices by item name containing the given string
         * @param filterExternalRef Filters invoices by external reference.
         * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
         * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
         * @param filterCurrency Filters invoices by currency. ISO3 currency code
         * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
         * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
         * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
         * @param filterVendorName Filters invoices by vendor name starting with given string
         * @param filterSku Filters invoices by item sku
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.getInvoices(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Lists available payment statuses
         */
        getPaymentStatuses(configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.getPaymentStatuses(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
         * @summary Pay an invoice using a saved payment method
         * @param id The id of the invoice
         * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
         */
        payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.payInvoice(params, configuration, options)(fetch, basePath);
        },
        /**
         * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
         * @summary Set the fulfillment status of a bundled invoice item
         * @param id The id of the invoice
         * @param bundleSku The sku of the bundle in the invoice that contains the given target
         * @param sku The sku of an item in the bundle in the invoice
         * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
         */
        setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.setBundledInvoiceItemFulfillmentStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_ADMIN
         * @summary Set the external reference of an invoice
         * @param id The id of the invoice
         * @param externalRef External reference info
         */
        setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.setExternalRef(params, configuration, options)(fetch, basePath);
        },
        /**
         * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
         * @summary Set the fulfillment status of an invoice item
         * @param id The id of the invoice
         * @param sku The sku of an item in the invoice
         * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
         */
        setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_ADMIN
         * @summary Set the order notes of an invoice
         * @param id The id of the invoice
         * @param orderNotes Payment status info
         */
        setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.setOrderNotes(params, configuration, options)(fetch, basePath);
        },
        /**
         * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which. <br><br><b>Permissions Needed:</b> INVOICES_ADMIN
         * @summary Set the payment status of an invoice
         * @param id The id of the invoice
         * @param request Payment status info
         */
        setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.setPaymentStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVOICES_USER and owner, or INVOICES_ADMIN
         * @summary Set or update billing info
         * @param id The id of the invoice
         * @param billingInfoRequest Address info
         */
        updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, configuration: Configuration, options: any = {}) {
            return InvoicesApiFp.updateBillingInfo(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * LocationsApi - fetch parameter creator
 */
export const LocationsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of countries
     */
    getCountries(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Determined by geo ip location. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/location/geolocation/country`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryStates");
        }
        const baseUrl = `/location/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/location/geolocation/currency`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationsApi - functional programming interface
 */
export const LocationsApiFp = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of countries
     */
    getCountries(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<CountryResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountries(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Determined by geo ip location. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryByGeoLocation(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: { countryCodeIso3: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<StateResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryStates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = LocationsApiFetchParamCreator.getCurrencyByGeoLocation(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LocationsApi - object-oriented interface
 */
export class LocationsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of countries
     */
    getCountries(options: any = {}) {
        return LocationsApiFp.getCountries(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Determined by geo ip location. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(options: any = {}) {
        return LocationsApiFp.getCountryByGeoLocation(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  countryCodeIso3: string; }, options: any = {}) {
        return LocationsApiFp.getCountryStates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(options: any = {}) {
        return LocationsApiFp.getCurrencyByGeoLocation(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * LocationsApi - factory interface
 */
export const LocationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a list of countries
         */
        getCountries(configuration: Configuration, options: any = {}) {
            return LocationsApiFp.getCountries(configuration, options)(fetch, basePath);
        },
        /**
         * Determined by geo ip location. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get the iso3 code of your country
         */
        getCountryByGeoLocation(configuration: Configuration, options: any = {}) {
            return LocationsApiFp.getCountryByGeoLocation(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a list of a country's states
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryStates(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}) {
            return LocationsApiFp.getCountryStates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Determined by geo ip location, currency to country mapping and a fallback setting. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get the currency information of your country
         */
        getCurrencyByGeoLocation(configuration: Configuration, options: any = {}) {
            return LocationsApiFp.getCurrencyByGeoLocation(configuration, options)(fetch, basePath);
        },
    };
};


/**
 * LogsApi - fetch parameter creator
 */
export const LogsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  logEntry?: UserActionLog; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["logEntry"]) {
            fetchOptions.body = JSON.stringify(params["logEntry"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREEventLog");
        }
        const baseUrl = `/bre/logs/event-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterRuleId Filter event logs by request id
     */
    getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; filterRuleId?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/logs/event-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEventName"] !== undefined) {
            urlObj.query["filter_event_name"] = params["filterEventName"];
        }
        if (params["filterEventId"] !== undefined) {
            urlObj.query["filter_event_id"] = params["filterEventId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        if (params["filterRuleId"] !== undefined) {
            urlObj.query["filter_rule_id"] = params["filterRuleId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREForwardLog");
        }
        const baseUrl = `/bre/logs/forward-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param filterUrl Filter forward logs by URL starting with...
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; filterUrl?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/logs/forward-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["filterStatusCode"] !== undefined) {
            urlObj.query["filter_status_code"] = params["filterStatusCode"];
        }
        if (params["filterUrl"] !== undefined) {
            urlObj.query["filter_url"] = params["filterUrl"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserLog");
        }
        const baseUrl = `/audit/logs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterUser"] !== undefined) {
            urlObj.query["filter_user"] = params["filterUser"];
        }
        if (params["filterActionName"] !== undefined) {
            urlObj.query["filter_action_name"] = params["filterActionName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LogsApi - functional programming interface
 */
export const LogsApiFp = {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: { logEntry?: UserActionLog;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LogsApiFetchParamCreator.addUserLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterRuleId Filter event logs by request id
     */
    getBREEventLogs(params: { filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; filterRuleId?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLogs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param filterUrl Filter forward logs by URL starting with...
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: { filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; filterUrl?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLogs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: { filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLogs(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LogsApi - object-oriented interface
 */
export class LogsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> owner
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  logEntry?: UserActionLog; }, options: any = {}) {
        return LogsApiFp.addUserLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getBREEventLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterRuleId Filter event logs by request id
     */
    getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; filterRuleId?: string; }, options: any = {}) {
        return LogsApiFp.getBREEventLogs(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getBREForwardLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param filterUrl Filter forward logs by URL starting with...
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; filterUrl?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return LogsApiFp.getBREForwardLogs(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getUserLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> LOGS_ADMIN or owner
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return LogsApiFp.getUserLogs(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * LogsApi - factory interface
 */
export const LogsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> owner
         * @summary Add a user log entry
         * @param logEntry The user log entry to be added
         */
        addUserLog(params: {  logEntry?: UserActionLog; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.addUserLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
         * @summary Get an existing BRE event log entry by id
         * @param id The BRE event log entry id
         */
        getBREEventLog(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getBREEventLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
         * @summary Returns a list of BRE event log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEventName Filter event logs by event name
         * @param filterEventId Filter event logs by request id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterRuleId Filter event logs by request id
         */
        getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; filterRuleId?: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getBREEventLogs(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
         * @summary Get an existing forward log entry by id
         * @param id The forward log entry id
         */
        getBREForwardLog(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getBREForwardLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_ADMIN
         * @summary Returns a list of forward log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterStatusCode Filter forward logs by http status code
         * @param filterUrl Filter forward logs by URL starting with...
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; filterUrl?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getBREForwardLogs(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LOGS_ADMIN or owner
         * @summary Returns a user log entry by id
         * @param id The user log entry id
         */
        getUserLog(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getUserLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> LOGS_ADMIN or owner
         * @summary Returns a page of user logs entries
         * @param filterUser Filter for actions taken by a specific user by id
         * @param filterActionName Filter for actions of a specific name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return LogsApiFp.getUserLogs(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Media_ArtistsApi - fetch parameter creator
 */
export const Media_ArtistsApiFetchParamCreator = {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions. <br><br><b>Permissions Needed:</b> ANY
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: {  artistResource?: ArtistResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Artist Templates define a type of artist and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  id: number; showContributions?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["showContributions"] !== undefined) {
            urlObj.query["show_contributions"] = params["showContributions"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterArtistsByName"] !== undefined) {
            urlObj.query["filter_artists_by_name"] = params["filterArtistsByName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  id: number; artistResource?: ArtistResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Media_ArtistsApi - functional programming interface
 */
export const Media_ArtistsApiFp = {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions. <br><br><b>Permissions Needed:</b> ANY
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: { artistResource?: ArtistResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.addArtist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Artist Templates define a type of artist and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: { artistTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.createArtistTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.deleteArtist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.deleteArtistTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: { id: number; showContributions?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.getArtist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.getArtistTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.getArtistTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: { filterArtistsByName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceArtistResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.getArtists(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: { id: number; artistResource?: ArtistResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.updateArtist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: { id: string; artistTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_ArtistsApiFetchParamCreator.updateArtistTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Media_ArtistsApi - object-oriented interface
 */
export class Media_ArtistsApi extends BaseAPI {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions. <br><br><b>Permissions Needed:</b> ANY
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: {  artistResource?: ArtistResource; }, options: any = {}) {
        return Media_ArtistsApiFp.addArtist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Artist Templates define a type of artist and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_ArtistsApiFp.createArtistTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  id: number; }, options: any = {}) {
        return Media_ArtistsApiFp.deleteArtist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Media_ArtistsApiFp.deleteArtistTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  id: number; showContributions?: number; }, options: any = {}) {
        return Media_ArtistsApiFp.getArtist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  id: string; }, options: any = {}) {
        return Media_ArtistsApiFp.getArtistTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_ArtistsApiFp.getArtistTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_ArtistsApiFp.getArtists(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ARTISTS_ADMIN
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  id: number; artistResource?: ArtistResource; }, options: any = {}) {
        return Media_ArtistsApiFp.updateArtist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_ArtistsApiFp.updateArtistTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Media_ArtistsApi - factory interface
 */
export const Media_ArtistsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new artist in the system. Use specific media contributions endpoint to add contributions. <br><br><b>Permissions Needed:</b> ANY
         * @summary Adds a new artist in the system
         * @param artistResource The new artist
         */
        addArtist(params: {  artistResource?: ArtistResource; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.addArtist(params, configuration, options)(fetch, basePath);
        },
        /**
         * Artist Templates define a type of artist and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an artist template
         * @param artistTemplateResource The artist template resource object
         */
        createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.createArtistTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ARTISTS_ADMIN
         * @summary Removes an artist from the system IF no resources are attached to it
         * @param id The artist id
         */
        deleteArtist(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.deleteArtist(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an artist template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArtistTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.deleteArtistTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Loads a specific artist details
         * @param id The artist id
         * @param showContributions The number of contributions to show fetch
         */
        getArtist(params: {  id: number; showContributions?: number; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.getArtist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
         * @summary Get a single artist template
         * @param id The id of the template
         */
        getArtistTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.getArtistTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ARTISTS_ADMIN
         * @summary List and search artist templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.getArtistTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Search for artists
         * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.getArtists(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ARTISTS_ADMIN
         * @summary Modifies an artist details
         * @param id The artist id
         * @param artistResource The new artist
         */
        updateArtist(params: {  id: number; artistResource?: ArtistResource; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.updateArtist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an artist template
         * @param id The id of the template
         * @param artistTemplateResource The artist template resource object
         */
        updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_ArtistsApiFp.updateArtistTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Media_ModerationApi - fetch parameter creator
 */
export const Media_ModerationApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Add a flag
     * @param flagResource The flag resource object
     */
    addFlag(params: {  flagResource?: FlagResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/moderation/flags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["flagResource"]) {
            fetchOptions.body = JSON.stringify(params["flagResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Delete a flag
     * @param contextName The name of the context
     * @param contextId The id of the context
     * @param userId The id of the user
     */
    deleteFlag(params: {  contextName?: string; contextId?: string; userId?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/moderation/flags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["contextName"] !== undefined) {
            urlObj.query["context_name"] = params["contextName"];
        }
        if (params["contextId"] !== undefined) {
            urlObj.query["context_id"] = params["contextId"];
        }
        if (params["userId"] !== undefined) {
            urlObj.query["user_id"] = params["userId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Returns a page of flags
     * @param filterContext Filter by flag context
     * @param filterContextId Filter by flag context ID
     * @param filterUserId Filter by user ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFlags(params: {  filterContext?: string; filterContextId?: string; filterUserId?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/moderation/flags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterContextId"] !== undefined) {
            urlObj.query["filter_context_id"] = params["filterContextId"];
        }
        if (params["filterUserId"] !== undefined) {
            urlObj.query["filter_user_id"] = params["filterUserId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Context can be either a free-form string or a pre-defined context name. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param filterContextId Filter by moderation context ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; filterContextId?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/moderation/reports`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeResolved"] !== undefined) {
            urlObj.query["exclude_resolved"] = params["excludeResolved"];
        }
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterContextId"] !== undefined) {
            urlObj.query["filter_context_id"] = params["filterContextId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["flagReportResource"]) {
            fetchOptions.body = JSON.stringify(params["flagReportResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Media_ModerationApi - functional programming interface
 */
export const Media_ModerationApiFp = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Add a flag
     * @param flagResource The flag resource object
     */
    addFlag(params: { flagResource?: FlagResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FlagResource> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.addFlag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Delete a flag
     * @param contextName The name of the context
     * @param contextId The id of the context
     * @param userId The id of the user
     */
    deleteFlag(params: { contextName?: string; contextId?: string; userId?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.deleteFlag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Returns a page of flags
     * @param filterContext Filter by flag context
     * @param filterContextId Filter by flag context ID
     * @param filterUserId Filter by user ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFlags(params: { filterContext?: string; filterContextId?: string; filterUserId?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceFlagResource> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.getFlags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FlagReportResource> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.getModerationReport(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Context can be either a free-form string or a pre-defined context name. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param filterContextId Filter by moderation context ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getModerationReports(params: { excludeResolved?: boolean; filterContext?: string; filterContextId?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceFlagReportResource> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.getModerationReports(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: { id: number; flagReportResource?: FlagReportResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_ModerationApiFetchParamCreator.updateModerationReport(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Media_ModerationApi - object-oriented interface
 */
export class Media_ModerationApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Add a flag
     * @param flagResource The flag resource object
     */
    addFlag(params: {  flagResource?: FlagResource; }, options: any = {}) {
        return Media_ModerationApiFp.addFlag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Delete a flag
     * @param contextName The name of the context
     * @param contextId The id of the context
     * @param userId The id of the user
     */
    deleteFlag(params: {  contextName?: string; contextId?: string; userId?: number; }, options: any = {}) {
        return Media_ModerationApiFp.deleteFlag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
     * @summary Returns a page of flags
     * @param filterContext Filter by flag context
     * @param filterContextId Filter by flag context ID
     * @param filterUserId Filter by user ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFlags(params: {  filterContext?: string; filterContextId?: string; filterUserId?: number; size?: number; page?: number; }, options: any = {}) {
        return Media_ModerationApiFp.getFlags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  id: number; }, options: any = {}) {
        return Media_ModerationApiFp.getModerationReport(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Context can be either a free-form string or a pre-defined context name. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param filterContextId Filter by moderation context ID
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; filterContextId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_ModerationApiFp.getModerationReports(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, options: any = {}) {
        return Media_ModerationApiFp.updateModerationReport(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Media_ModerationApi - factory interface
 */
export const Media_ModerationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Add a flag
         * @param flagResource The flag resource object
         */
        addFlag(params: {  flagResource?: FlagResource; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.addFlag(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
         * @summary Delete a flag
         * @param contextName The name of the context
         * @param contextId The id of the context
         * @param userId The id of the user
         */
        deleteFlag(params: {  contextName?: string; contextId?: string; userId?: number; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.deleteFlag(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MODERATION_ADMIN or owner
         * @summary Returns a page of flags
         * @param filterContext Filter by flag context
         * @param filterContextId Filter by flag context ID
         * @param filterUserId Filter by user ID
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getFlags(params: {  filterContext?: string; filterContextId?: string; filterUserId?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.getFlags(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MODERATION_ADMIN
         * @summary Get a flag report
         * @param id The flag report id
         */
        getModerationReport(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.getModerationReport(params, configuration, options)(fetch, basePath);
        },
        /**
         * Context can be either a free-form string or a pre-defined context name. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
         * @summary Returns a page of flag reports
         * @param excludeResolved Ignore resolved context
         * @param filterContext Filter by moderation context
         * @param filterContextId Filter by moderation context ID
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; filterContextId?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.getModerationReports(params, configuration, options)(fetch, basePath);
        },
        /**
         * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason. <br><br><b>Permissions Needed:</b> MODERATION_ADMIN
         * @summary Update a flag report
         * @param id The flag report id
         * @param flagReportResource The new flag report
         */
        updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, configuration: Configuration, options: any = {}) {
            return Media_ModerationApiFp.updateModerationReport(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Media_PollsApi - fetch parameter creator
 */
export const Media_PollsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  id: string; answerKey?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling answerPoll");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answerKey"]) {
            fetchOptions.body = JSON.stringify(params["answerKey"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end. <br><br><b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: {  pollResource?: PollResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Poll templates define a type of poll and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollAnswer");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterText"] !== undefined) {
            urlObj.query["filter_text"] = params["filterText"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  id: string; pollResource?: PollResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Media_PollsApi - functional programming interface
 */
export const Media_PollsApiFp = {
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: { id: string; answerKey?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.answerPoll(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end. <br><br><b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: { pollResource?: PollResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.createPoll(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Poll templates define a type of poll and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: { pollTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.createPollTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_PollsApiFetchParamCreator.deletePoll(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_PollsApiFetchParamCreator.deletePollTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.getPoll(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.getPollAnswer(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.getPollTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.getPollTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: { filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcePollResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.getPolls(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: { id: string; pollResource?: PollResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.updatePoll(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: { id: string; pollTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_PollsApiFetchParamCreator.updatePollTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Media_PollsApi - object-oriented interface
 */
export class Media_PollsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  id: string; answerKey?: StringWrapper; }, options: any = {}) {
        return Media_PollsApiFp.answerPoll(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end. <br><br><b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: {  pollResource?: PollResource; }, options: any = {}) {
        return Media_PollsApiFp.createPoll(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Poll templates define a type of poll and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_PollsApiFp.createPollTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  id: string; }, options: any = {}) {
        return Media_PollsApiFp.deletePoll(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Media_PollsApiFp.deletePollTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  id: string; }, options: any = {}) {
        return Media_PollsApiFp.getPoll(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  id: string; }, options: any = {}) {
        return Media_PollsApiFp.getPollAnswer(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  id: string; }, options: any = {}) {
        return Media_PollsApiFp.getPollTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_PollsApiFp.getPollTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_PollsApiFp.getPolls(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> POLLS_ADMIN
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  id: string; pollResource?: PollResource; }, options: any = {}) {
        return Media_PollsApiFp.updatePoll(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_PollsApiFp.updatePollTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Media_PollsApi - factory interface
 */
export const Media_PollsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
         * @summary Add your vote to a poll
         * @param id The poll id
         * @param answerKey The answer key
         */
        answerPoll(params: {  id: string; answerKey?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.answerPoll(params, configuration, options)(fetch, basePath);
        },
        /**
         * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end. <br><br><b>Permissions Needed:</b> POLLS_ADMIN
         * @summary Create a new poll
         * @param pollResource The poll object
         */
        createPoll(params: {  pollResource?: PollResource; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.createPoll(params, configuration, options)(fetch, basePath);
        },
        /**
         * Poll templates define a type of poll and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a poll template
         * @param pollTemplateResource The poll template resource object
         */
        createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.createPollTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> POLLS_ADMIN
         * @summary Delete an existing poll
         * @param id The poll id
         */
        deletePoll(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.deletePoll(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a poll template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deletePollTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.deletePollTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single poll
         * @param id The poll id
         */
        getPoll(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.getPoll(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> POLLS_ADMIN or POLLS_USER
         * @summary Get poll answer
         * @param id The poll id
         */
        getPollAnswer(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.getPollAnswer(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
         * @summary Get a single poll template
         * @param id The id of the template
         */
        getPollTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.getPollTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or POLLS_ADMIN
         * @summary List and search poll templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPollTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.getPollTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed. <br><br><b>Permissions Needed:</b> ANY
         * @summary List and search polls
         * @param filterCategory Filter for polls from a specific category by id
         * @param filterTagset Filter for polls with specified tags (separated by comma)
         * @param filterText Filter for polls whose text contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.getPolls(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> POLLS_ADMIN
         * @summary Update an existing poll
         * @param id The poll id
         * @param pollResource The poll object
         */
        updatePoll(params: {  id: string; pollResource?: PollResource; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.updatePoll(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a poll template
         * @param id The id of the template
         * @param pollTemplateResource The poll template resource object
         */
        updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_PollsApiFp.updatePollTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Media_VideosApi - fetch parameter creator
 */
export const Media_VideosApiFetchParamCreator = {
    /**
     * Whitelisted users can view video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addUserToVideoWhitelist");
        }
        const baseUrl = `/media/videos/{id}/whitelist`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  videoResource?: VideoResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["contributionResource"]) {
            fetchOptions.body = JSON.stringify(params["contributionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reason"]) {
            fetchOptions.body = JSON.stringify(params["reason"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoRelationshipResource"]) {
            fetchOptions.body = JSON.stringify(params["videoRelationshipResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling createVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["dispositionResource"]) {
            fetchOptions.body = JSON.stringify(params["dispositionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Video Templates define a type of video and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a video template
     * @param videoTemplateResource The video template resource object
     */
    createVideoTemplate(params: {  videoTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["videoTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  dispositionId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "dispositionId" is set
        if (params["dispositionId"] == null) {
            throw new Error("Missing required parameter dispositionId when calling deleteVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions/{disposition_id}`
            .replace(`{${"disposition_id"}}`, `${ params["dispositionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  videoId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoRelationship");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a video template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteVideoTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoTemplate");
        }
        const baseUrl = `/media/videos/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserVideos");
        }
        const baseUrl = `/users/{user_id}/videos`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeFlagged"] !== undefined) {
            urlObj.query["exclude_flagged"] = params["excludeFlagged"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoComments");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoDispositions");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary Get a single video template
     * @param id The id of the template
     */
    getVideoTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVideoTemplate");
        }
        const baseUrl = `/media/videos/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary List and search video templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideoTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeFlagged"] !== undefined) {
            urlObj.query["exclude_flagged"] = params["excludeFlagged"];
        }
        if (params["filterVideosByUploader"] !== undefined) {
            urlObj.query["filter_videos_by_uploader"] = params["filterVideosByUploader"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterVideosByName"] !== undefined) {
            urlObj.query["filter_videos_by_name"] = params["filterVideosByName"];
        }
        if (params["filterVideosByContributor"] !== undefined) {
            urlObj.query["filter_videos_by_contributor"] = params["filterVideosByContributor"];
        }
        if (params["filterVideosByAuthor"] !== undefined) {
            urlObj.query["filter_videos_by_author"] = params["filterVideosByAuthor"];
        }
        if (params["filterHasAuthor"] !== undefined) {
            urlObj.query["filter_has_author"] = params["filterHasAuthor"];
        }
        if (params["filterHasUploader"] !== undefined) {
            urlObj.query["filter_has_uploader"] = params["filterHasUploader"];
        }
        if (params["filterRelatedTo"] !== undefined) {
            urlObj.query["filter_related_to"] = params["filterRelatedTo"];
        }
        if (params["filterFriends"] !== undefined) {
            urlObj.query["filter_friends"] = params["filterFriends"];
        }
        if (params["filterDisposition"] !== undefined) {
            urlObj.query["filter_disposition"] = params["filterDisposition"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeUserFromVideoWhitelist");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeUserFromVideoWhitelist");
        }
        const baseUrl = `/media/videos/{video_id}/whitelist/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeVideoContributor");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  id: number; videoResource?: VideoResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}/content`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoRelationship");
        }
        // verify required parameter "relationshipId" is set
        if (params["relationshipId"] == null) {
            throw new Error("Missing required parameter relationshipId when calling updateVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}/relationship_details`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"relationship_id"}}`, `${ params["relationshipId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a video template
     * @param id The id of the template
     * @param videoTemplateResource The video template resource object
     */
    updateVideoTemplate(params: {  id: string; videoTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideoTemplate");
        }
        const baseUrl = `/media/videos/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["videoTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling viewVideo");
        }
        const baseUrl = `/media/videos/{id}/views`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Media_VideosApi - functional programming interface
 */
export const Media_VideosApiFp = {
    /**
     * Whitelisted users can view video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: { id: number; userId?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addUserToVideoWhitelist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: { videoResource?: VideoResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addVideo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: { videoId: number; commentResource?: CommentResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addVideoComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: { videoId: number; contributionResource?: ContributionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addVideoContributor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: { videoId: number; reason?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FlagResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addVideoFlag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: { videoId: number; videoRelationshipResource?: VideoRelationshipResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoRelationshipResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.addVideoRelationships(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: { videoId: number; dispositionResource?: DispositionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.createVideoDisposition(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Video Templates define a type of video and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a video template
     * @param videoTemplateResource The video template resource object
     */
    createVideoTemplate(params: { videoTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.createVideoTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: { videoId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideoComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: { dispositionId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideoDisposition(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: { videoId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideoFlag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: { videoId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideoRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a video template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteVideoTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.deleteVideoTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: { userId: number; excludeFlagged?: boolean; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getUserVideos(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: { videoId: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideoComments(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: { videoId: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideoDispositions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: { videoId: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoRelationshipResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideoRelationships(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary Get a single video template
     * @param id The id of the template
     */
    getVideoTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideoTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary List and search video templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideoTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideoTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: { excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.getVideos(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: { videoId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.removeUserFromVideoWhitelist(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: { videoId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.removeVideoContributor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: { id: number; videoResource?: VideoResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.updateVideo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: { videoId: number; id: number; content?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.updateVideoComment(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: { videoId: number; relationshipId: number; details?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.updateVideoRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a video template
     * @param id The id of the template
     * @param videoTemplateResource The video template resource object
     */
    updateVideoTemplate(params: { id: string; videoTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Media_VideosApiFetchParamCreator.updateVideoTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Media_VideosApiFetchParamCreator.viewVideo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Media_VideosApi - object-oriented interface
 */
export class Media_VideosApi extends BaseAPI {
    /**
     * Whitelisted users can view video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, options: any = {}) {
        return Media_VideosApiFp.addUserToVideoWhitelist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  videoResource?: VideoResource; }, options: any = {}) {
        return Media_VideosApiFp.addVideo(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, options: any = {}) {
        return Media_VideosApiFp.addVideoComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, options: any = {}) {
        return Media_VideosApiFp.addVideoContributor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, options: any = {}) {
        return Media_VideosApiFp.addVideoFlag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, options: any = {}) {
        return Media_VideosApiFp.addVideoRelationships(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, options: any = {}) {
        return Media_VideosApiFp.createVideoDisposition(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Video Templates define a type of video and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a video template
     * @param videoTemplateResource The video template resource object
     */
    createVideoTemplate(params: {  videoTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_VideosApiFp.createVideoTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  id: number; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideo(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  videoId: number; id: number; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideoComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  dispositionId: number; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideoDisposition(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  videoId: number; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideoFlag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  videoId: number; id: number; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideoRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a video template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteVideoTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Media_VideosApiFp.deleteVideoTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, options: any = {}) {
        return Media_VideosApiFp.getUserVideos(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  id: number; }, options: any = {}) {
        return Media_VideosApiFp.getVideo(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return Media_VideosApiFp.getVideoComments(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return Media_VideosApiFp.getVideoDispositions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return Media_VideosApiFp.getVideoRelationships(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary Get a single video template
     * @param id The id of the template
     */
    getVideoTemplate(params: {  id: string; }, options: any = {}) {
        return Media_VideosApiFp.getVideoTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
     * @summary List and search video templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideoTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_VideosApiFp.getVideoTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Media_VideosApiFp.getVideos(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, options: any = {}) {
        return Media_VideosApiFp.removeUserFromVideoWhitelist(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  videoId: number; id: number; }, options: any = {}) {
        return Media_VideosApiFp.removeVideoContributor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  id: number; videoResource?: VideoResource; }, options: any = {}) {
        return Media_VideosApiFp.updateVideo(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, options: any = {}) {
        return Media_VideosApiFp.updateVideoComment(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, options: any = {}) {
        return Media_VideosApiFp.updateVideoRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a video template
     * @param id The id of the template
     * @param videoTemplateResource The video template resource object
     */
    updateVideoTemplate(params: {  id: string; videoTemplateResource?: TemplateResource; }, options: any = {}) {
        return Media_VideosApiFp.updateVideoTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: {  id: number; }, options: any = {}) {
        return Media_VideosApiFp.viewVideo(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Media_VideosApi - factory interface
 */
export const Media_VideosApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Whitelisted users can view video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Adds a user to a video's whitelist
         * @param id The video id
         * @param userId The user id
         */
        addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addUserToVideoWhitelist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Adds a new video in the system
         * @param videoResource The video object
         */
        addVideo(params: {  videoResource?: VideoResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addVideo(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Add a new video comment
         * @param videoId The video id 
         * @param commentResource The comment object
         */
        addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addVideoComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Adds a contributor to a video
         * @param videoId The video id
         * @param contributionResource The contribution object
         */
        addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addVideoContributor(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Add a new flag
         * @param videoId The video id
         * @param reason The flag reason
         */
        addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addVideoFlag(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Adds one or more existing videos as related to this one
         * @param videoId The video id
         * @param videoRelationshipResource The video relationship object 
         */
        addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.addVideoRelationships(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Create a video disposition
         * @param videoId The video id
         * @param dispositionResource The disposition object
         */
        createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.createVideoDisposition(params, configuration, options)(fetch, basePath);
        },
        /**
         * Video Templates define a type of video and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a video template
         * @param videoTemplateResource The video template resource object
         */
        createVideoTemplate(params: {  videoTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.createVideoTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Deletes a video from the system if no resources are attached to it
         * @param id The video id
         */
        deleteVideo(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideo(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Delete a video comment
         * @param videoId The video id
         * @param id The comment id
         */
        deleteVideoComment(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideoComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Delete a video disposition
         * @param dispositionId The disposition id
         */
        deleteVideoDisposition(params: {  dispositionId: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideoDisposition(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Delete a flag
         * @param videoId The video id
         */
        deleteVideoFlag(params: {  videoId: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideoFlag(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Delete a video's relationship
         * @param videoId The video id
         * @param id The relationship id
         */
        deleteVideoRelationship(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideoRelationship(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a video template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteVideoTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.deleteVideoTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Get user videos
         * @param userId The user id
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getUserVideos(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Loads a specific video details
         * @param id The video id
         */
        getVideo(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideo(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a page of comments for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoComments(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideoComments(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a page of dispositions for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideoDispositions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Returns a page of video relationships
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideoRelationships(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
         * @summary Get a single video template
         * @param id The id of the template
         */
        getVideoTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideoTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or VIDEOS_ADMIN
         * @summary List and search video templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVideoTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideoTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Search videos using the documented filters
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param filterVideosByUploader Filter for videos by uploader id
         * @param filterCategory Filter for videos from a specific category by id
         * @param filterTagset Filter for videos with specified tags (separated by comma)
         * @param filterVideosByName Filter for videos which name *STARTS* with the given string
         * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
         * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
         * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
         * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
         * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
         * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
         * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.getVideos(params, configuration, options)(fetch, basePath);
        },
        /**
         * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting. <br><br><b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Removes a user from a video's whitelist
         * @param videoId The video id
         * @param id The user id
         */
        removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.removeUserFromVideoWhitelist(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Removes a contributor from a video
         * @param videoId The video id
         * @param id The contributor id
         */
        removeVideoContributor(params: {  videoId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.removeVideoContributor(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Modifies a video's details
         * @param id The video id
         * @param videoResource The video object
         */
        updateVideo(params: {  id: number; videoResource?: VideoResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.updateVideo(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Update a video comment
         * @param videoId The video id
         * @param id The comment id
         * @param content The comment content
         */
        updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.updateVideoComment(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VIDEOS_USER or VIDEOS_ADMIN
         * @summary Update a video's relationship details
         * @param videoId The video id
         * @param relationshipId The relationship id
         * @param details The video relationship details
         */
        updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.updateVideoRelationship(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a video template
         * @param id The id of the template
         * @param videoTemplateResource The video template resource object
         */
        updateVideoTemplate(params: {  id: string; videoTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.updateVideoTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Increment a video's view count
         * @param id The video id
         */
        viewVideo(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Media_VideosApiFp.viewVideo(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * MessagingApi - fetch parameter creator
 */
export const MessagingApiFetchParamCreator = {
    /**
     * Processes a set of input data against the template and returnes the compiled result. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Compile a message template
     * @param request request
     */
    compileMessageTemplate(params: {  request?: MessageTemplateBulkRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templates/compilations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Create a message template
     * @param messageTemplate The new template email to be sent
     */
    createMessageTemplate(params: {  messageTemplate?: MessageTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageTemplate"]) {
            fetchOptions.body = JSON.stringify(params["messageTemplate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Delete an existing message template
     * @param id The message_template id
     */
    deleteMessageTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteMessageTemplate");
        }
        const baseUrl = `/messaging/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Get a single message template
     * @param id The message_template id
     */
    getMessageTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getMessageTemplate");
        }
        const baseUrl = `/messaging/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of message templates with optional filtering. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary List and search message templates
     * @param filterTagset Filter for message templates with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for message templates with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for message templates with none of a specified set of tags (separated by comma)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getMessageTemplates(params: {  filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterTagIntersection"] !== undefined) {
            urlObj.query["filter_tag_intersection"] = params["filterTagIntersection"];
        }
        if (params["filterTagExclusion"] !== undefined) {
            urlObj.query["filter_tag_exclusion"] = params["filterTagExclusion"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a message with one or more formats to one or more users. Fill in any message formats desired (email, sms, websockets) and each user will recieve all valid formats. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a message
     * @param messageResource The message to be sent
     */
    sendMessage(params: {  messageResource?: MessageResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/message`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageResource"]) {
            fetchOptions.body = JSON.stringify(params["messageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/raw-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawEmailResource"]) {
            fetchOptions.body = JSON.stringify(params["rawEmailResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a raw push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw push notification
     * @param rawPushResource The new raw push notification to be sent
     */
    sendRawPush(params: {  rawPushResource?: RawPushResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/raw-push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawPushResource"]) {
            fetchOptions.body = JSON.stringify(params["rawPushResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/raw-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["rawSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templated-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageResource"]) {
            fetchOptions.body = JSON.stringify(params["messageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a templated push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated push notification
     * @param templatePushResource The new templated push notification to be sent
     */
    sendTemplatedPush(params: {  templatePushResource?: TemplatePushResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templated-push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["templatePushResource"]) {
            fetchOptions.body = JSON.stringify(params["templatePushResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templated-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["templateSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["templateSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a websocket message to one or more users. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a websocket message
     * @param websocketResource The new websocket message to be sent
     */
    sendWebsocket(params: {  websocketResource?: WebsocketMessageResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/websocket-message`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["websocketResource"]) {
            fetchOptions.body = JSON.stringify(params["websocketResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Update an existing message template
     * @param id The message_template id
     * @param messageTemplateResource The message template
     */
    updateMessageTemplate(params: {  id: string; messageTemplateResource?: MessageTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateMessageTemplate");
        }
        const baseUrl = `/messaging/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["messageTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MessagingApi - functional programming interface
 */
export const MessagingApiFp = {
    /**
     * Processes a set of input data against the template and returnes the compiled result. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Compile a message template
     * @param request request
     */
    compileMessageTemplate(params: { request?: MessageTemplateBulkRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<{ [key: string]: string; }> {
        const fetchArgs = MessagingApiFetchParamCreator.compileMessageTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Create a message template
     * @param messageTemplate The new template email to be sent
     */
    createMessageTemplate(params: { messageTemplate?: MessageTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<MessageTemplateResource> {
        const fetchArgs = MessagingApiFetchParamCreator.createMessageTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Delete an existing message template
     * @param id The message_template id
     */
    deleteMessageTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.deleteMessageTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Get a single message template
     * @param id The message_template id
     */
    getMessageTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<MessageTemplateResource> {
        const fetchArgs = MessagingApiFetchParamCreator.getMessageTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of message templates with optional filtering. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary List and search message templates
     * @param filterTagset Filter for message templates with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for message templates with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for message templates with none of a specified set of tags (separated by comma)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getMessageTemplates(params: { filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceMessageTemplateResource> {
        const fetchArgs = MessagingApiFetchParamCreator.getMessageTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a message with one or more formats to one or more users. Fill in any message formats desired (email, sms, websockets) and each user will recieve all valid formats. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a message
     * @param messageResource The message to be sent
     */
    sendMessage(params: { messageResource?: MessageResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendMessage(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: { rawEmailResource?: RawEmailResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawEmail(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a raw push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw push notification
     * @param rawPushResource The new raw push notification to be sent
     */
    sendRawPush(params: { rawPushResource?: RawPushResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawPush(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: { rawSMSResource?: RawSMSResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawSMS(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: { messageResource?: TemplateEmailResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedEmail(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a templated push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated push notification
     * @param templatePushResource The new templated push notification to be sent
     */
    sendTemplatedPush(params: { templatePushResource?: TemplatePushResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedPush(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: { templateSMSResource?: TemplateSMSResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedSMS(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a websocket message to one or more users. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a websocket message
     * @param websocketResource The new websocket message to be sent
     */
    sendWebsocket(params: { websocketResource?: WebsocketMessageResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendWebsocket(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Update an existing message template
     * @param id The message_template id
     * @param messageTemplateResource The message template
     */
    updateMessageTemplate(params: { id: string; messageTemplateResource?: MessageTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<MessageTemplateResource> {
        const fetchArgs = MessagingApiFetchParamCreator.updateMessageTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MessagingApi - object-oriented interface
 */
export class MessagingApi extends BaseAPI {
    /**
     * Processes a set of input data against the template and returnes the compiled result. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Compile a message template
     * @param request request
     */
    compileMessageTemplate(params: {  request?: MessageTemplateBulkRequest; }, options: any = {}) {
        return MessagingApiFp.compileMessageTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Create a message template
     * @param messageTemplate The new template email to be sent
     */
    createMessageTemplate(params: {  messageTemplate?: MessageTemplateResource; }, options: any = {}) {
        return MessagingApiFp.createMessageTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Delete an existing message template
     * @param id The message_template id
     */
    deleteMessageTemplate(params: {  id: string; }, options: any = {}) {
        return MessagingApiFp.deleteMessageTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Get a single message template
     * @param id The message_template id
     */
    getMessageTemplate(params: {  id: string; }, options: any = {}) {
        return MessagingApiFp.getMessageTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of message templates with optional filtering. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary List and search message templates
     * @param filterTagset Filter for message templates with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for message templates with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for message templates with none of a specified set of tags (separated by comma)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getMessageTemplates(params: {  filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return MessagingApiFp.getMessageTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a message with one or more formats to one or more users. Fill in any message formats desired (email, sms, websockets) and each user will recieve all valid formats. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a message
     * @param messageResource The message to be sent
     */
    sendMessage(params: {  messageResource?: MessageResource; }, options: any = {}) {
        return MessagingApiFp.sendMessage(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, options: any = {}) {
        return MessagingApiFp.sendRawEmail(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a raw push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw push notification
     * @param rawPushResource The new raw push notification to be sent
     */
    sendRawPush(params: {  rawPushResource?: RawPushResource; }, options: any = {}) {
        return MessagingApiFp.sendRawPush(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, options: any = {}) {
        return MessagingApiFp.sendRawSMS(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, options: any = {}) {
        return MessagingApiFp.sendTemplatedEmail(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a templated push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a templated push notification
     * @param templatePushResource The new templated push notification to be sent
     */
    sendTemplatedPush(params: {  templatePushResource?: TemplatePushResource; }, options: any = {}) {
        return MessagingApiFp.sendTemplatedPush(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, options: any = {}) {
        return MessagingApiFp.sendTemplatedSMS(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a websocket message to one or more users. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Send a websocket message
     * @param websocketResource The new websocket message to be sent
     */
    sendWebsocket(params: {  websocketResource?: WebsocketMessageResource; }, options: any = {}) {
        return MessagingApiFp.sendWebsocket(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MESSAGING_ADMIN
     * @summary Update an existing message template
     * @param id The message_template id
     * @param messageTemplateResource The message template
     */
    updateMessageTemplate(params: {  id: string; messageTemplateResource?: MessageTemplateResource; }, options: any = {}) {
        return MessagingApiFp.updateMessageTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * MessagingApi - factory interface
 */
export const MessagingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Processes a set of input data against the template and returnes the compiled result. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Compile a message template
         * @param request request
         */
        compileMessageTemplate(params: {  request?: MessageTemplateBulkRequest; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.compileMessageTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Create a message template
         * @param messageTemplate The new template email to be sent
         */
        createMessageTemplate(params: {  messageTemplate?: MessageTemplateResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.createMessageTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Delete an existing message template
         * @param id The message_template id
         */
        deleteMessageTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.deleteMessageTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Get a single message template
         * @param id The message_template id
         */
        getMessageTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.getMessageTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of message templates with optional filtering. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary List and search message templates
         * @param filterTagset Filter for message templates with at least one of a specified set of tags (separated by comma)
         * @param filterTagIntersection Filter for message templates with all of a specified set of tags (separated by comma)
         * @param filterTagExclusion Filter for message templates with none of a specified set of tags (separated by comma)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getMessageTemplates(params: {  filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.getMessageTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a message with one or more formats to one or more users. Fill in any message formats desired (email, sms, websockets) and each user will recieve all valid formats. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a message
         * @param messageResource The message to be sent
         */
        sendMessage(params: {  messageResource?: MessageResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendMessage(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a raw email to one or more users
         * @param rawEmailResource The new raw email to be sent
         */
        sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendRawEmail(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a raw push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a raw push notification
         * @param rawPushResource The new raw push notification to be sent
         */
        sendRawPush(params: {  rawPushResource?: RawPushResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendRawPush(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a raw SMS
         * @param rawSMSResource The new raw SMS to be sent
         */
        sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendRawSMS(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a templated email to one or more users
         * @param messageResource The new template email to be sent
         */
        sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendTemplatedEmail(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a templated push notification message to one or more users. User's without registered mobile device for the application will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a templated push notification
         * @param templatePushResource The new templated push notification to be sent
         */
        sendTemplatedPush(params: {  templatePushResource?: TemplatePushResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendTemplatedPush(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a new templated SMS
         * @param templateSMSResource The new template SMS to be sent
         */
        sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendTemplatedSMS(params, configuration, options)(fetch, basePath);
        },
        /**
         * Sends a websocket message to one or more users. <br><br><b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Send a websocket message
         * @param websocketResource The new websocket message to be sent
         */
        sendWebsocket(params: {  websocketResource?: WebsocketMessageResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.sendWebsocket(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MESSAGING_ADMIN
         * @summary Update an existing message template
         * @param id The message_template id
         * @param messageTemplateResource The message template
         */
        updateMessageTemplate(params: {  id: string; messageTemplateResource?: MessageTemplateResource; }, configuration: Configuration, options: any = {}) {
            return MessagingApiFp.updateMessageTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Messaging_TopicsApi - fetch parameter creator
 */
export const Messaging_TopicsApiFetchParamCreator = {
    /**
     * Useful for opt-out options on a single topic. Consider multiple topics for multiple opt-out options. <br><br><b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable messages for a user
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param disabled disabled
     */
    disableTopicSubscriber(params: {  id: string; userId: string; disabled: ValueWrapperboolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling disableTopicSubscriber");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling disableTopicSubscriber");
        }
        // verify required parameter "disabled" is set
        if (params["disabled"] == null) {
            throw new Error("Missing required parameter disabled when calling disableTopicSubscriber");
        }
        const baseUrl = `/messaging/topics/{id}/subscribers/{user_id}/disabled`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["disabled"]) {
            fetchOptions.body = JSON.stringify(params["disabled"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get a subscriber to a topic
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getTopicSubscriber(params: {  id: string; userId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTopicSubscriber");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getTopicSubscriber");
        }
        const baseUrl = `/messaging/topics/{id}/subscribers/{user_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get all messaging topics for a given user
     * @param id The id of the user or &#39;me&#39;
     */
    getUserTopics(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserTopics");
        }
        const baseUrl = `/users/{id}/topics`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Messaging_TopicsApi - functional programming interface
 */
export const Messaging_TopicsApiFp = {
    /**
     * Useful for opt-out options on a single topic. Consider multiple topics for multiple opt-out options. <br><br><b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable messages for a user
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param disabled disabled
     */
    disableTopicSubscriber(params: { id: string; userId: string; disabled: ValueWrapperboolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Messaging_TopicsApiFetchParamCreator.disableTopicSubscriber(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get a subscriber to a topic
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getTopicSubscriber(params: { id: string; userId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TopicSubscriberResource> {
        const fetchArgs = Messaging_TopicsApiFetchParamCreator.getTopicSubscriber(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get all messaging topics for a given user
     * @param id The id of the user or &#39;me&#39;
     */
    getUserTopics(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTopicResource> {
        const fetchArgs = Messaging_TopicsApiFetchParamCreator.getUserTopics(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Messaging_TopicsApi - object-oriented interface
 */
export class Messaging_TopicsApi extends BaseAPI {
    /**
     * Useful for opt-out options on a single topic. Consider multiple topics for multiple opt-out options. <br><br><b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable messages for a user
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param disabled disabled
     */
    disableTopicSubscriber(params: {  id: string; userId: string; disabled: ValueWrapperboolean; }, options: any = {}) {
        return Messaging_TopicsApiFp.disableTopicSubscriber(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get a subscriber to a topic
     * @param id The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getTopicSubscriber(params: {  id: string; userId: string; }, options: any = {}) {
        return Messaging_TopicsApiFp.getTopicSubscriber(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Get all messaging topics for a given user
     * @param id The id of the user or &#39;me&#39;
     */
    getUserTopics(params: {  id: string; }, options: any = {}) {
        return Messaging_TopicsApiFp.getUserTopics(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Messaging_TopicsApi - factory interface
 */
export const Messaging_TopicsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Useful for opt-out options on a single topic. Consider multiple topics for multiple opt-out options. <br><br><b>Permissions Needed:</b> TOPICS_ADMIN or self
         * @summary Enable or disable messages for a user
         * @param id The id of the topic
         * @param userId The id of the subscriber or &#39;me&#39;
         * @param disabled disabled
         */
        disableTopicSubscriber(params: {  id: string; userId: string; disabled: ValueWrapperboolean; }, configuration: Configuration, options: any = {}) {
            return Messaging_TopicsApiFp.disableTopicSubscriber(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TOPICS_ADMIN or self
         * @summary Get a subscriber to a topic
         * @param id The id of the topic
         * @param userId The id of the subscriber or &#39;me&#39;
         */
        getTopicSubscriber(params: {  id: string; userId: string; }, configuration: Configuration, options: any = {}) {
            return Messaging_TopicsApiFp.getTopicSubscriber(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TOPICS_ADMIN or self
         * @summary Get all messaging topics for a given user
         * @param id The id of the user or &#39;me&#39;
         */
        getUserTopics(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Messaging_TopicsApiFp.getUserTopics(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * NotificationsApi - fetch parameter creator
 */
export const NotificationsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Create a notification type
     * @param notificationType notificationType
     */
    createNotificationType(params: {  notificationType?: NotificationTypeResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/notifications/types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["notificationType"]) {
            fetchOptions.body = JSON.stringify(params["notificationType"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Delete a notification type
     * @param id id
     */
    deleteNotificationType(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteNotificationType");
        }
        const baseUrl = `/notifications/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Get a single notification type
     * @param id id
     */
    getNotificationType(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getNotificationType");
        }
        const baseUrl = `/notifications/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of notification type with optional filtering. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary List and search notification types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getNotificationTypes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/notifications/types`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings for a type
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getUserNotificationInfo(params: {  typeId: string; userId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeId" is set
        if (params["typeId"] == null) {
            throw new Error("Missing required parameter typeId when calling getUserNotificationInfo");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserNotificationInfo");
        }
        const baseUrl = `/users/{user_id}/notifications/types/{type_id}`
            .replace(`{${"type_id"}}`, `${ params["typeId"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotificationInfoList(params: {  userId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserNotificationInfoList");
        }
        const baseUrl = `/users/{user_id}/notifications/types`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Get notifications
     * @param id The id of the user or &#39;me&#39;
     * @param filterStatus filter for notifications with a given status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotifications(params: {  id: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserNotifications");
        }
        const baseUrl = `/users/{id}/notifications`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Send a notification
     * @param notification notification
     */
    sendNotification(params: {  notification?: NotificationResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["notification"]) {
            fetchOptions.body = JSON.stringify(params["notification"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Set notification status
     * @param userId The id of the user or &#39;me&#39;
     * @param notificationId The id of the notification
     * @param notification status
     */
    setUserNotificationStatus(params: {  userId: string; notificationId: string; notification?: UserNotificationStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserNotificationStatus");
        }
        // verify required parameter "notificationId" is set
        if (params["notificationId"] == null) {
            throw new Error("Missing required parameter notificationId when calling setUserNotificationStatus");
        }
        const baseUrl = `/users/{user_id}/notifications/{notification_id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"notification_id"}}`, `${ params["notificationId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["notification"]) {
            fetchOptions.body = JSON.stringify(params["notification"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Allows enabling or disabling messages for a given notification type when sent direct to the user. Notifications can still be retrieved by endpoint. For notifications broadcased to a topic, see the topic service to disable messages for the user there. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Enable or disable direct notifications for a user
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param silenced silenced
     */
    silenceDirectNotifications(params: {  typeId: string; userId: string; silenced: ValueWrapperboolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "typeId" is set
        if (params["typeId"] == null) {
            throw new Error("Missing required parameter typeId when calling silenceDirectNotifications");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling silenceDirectNotifications");
        }
        // verify required parameter "silenced" is set
        if (params["silenced"] == null) {
            throw new Error("Missing required parameter silenced when calling silenceDirectNotifications");
        }
        const baseUrl = `/users/{user_id}/notifications/types/{type_id}/silenced`
            .replace(`{${"type_id"}}`, `${ params["typeId"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["silenced"]) {
            fetchOptions.body = JSON.stringify(params["silenced"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Update a notificationType
     * @param id id
     * @param notificationType notificationType
     */
    updateNotificationType(params: {  id: string; notificationType?: NotificationTypeResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateNotificationType");
        }
        const baseUrl = `/notifications/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["notificationType"]) {
            fetchOptions.body = JSON.stringify(params["notificationType"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * NotificationsApi - functional programming interface
 */
export const NotificationsApiFp = {
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Create a notification type
     * @param notificationType notificationType
     */
    createNotificationType(params: { notificationType?: NotificationTypeResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<NotificationTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.createNotificationType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Delete a notification type
     * @param id id
     */
    deleteNotificationType(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationsApiFetchParamCreator.deleteNotificationType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Get a single notification type
     * @param id id
     */
    getNotificationType(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<NotificationTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.getNotificationType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of notification type with optional filtering. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary List and search notification types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getNotificationTypes(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceNotificationTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.getNotificationTypes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings for a type
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getUserNotificationInfo(params: { typeId: string; userId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<NotificationUserTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.getUserNotificationInfo(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotificationInfoList(params: { userId: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceNotificationUserTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.getUserNotificationInfoList(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Get notifications
     * @param id The id of the user or &#39;me&#39;
     * @param filterStatus filter for notifications with a given status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotifications(params: { id: string; filterStatus?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserNotificationResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.getUserNotifications(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Send a notification
     * @param notification notification
     */
    sendNotification(params: { notification?: NotificationResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<NotificationResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.sendNotification(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Set notification status
     * @param userId The id of the user or &#39;me&#39;
     * @param notificationId The id of the notification
     * @param notification status
     */
    setUserNotificationStatus(params: { userId: string; notificationId: string; notification?: UserNotificationStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationsApiFetchParamCreator.setUserNotificationStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Allows enabling or disabling messages for a given notification type when sent direct to the user. Notifications can still be retrieved by endpoint. For notifications broadcased to a topic, see the topic service to disable messages for the user there. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Enable or disable direct notifications for a user
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param silenced silenced
     */
    silenceDirectNotifications(params: { typeId: string; userId: string; silenced: ValueWrapperboolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationsApiFetchParamCreator.silenceDirectNotifications(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Update a notificationType
     * @param id id
     * @param notificationType notificationType
     */
    updateNotificationType(params: { id: string; notificationType?: NotificationTypeResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<NotificationTypeResource> {
        const fetchArgs = NotificationsApiFetchParamCreator.updateNotificationType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * NotificationsApi - object-oriented interface
 */
export class NotificationsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Create a notification type
     * @param notificationType notificationType
     */
    createNotificationType(params: {  notificationType?: NotificationTypeResource; }, options: any = {}) {
        return NotificationsApiFp.createNotificationType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Delete a notification type
     * @param id id
     */
    deleteNotificationType(params: {  id: string; }, options: any = {}) {
        return NotificationsApiFp.deleteNotificationType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Get a single notification type
     * @param id id
     */
    getNotificationType(params: {  id: string; }, options: any = {}) {
        return NotificationsApiFp.getNotificationType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of notification type with optional filtering. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary List and search notification types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getNotificationTypes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return NotificationsApiFp.getNotificationTypes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings for a type
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     */
    getUserNotificationInfo(params: {  typeId: string; userId: string; }, options: any = {}) {
        return NotificationsApiFp.getUserNotificationInfo(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary View a user's notification settings
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotificationInfoList(params: {  userId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return NotificationsApiFp.getUserNotificationInfoList(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Get notifications
     * @param id The id of the user or &#39;me&#39;
     * @param filterStatus filter for notifications with a given status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserNotifications(params: {  id: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return NotificationsApiFp.getUserNotifications(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Send a notification
     * @param notification notification
     */
    sendNotification(params: {  notification?: NotificationResource; }, options: any = {}) {
        return NotificationsApiFp.sendNotification(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Set notification status
     * @param userId The id of the user or &#39;me&#39;
     * @param notificationId The id of the notification
     * @param notification status
     */
    setUserNotificationStatus(params: {  userId: string; notificationId: string; notification?: UserNotificationStatusWrapper; }, options: any = {}) {
        return NotificationsApiFp.setUserNotificationStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Allows enabling or disabling messages for a given notification type when sent direct to the user. Notifications can still be retrieved by endpoint. For notifications broadcased to a topic, see the topic service to disable messages for the user there. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
     * @summary Enable or disable direct notifications for a user
     * @param typeId The id of the topic
     * @param userId The id of the subscriber or &#39;me&#39;
     * @param silenced silenced
     */
    silenceDirectNotifications(params: {  typeId: string; userId: string; silenced: ValueWrapperboolean; }, options: any = {}) {
        return NotificationsApiFp.silenceDirectNotifications(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
     * @summary Update a notificationType
     * @param id id
     * @param notificationType notificationType
     */
    updateNotificationType(params: {  id: string; notificationType?: NotificationTypeResource; }, options: any = {}) {
        return NotificationsApiFp.updateNotificationType(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * NotificationsApi - factory interface
 */
export const NotificationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary Create a notification type
         * @param notificationType notificationType
         */
        createNotificationType(params: {  notificationType?: NotificationTypeResource; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.createNotificationType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary Delete a notification type
         * @param id id
         */
        deleteNotificationType(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.deleteNotificationType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary Get a single notification type
         * @param id id
         */
        getNotificationType(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.getNotificationType(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of notification type with optional filtering. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary List and search notification types
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getNotificationTypes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.getNotificationTypes(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
         * @summary View a user's notification settings for a type
         * @param typeId The id of the topic
         * @param userId The id of the subscriber or &#39;me&#39;
         */
        getUserNotificationInfo(params: {  typeId: string; userId: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.getUserNotificationInfo(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
         * @summary View a user's notification settings
         * @param userId The id of the subscriber or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserNotificationInfoList(params: {  userId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.getUserNotificationInfoList(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
         * @summary Get notifications
         * @param id The id of the user or &#39;me&#39;
         * @param filterStatus filter for notifications with a given status
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserNotifications(params: {  id: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.getUserNotifications(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary Send a notification
         * @param notification notification
         */
        sendNotification(params: {  notification?: NotificationResource; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.sendNotification(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
         * @summary Set notification status
         * @param userId The id of the user or &#39;me&#39;
         * @param notificationId The id of the notification
         * @param notification status
         */
        setUserNotificationStatus(params: {  userId: string; notificationId: string; notification?: UserNotificationStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.setUserNotificationStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * Allows enabling or disabling messages for a given notification type when sent direct to the user. Notifications can still be retrieved by endpoint. For notifications broadcased to a topic, see the topic service to disable messages for the user there. <br><br><b>Permissions Needed:</b> NOTIFICATIONS_ADMIN or self
         * @summary Enable or disable direct notifications for a user
         * @param typeId The id of the topic
         * @param userId The id of the subscriber or &#39;me&#39;
         * @param silenced silenced
         */
        silenceDirectNotifications(params: {  typeId: string; userId: string; silenced: ValueWrapperboolean; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.silenceDirectNotifications(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> NOTIFICATIONS_ADMIN
         * @summary Update a notificationType
         * @param id id
         * @param notificationType notificationType
         */
        updateNotificationType(params: {  id: string; notificationType?: NotificationTypeResource; }, configuration: Configuration, options: any = {}) {
            return NotificationsApiFp.updateNotificationType(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * ObjectsApi - fetch parameter creator
 */
export const ObjectsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an object
     * @param templateId The id of the template this object is to be part of
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    createObjectItem(params: {  templateId: string; cascade?: boolean; objectItem?: ObjectResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "templateId" is set
        if (params["templateId"] == null) {
            throw new Error("Missing required parameter templateId when calling createObjectItem");
        }
        const baseUrl = `/objects/{template_id}`
            .replace(`{${"template_id"}}`, `${ params["templateId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["objectItem"]) {
            fetchOptions.body = JSON.stringify(params["objectItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Object templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an object template
     * @param template The entitlement template to be created
     */
    createObjectTemplate(params: {  template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/objects/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    deleteObjectItem(params: {  templateId: string; objectId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "templateId" is set
        if (params["templateId"] == null) {
            throw new Error("Missing required parameter templateId when calling deleteObjectItem");
        }
        // verify required parameter "objectId" is set
        if (params["objectId"] == null) {
            throw new Error("Missing required parameter objectId when calling deleteObjectItem");
        }
        const baseUrl = `/objects/{template_id}/{object_id}`
            .replace(`{${"template_id"}}`, `${ params["templateId"] }`)
            .replace(`{${"object_id"}}`, `${ params["objectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteObjectTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteObjectTemplate");
        }
        const baseUrl = `/objects/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    getObjectItem(params: {  templateId: string; objectId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "templateId" is set
        if (params["templateId"] == null) {
            throw new Error("Missing required parameter templateId when calling getObjectItem");
        }
        // verify required parameter "objectId" is set
        if (params["objectId"] == null) {
            throw new Error("Missing required parameter objectId when calling getObjectItem");
        }
        const baseUrl = `/objects/{template_id}/{object_id}`
            .replace(`{${"template_id"}}`, `${ params["templateId"] }`)
            .replace(`{${"object_id"}}`, `${ params["objectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search objects
     * @param templateId The id of the template to get objects for
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectItems(params: {  templateId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "templateId" is set
        if (params["templateId"] == null) {
            throw new Error("Missing required parameter templateId when calling getObjectItems");
        }
        const baseUrl = `/objects/{template_id}`
            .replace(`{${"template_id"}}`, `${ params["templateId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getObjectTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getObjectTemplate");
        }
        const baseUrl = `/objects/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/objects/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    updateObjectItem(params: {  templateId: string; objectId: number; cascade?: boolean; objectItem?: ObjectResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "templateId" is set
        if (params["templateId"] == null) {
            throw new Error("Missing required parameter templateId when calling updateObjectItem");
        }
        // verify required parameter "objectId" is set
        if (params["objectId"] == null) {
            throw new Error("Missing required parameter objectId when calling updateObjectItem");
        }
        const baseUrl = `/objects/{template_id}/{object_id}`
            .replace(`{${"template_id"}}`, `${ params["templateId"] }`)
            .replace(`{${"object_id"}}`, `${ params["objectId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["objectItem"]) {
            fetchOptions.body = JSON.stringify(params["objectItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateObjectTemplate(params: {  id: string; template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateObjectTemplate");
        }
        const baseUrl = `/objects/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ObjectsApi - functional programming interface
 */
export const ObjectsApiFp = {
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an object
     * @param templateId The id of the template this object is to be part of
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    createObjectItem(params: { templateId: string; cascade?: boolean; objectItem?: ObjectResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ObjectResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.createObjectItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Object templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an object template
     * @param template The entitlement template to be created
     */
    createObjectTemplate(params: { template?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.createObjectTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    deleteObjectItem(params: { templateId: string; objectId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ObjectsApiFetchParamCreator.deleteObjectItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteObjectTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ObjectsApiFetchParamCreator.deleteObjectTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    getObjectItem(params: { templateId: string; objectId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ObjectResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.getObjectItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search objects
     * @param templateId The id of the template to get objects for
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectItems(params: { templateId: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceObjectResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.getObjectItems(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getObjectTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.getObjectTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.getObjectTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    updateObjectItem(params: { templateId: string; objectId: number; cascade?: boolean; objectItem?: ObjectResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ObjectsApiFetchParamCreator.updateObjectItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateObjectTemplate(params: { id: string; template?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = ObjectsApiFetchParamCreator.updateObjectTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ObjectsApi - object-oriented interface
 */
export class ObjectsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an object
     * @param templateId The id of the template this object is to be part of
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    createObjectItem(params: {  templateId: string; cascade?: boolean; objectItem?: ObjectResource; }, options: any = {}) {
        return ObjectsApiFp.createObjectItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Object templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an object template
     * @param template The entitlement template to be created
     */
    createObjectTemplate(params: {  template?: ItemTemplateResource; }, options: any = {}) {
        return ObjectsApiFp.createObjectTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    deleteObjectItem(params: {  templateId: string; objectId: number; }, options: any = {}) {
        return ObjectsApiFp.deleteObjectItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteObjectTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return ObjectsApiFp.deleteObjectTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     */
    getObjectItem(params: {  templateId: string; objectId: number; }, options: any = {}) {
        return ObjectsApiFp.getObjectItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search objects
     * @param templateId The id of the template to get objects for
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectItems(params: {  templateId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ObjectsApiFp.getObjectItems(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getObjectTemplate(params: {  id: string; }, options: any = {}) {
        return ObjectsApiFp.getObjectTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getObjectTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ObjectsApiFp.getObjectTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an object
     * @param templateId The id of the template this object is part of
     * @param objectId The id of the object
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param objectItem The object item object
     */
    updateObjectItem(params: {  templateId: string; objectId: number; cascade?: boolean; objectItem?: ObjectResource; }, options: any = {}) {
        return ObjectsApiFp.updateObjectItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateObjectTemplate(params: {  id: string; template?: ItemTemplateResource; }, options: any = {}) {
        return ObjectsApiFp.updateObjectTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * ObjectsApi - factory interface
 */
export const ObjectsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Create an object
         * @param templateId The id of the template this object is to be part of
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param objectItem The object item object
         */
        createObjectItem(params: {  templateId: string; cascade?: boolean; objectItem?: ObjectResource; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.createObjectItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Object templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an object template
         * @param template The entitlement template to be created
         */
        createObjectTemplate(params: {  template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.createObjectTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Delete an object
         * @param templateId The id of the template this object is part of
         * @param objectId The id of the object
         */
        deleteObjectItem(params: {  templateId: string; objectId: number; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.deleteObjectItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an entitlement template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteObjectTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.deleteObjectTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single object
         * @param templateId The id of the template this object is part of
         * @param objectId The id of the object
         */
        getObjectItem(params: {  templateId: string; objectId: number; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.getObjectItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search objects
         * @param templateId The id of the template to get objects for
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getObjectItems(params: {  templateId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.getObjectItems(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary Get a single entitlement template
         * @param id The id of the template
         */
        getObjectTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.getObjectTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary List and search entitlement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getObjectTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.getObjectTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Update an object
         * @param templateId The id of the template this object is part of
         * @param objectId The id of the object
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param objectItem The object item object
         */
        updateObjectItem(params: {  templateId: string; objectId: number; cascade?: boolean; objectItem?: ObjectResource; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.updateObjectItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an entitlement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateObjectTemplate(params: {  id: string; template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return ObjectsApiFp.updateObjectTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsApi - fetch parameter creator
 */
export const PaymentsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  userId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deletePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  userId: number; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single payment method type
     * @param id ID of the payment method type being retrieved
     */
    getPaymentMethodType(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPaymentMethodType");
        }
        const baseUrl = `/payment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get all payment method types
     * @param filterName Filter for payment method types whose name matches a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethodTypes(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/types`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethods");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterPaymentType"] !== undefined) {
            urlObj.query["filter_payment_type"] = params["filterPaymentType"];
        }
        if (params["filterPaymentMethodTypeId"] !== undefined) {
            urlObj.query["filter_payment_method_type_id"] = params["filterPaymentMethodTypeId"];
        }
        if (params["filterPaymentMethodTypeName"] !== undefined) {
            urlObj.query["filter_payment_method_type_name"] = params["filterPaymentMethodTypeName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or PAYMENTS_USER
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/authorizations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling paymentCapture");
        }
        const baseUrl = `/payment/authorizations/{id}/capture`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updatePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = {
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: { userId: number; paymentMethod?: PaymentMethodResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.createPaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: { userId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.deletePaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: { userId: number; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single payment method type
     * @param id ID of the payment method type being retrieved
     */
    getPaymentMethodType(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodTypeResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethodType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get all payment method types
     * @param filterName Filter for payment method types whose name matches a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethodTypes(params: { filterName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcePaymentMethodTypeResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethodTypes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: { userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<PaymentMethodResource>> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethods(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or PAYMENTS_USER
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: { request?: PaymentAuthorizationResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentAuthorizationResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentAuthorization(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentCapture(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: { userId: number; id: number; paymentMethod?: PaymentMethodResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.updatePaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
        return PaymentsApiFp.createPaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
        return PaymentsApiFp.deletePaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single payment method type
     * @param id ID of the payment method type being retrieved
     */
    getPaymentMethodType(params: {  id: number; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethodType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get all payment method types
     * @param filterName Filter for payment method types whose name matches a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethodTypes(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethodTypes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethods(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or PAYMENTS_USER
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, options: any = {}) {
        return PaymentsApiFp.paymentAuthorization(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  id: number; }, options: any = {}) {
        return PaymentsApiFp.paymentCapture(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
        return PaymentsApiFp.updatePaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
         * @summary Create a new payment method for a user
         * @param userId ID of the user for whom the payment method is being created
         * @param paymentMethod Payment method being created
         */
        createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.createPaymentMethod(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
         * @summary Delete an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being deleted
         */
        deletePaymentMethod(params: {  userId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.deletePaymentMethod(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
         * @summary Get a single payment method for a user
         * @param userId ID of the user for whom the payment method is being retrieved
         * @param id ID of the payment method being retrieved
         */
        getPaymentMethod(params: {  userId: number; id: number; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.getPaymentMethod(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single payment method type
         * @param id ID of the payment method type being retrieved
         */
        getPaymentMethodType(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.getPaymentMethodType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get all payment method types
         * @param filterName Filter for payment method types whose name matches a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPaymentMethodTypes(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.getPaymentMethodTypes(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
         * @summary Get all payment methods for a user
         * @param userId ID of the user for whom the payment methods are being retrieved
         * @param filterName Filter for payment methods whose name starts with a given string
         * @param filterPaymentType Filter for payment methods with a specific payment type
         * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
         * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.getPaymentMethods(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or PAYMENTS_USER
         * @summary Authorize payment of an invoice for later capture
         * @param request Payment authorization request
         */
        paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.paymentAuthorization(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN
         * @summary Capture an existing invoice payment authorization
         * @param id ID of the payment authorization to capture
         */
        paymentCapture(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.paymentCapture(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> PAYMENTS_ADMIN or owner
         * @summary Update an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being updated
         * @param paymentMethod The updated payment method data
         */
        updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, configuration: Configuration, options: any = {}) {
            return PaymentsApiFp.updatePaymentMethod(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_AppleApi - fetch parameter creator
 */
export const Payments_AppleApiFetchParamCreator = {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/apple/receipt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_AppleApi - functional programming interface
 */
export const Payments_AppleApiFp = {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: { request?: ApplyPaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Payments_AppleApiFetchParamCreator.verifyAppleReceipt(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_AppleApi - object-oriented interface
 */
export class Payments_AppleApi extends BaseAPI {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, options: any = {}) {
        return Payments_AppleApiFp.verifyAppleReceipt(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_AppleApi - factory interface
 */
export const Payments_AppleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful. <br><br><b>Permissions Needed:</b> ANY
         * @summary Pay invoice with Apple receipt
         * @param request The request for paying an invoice through an Apple receipt
         */
        verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_AppleApiFp.verifyAppleReceipt(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_FattMerchantApi - fetch parameter creator
 */
export const Payments_FattMerchantApiFetchParamCreator = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. <br><br><b>Permissions Needed:</b> FATTMERCHANT_ADMIN or owner
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/fattmerchant/payment-methods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_FattMerchantApi - functional programming interface
 */
export const Payments_FattMerchantApiFp = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. <br><br><b>Permissions Needed:</b> FATTMERCHANT_ADMIN or owner
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: { request?: FattMerchantPaymentMethodRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = Payments_FattMerchantApiFetchParamCreator.createOrUpdateFattMerchantPaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_FattMerchantApi - object-oriented interface
 */
export class Payments_FattMerchantApi extends BaseAPI {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. <br><br><b>Permissions Needed:</b> FATTMERCHANT_ADMIN or owner
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, options: any = {}) {
        return Payments_FattMerchantApiFp.createOrUpdateFattMerchantPaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_FattMerchantApi - factory interface
 */
export const Payments_FattMerchantApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. <br><br><b>Permissions Needed:</b> FATTMERCHANT_ADMIN or owner
         * @summary Create or update a FattMerchant payment method for a user
         * @param request Request containing payment method information for user
         */
        createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_FattMerchantApiFp.createOrUpdateFattMerchantPaymentMethod(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_OptimalApi - fetch parameter creator
 */
export const Payments_OptimalApiFetchParamCreator = {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details. <br><br><b>Permissions Needed:</b> OPTIMAL_ADMIN or owner
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/optimal/silent`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_OptimalApi - functional programming interface
 */
export const Payments_OptimalApiFp = {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details. <br><br><b>Permissions Needed:</b> OPTIMAL_ADMIN or owner
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: { request?: OptimalPaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Payments_OptimalApiFetchParamCreator.silentPostOptimal(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_OptimalApi - object-oriented interface
 */
export class Payments_OptimalApi extends BaseAPI {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details. <br><br><b>Permissions Needed:</b> OPTIMAL_ADMIN or owner
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, options: any = {}) {
        return Payments_OptimalApiFp.silentPostOptimal(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_OptimalApi - factory interface
 */
export const Payments_OptimalApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details. <br><br><b>Permissions Needed:</b> OPTIMAL_ADMIN or owner
         * @summary Initiate silent post with Optimal
         * @param request The payment request to initiate
         */
        silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_OptimalApiFp.silentPostOptimal(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_PayPalClassicApi - fetch parameter creator
 */
export const Payments_PayPalClassicApiFetchParamCreator = {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_PayPalClassicApi - functional programming interface
 */
export const Payments_PayPalClassicApiFp = {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: { request?: CreateBillingAgreementRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Payments_PayPalClassicApiFetchParamCreator.createPayPalBillingAgreementUrl(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: { request?: CreatePayPalPaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Payments_PayPalClassicApiFetchParamCreator.createPayPalExpressCheckout(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: { request?: FinalizeBillingAgreementRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = Payments_PayPalClassicApiFetchParamCreator.finalizePayPalBillingAgreement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: { request?: FinalizePayPalPaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Payments_PayPalClassicApiFetchParamCreator.finalizePayPalCheckout(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_PayPalClassicApi - object-oriented interface
 */
export class Payments_PayPalClassicApi extends BaseAPI {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, options: any = {}) {
        return Payments_PayPalClassicApiFp.createPayPalBillingAgreementUrl(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, options: any = {}) {
        return Payments_PayPalClassicApiFp.createPayPalExpressCheckout(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, options: any = {}) {
        return Payments_PayPalClassicApiFp.finalizePayPalBillingAgreement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, options: any = {}) {
        return Payments_PayPalClassicApiFp.finalizePayPalCheckout(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_PayPalClassicApi - factory interface
 */
export const Payments_PayPalClassicApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the token that should be used to forward the user to PayPal so they can accept the agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
         * @summary Create a PayPal Classic billing agreement for the user
         * @param request The request to create a PayPal billing agreement
         */
        createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_PayPalClassicApiFp.createPayPalBillingAgreementUrl(params, configuration, options)(fetch, basePath);
        },
        /**
         * Returns the token that should be used to forward the user to PayPal so they can complete the checkout. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
         * @summary Create a payment token for PayPal express checkout
         * @param request The request to create a PayPal payment token
         */
        createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_PayPalClassicApiFp.createPayPalExpressCheckout(params, configuration, options)(fetch, basePath);
        },
        /**
         * Returns the ID of the new payment method created for the user for the billing agreement. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
         * @summary Finalizes a billing agreement after the user has accepted through PayPal
         * @param request The request to finalize a PayPal billing agreement
         */
        finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_PayPalClassicApiFp.finalizePayPalBillingAgreement(params, configuration, options)(fetch, basePath);
        },
        /**
         * The invoice will be marked paid/failed by asynchronous IPN callback. <br><br><b>Permissions Needed:</b> PAYPAL_CLASSIC_ADMIN or owner
         * @summary Finalizes a payment after the user has completed checkout with PayPal
         * @param request The request to finalize the payment
         */
        finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_PayPalClassicApiFp.finalizePayPalCheckout(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_StripeApi - fetch parameter creator
 */
export const Payments_StripeApiFetchParamCreator = {
    /**
     * Obtain a token from Stripe, following their examples and documentation. Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> STRIPE_ADMIN or owner
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payment-methods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Obtain a token from Stripe, following their examples and documentation. Pays an invoice without creating a payment method. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  request?: StripePaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_StripeApi - functional programming interface
 */
export const Payments_StripeApiFp = {
    /**
     * Obtain a token from Stripe, following their examples and documentation. Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> STRIPE_ADMIN or owner
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: { request?: StripeCreatePaymentMethod;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = Payments_StripeApiFetchParamCreator.createStripePaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Obtain a token from Stripe, following their examples and documentation. Pays an invoice without creating a payment method. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: { request?: StripePaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Payments_StripeApiFetchParamCreator.payStripeInvoice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_StripeApi - object-oriented interface
 */
export class Payments_StripeApi extends BaseAPI {
    /**
     * Obtain a token from Stripe, following their examples and documentation. Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> STRIPE_ADMIN or owner
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, options: any = {}) {
        return Payments_StripeApiFp.createStripePaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Obtain a token from Stripe, following their examples and documentation. Pays an invoice without creating a payment method. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> ANY
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  request?: StripePaymentRequest; }, options: any = {}) {
        return Payments_StripeApiFp.payStripeInvoice(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_StripeApi - factory interface
 */
export const Payments_StripeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Obtain a token from Stripe, following their examples and documentation. Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> STRIPE_ADMIN or owner
         * @summary Create a Stripe payment method for a user
         * @param request The request to create a Stripe customer with payment info
         */
        createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, configuration: Configuration, options: any = {}) {
            return Payments_StripeApiFp.createStripePaymentMethod(params, configuration, options)(fetch, basePath);
        },
        /**
         * Obtain a token from Stripe, following their examples and documentation. Pays an invoice without creating a payment method. Ensure that Stripe itself has been configured with the webhook so that invoices are marked paid. <br><br><b>Permissions Needed:</b> ANY
         * @summary Pay with a single use token
         * @param request The request to pay an invoice
         */
        payStripeInvoice(params: {  request?: StripePaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_StripeApiFp.payStripeInvoice(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_TransactionsApi - fetch parameter creator
 */
export const Payments_TransactionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTransaction");
        }
        const baseUrl = `/transactions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterInvoice"] !== undefined) {
            urlObj.query["filter_invoice"] = params["filterInvoice"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds. <br><br><b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  id: number; request?: RefundRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling refundTransaction");
        }
        const baseUrl = `/transactions/{id}/refunds`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_TransactionsApi - functional programming interface
 */
export const Payments_TransactionsApiFp = {
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TransactionResource> {
        const fetchArgs = Payments_TransactionsApiFetchParamCreator.getTransaction(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: { filterInvoice?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTransactionResource> {
        const fetchArgs = Payments_TransactionsApiFetchParamCreator.getTransactions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds. <br><br><b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: { id: number; request?: RefundRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RefundResource> {
        const fetchArgs = Payments_TransactionsApiFetchParamCreator.refundTransaction(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_TransactionsApi - object-oriented interface
 */
export class Payments_TransactionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  id: number; }, options: any = {}) {
        return Payments_TransactionsApiFp.getTransaction(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Payments_TransactionsApiFp.getTransactions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds. <br><br><b>Permissions Needed:</b> PAYMENTS_ADMIN
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  id: number; request?: RefundRequest; }, options: any = {}) {
        return Payments_TransactionsApiFp.refundTransaction(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_TransactionsApi - factory interface
 */
export const Payments_TransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
         * @summary Get the details for a single transaction
         * @param id id
         */
        getTransaction(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Payments_TransactionsApiFp.getTransaction(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TRANSACTIONS_ADMIN or owner
         * @summary List and search transactions
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Payments_TransactionsApiFp.getTransactions(params, configuration, options)(fetch, basePath);
        },
        /**
         * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds. <br><br><b>Permissions Needed:</b> PAYMENTS_ADMIN
         * @summary Refund a payment transaction, in full or in part
         * @param id The id of the transaction to refund
         * @param request Request containing refund details
         */
        refundTransaction(params: {  id: number; request?: RefundRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_TransactionsApiFp.refundTransaction(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_WalletsApi - fetch parameter creator
 */
export const Payments_WalletsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  userId: number; currencyCode: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallet");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWallet");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWalletTransactions");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWalletTransactions");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/transactions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterMaxDate"] !== undefined) {
            urlObj.query["filter_max_date"] = params["filterMaxDate"];
        }
        if (params["filterMinDate"] !== undefined) {
            urlObj.query["filter_min_date"] = params["filterMinDate"];
        }
        if (params["filterSign"] !== undefined) {
            urlObj.query["filter_sign"] = params["filterSign"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallets");
        }
        const baseUrl = `/users/{user_id}/wallets`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/wallets/totals`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/wallets/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterInvoice"] !== undefined) {
            urlObj.query["filter_invoice"] = params["filterInvoice"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        if (params["filterSign"] !== undefined) {
            urlObj.query["filter_sign"] = params["filterSign"];
        }
        if (params["filterUserId"] !== undefined) {
            urlObj.query["filter_user_id"] = params["filterUserId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterDetails"] !== undefined) {
            urlObj.query["filter_details"] = params["filterDetails"];
        }
        if (params["filterCurrencyCode"] !== undefined) {
            urlObj.query["filter_currency_code"] = params["filterCurrencyCode"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/wallets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateWalletBalance");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling updateWalletBalance");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/balance`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_WalletsApi - functional programming interface
 */
export const Payments_WalletsApiFp = {
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: { userId: number; currencyCode: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SimpleWallet> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getUserWallet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: { userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getUserWalletTransactions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: { userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<SimpleWallet>> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getUserWallets(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTotalResponse> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getWalletBalances(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: { filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getWalletTransactions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleWallet> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.getWallets(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: { userId: number; currencyCode: string; request?: WalletAlterRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<WalletTransactionResource> {
        const fetchArgs = Payments_WalletsApiFetchParamCreator.updateWalletBalance(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_WalletsApi - object-oriented interface
 */
export class Payments_WalletsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  userId: number; currencyCode: string; }, options: any = {}) {
        return Payments_WalletsApiFp.getUserWallet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Payments_WalletsApiFp.getUserWalletTransactions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  userId: number; }, options: any = {}) {
        return Payments_WalletsApiFp.getUserWallets(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options: any = {}) {
        return Payments_WalletsApiFp.getWalletBalances(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Payments_WalletsApiFp.getWalletTransactions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Payments_WalletsApiFp.getWallets(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> WALLETS_ADMIN
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, options: any = {}) {
        return Payments_WalletsApiFp.updateWalletBalance(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_WalletsApi - factory interface
 */
export const Payments_WalletsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
         * @summary Returns the user's wallet for the given currency code
         * @param userId The ID of the user for whom wallet is being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         */
        getUserWallet(params: {  userId: number; currencyCode: string; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getUserWallet(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
         * @summary Retrieve a user's wallet transactions
         * @param userId The ID of the user for whom wallet transactions are being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param filterType Filter for transactions with specified type
         * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
         * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
         * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getUserWalletTransactions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN or owner
         * @summary List all of a user's wallets
         * @param userId The ID of the user for whom wallets are being retrieved
         */
        getUserWallets(params: {  userId: number; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getUserWallets(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN
         * @summary Retrieves a summation of wallet balances by currency code
         */
        getWalletBalances(configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getWalletBalances(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN
         * @summary Retrieve wallet transactions across the system
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param filterType Filter for transactions with specified type
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterSign Filter for transactions with amount with the given sign
         * @param filterUserId Filter for transactions for specific userId
         * @param filterUsername Filter for transactions for specific username that start with the given string
         * @param filterDetails Filter for transactions for specific details that start with the given string
         * @param filterCurrencyCode Filter for transactions for specific currency code
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getWalletTransactions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN
         * @summary Retrieve a list of wallets across the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWallets(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.getWallets(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> WALLETS_ADMIN
         * @summary Updates the balance for a user's wallet
         * @param userId The ID of the user for whom wallet is being modified
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param request The requested balance modification to be made to the user&#39;s wallet
         */
        updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_WalletsApiFp.updateWalletBalance(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Payments_XsollaApi - fetch parameter creator
 */
export const Payments_XsollaApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> XSOLLA_ADMIN or owner
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/xsolla/payment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Payments_XsollaApi - functional programming interface
 */
export const Payments_XsollaApiFp = {
    /**
     * <b>Permissions Needed:</b> XSOLLA_ADMIN or owner
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: { request?: XsollaPaymentRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Payments_XsollaApiFetchParamCreator.createXsollaTokenUrl(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Payments_XsollaApi - object-oriented interface
 */
export class Payments_XsollaApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> XSOLLA_ADMIN or owner
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, options: any = {}) {
        return Payments_XsollaApiFp.createXsollaTokenUrl(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Payments_XsollaApi - factory interface
 */
export const Payments_XsollaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> XSOLLA_ADMIN or owner
         * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
         * @param request The payment request to be sent to XSolla
         */
        createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, configuration: Configuration, options: any = {}) {
            return Payments_XsollaApiFp.createXsollaTokenUrl(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_ChallengesApi - fetch parameter creator
 */
export const Reporting_ChallengesApiFetchParamCreator = {
    /**
     * Lists all leaderboard entries with additional user details. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/events/leaderboard`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterEvent"] !== undefined) {
            urlObj.query["filter_event"] = params["filterEvent"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/events/participants`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterEvent"] !== undefined) {
            urlObj.query["filter_event"] = params["filterEvent"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_ChallengesApi - functional programming interface
 */
export const Reporting_ChallengesApiFp = {
    /**
     * Lists all leaderboard entries with additional user details. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: { filterEvent?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = Reporting_ChallengesApiFetchParamCreator.getChallengeEventLeaderboard(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: { filterEvent?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = Reporting_ChallengesApiFetchParamCreator.getChallengeEventParticipants(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_ChallengesApi - object-oriented interface
 */
export class Reporting_ChallengesApi extends BaseAPI {
    /**
     * Lists all leaderboard entries with additional user details. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Reporting_ChallengesApiFp.getChallengeEventLeaderboard(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Reporting_ChallengesApiFp.getChallengeEventParticipants(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_ChallengesApi - factory interface
 */
export const Reporting_ChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists all leaderboard entries with additional user details. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
         * @summary Retrieve a challenge event leaderboard details
         * @param filterEvent A sepecific challenge event id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Reporting_ChallengesApiFp.getChallengeEventLeaderboard(params, configuration, options)(fetch, basePath);
        },
        /**
         * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation. <br><br><b>Permissions Needed:</b> REPORTING_CHALLENGES_ADMIN
         * @summary Retrieve a challenge event participant details
         * @param filterEvent A sepecific challenge event id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Reporting_ChallengesApiFp.getChallengeEventParticipants(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_OrdersApi - fetch parameter creator
 */
export const Reporting_OrdersApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> REPORTING_ORDERS_ADMIN
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getInvoiceReports");
        }
        const baseUrl = `/reporting/orders/count/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["granularity"] !== undefined) {
            urlObj.query["granularity"] = params["granularity"];
        }
        if (params["filterPaymentStatus"] !== undefined) {
            urlObj.query["filter_payment_status"] = params["filterPaymentStatus"];
        }
        if (params["filterFulfillmentStatus"] !== undefined) {
            urlObj.query["filter_fulfillment_status"] = params["filterFulfillmentStatus"];
        }
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_OrdersApi - functional programming interface
 */
export const Reporting_OrdersApiFp = {
    /**
     * <b>Permissions Needed:</b> REPORTING_ORDERS_ADMIN
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: { currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAggregateInvoiceReportResource> {
        const fetchArgs = Reporting_OrdersApiFetchParamCreator.getInvoiceReports(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_OrdersApi - object-oriented interface
 */
export class Reporting_OrdersApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> REPORTING_ORDERS_ADMIN
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return Reporting_OrdersApiFp.getInvoiceReports(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_OrdersApi - factory interface
 */
export const Reporting_OrdersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> REPORTING_ORDERS_ADMIN
         * @summary Retrieve invoice counts aggregated by time ranges
         * @param currencyCode The code for a currency to get sales data for
         * @param granularity The time duration to aggregate by
         * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
         * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
         * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         */
        getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_OrdersApiFp.getInvoiceReports(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_RevenueApi - fetch parameter creator
 */
export const Reporting_RevenueApiFetchParamCreator = {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getItemRevenue");
        }
        const baseUrl = `/reporting/revenue/item-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRefundRevenue");
        }
        const baseUrl = `/reporting/revenue/refunds/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByCountry");
        }
        const baseUrl = `/reporting/revenue/countries/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByItem");
        }
        const baseUrl = `/reporting/revenue/products/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getSubscriptionRevenue");
        }
        const baseUrl = `/reporting/revenue/subscription-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_RevenueApi - functional programming interface
 */
export const Reporting_RevenueApiFp = {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = Reporting_RevenueApiFetchParamCreator.getItemRevenue(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = Reporting_RevenueApiFetchParamCreator.getRefundRevenue(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: { currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRevenueCountryReportResource> {
        const fetchArgs = Reporting_RevenueApiFetchParamCreator.getRevenueByCountry(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: { currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRevenueProductReportResource> {
        const fetchArgs = Reporting_RevenueApiFetchParamCreator.getRevenueByItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = Reporting_RevenueApiFetchParamCreator.getSubscriptionRevenue(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_RevenueApi - object-oriented interface
 */
export class Reporting_RevenueApi extends BaseAPI {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return Reporting_RevenueApiFp.getItemRevenue(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return Reporting_RevenueApiFp.getRefundRevenue(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return Reporting_RevenueApiFp.getRevenueByCountry(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return Reporting_RevenueApiFp.getRevenueByItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return Reporting_RevenueApiFp.getSubscriptionRevenue(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_RevenueApi - factory interface
 */
export const Reporting_RevenueApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
         * @summary Get item revenue info
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_RevenueApiFp.getItemRevenue(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue loss from refunds (for all item types), summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
         * @summary Get refund revenue info
         * @param currencyCode The code for a currency to get refund data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_RevenueApiFp.getRefundRevenue(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
         * @summary Get revenue info by country
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_RevenueApiFp.getRevenueByCountry(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
         * @summary Get revenue info by item
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_RevenueApiFp.getRevenueByItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range. <br><br><b>Permissions Needed:</b> REPORTING_REVENUE_ADMIN
         * @summary Get subscription revenue info
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_RevenueApiFp.getSubscriptionRevenue(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_SubscriptionsApi - fetch parameter creator
 */
export const Reporting_SubscriptionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/subscription`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_SubscriptionsApi - functional programming interface
 */
export const Reporting_SubscriptionsApiFp = {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: { size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBillingReport> {
        const fetchArgs = Reporting_SubscriptionsApiFetchParamCreator.getSubscriptionReports(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_SubscriptionsApi - object-oriented interface
 */
export class Reporting_SubscriptionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  size?: number; page?: number; }, options: any = {}) {
        return Reporting_SubscriptionsApiFp.getSubscriptionReports(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_SubscriptionsApi - factory interface
 */
export const Reporting_SubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
         * @summary Get a list of available subscription reports in most recent first order
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getSubscriptionReports(params: {  size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_SubscriptionsApiFp.getSubscriptionReports(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_UsageApi - fetch parameter creator
 */
export const Reporting_UsageApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByDay");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByDay");
        }
        const baseUrl = `/reporting/usage/day`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByHour");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByHour");
        }
        const baseUrl = `/reporting/usage/hour`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMinute");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMinute");
        }
        const baseUrl = `/reporting/usage/minute`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMonth");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMonth");
        }
        const baseUrl = `/reporting/usage/month`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByYear");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByYear");
        }
        const baseUrl = `/reporting/usage/year`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: {  startDate: number; endDate: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageEndpoints");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageEndpoints");
        }
        const baseUrl = `/reporting/usage/endpoints`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_UsageApi - functional programming interface
 */
export const Reporting_UsageApiFp = {
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageByDay(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageByHour(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageByMinute(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageByMonth(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageByYear(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: { startDate: number; endDate: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = Reporting_UsageApiFetchParamCreator.getUsageEndpoints(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_UsageApi - object-oriented interface
 */
export class Reporting_UsageApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageByDay(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageByHour(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageByMinute(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageByMonth(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageByYear(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USAGE_ADMIN
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: {  startDate: number; endDate: number; }, options: any = {}) {
        return Reporting_UsageApiFp.getUsageEndpoints(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_UsageApi - factory interface
 */
export const Reporting_UsageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns aggregated endpoint usage information by day
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageByDay(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns aggregated endpoint usage information by hour
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageByHour(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns aggregated endpoint usage information by minute
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageByMinute(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns aggregated endpoint usage information by month
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageByMonth(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns aggregated endpoint usage information by year
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageByYear(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USAGE_ADMIN
         * @summary Returns list of endpoints called (method and url)
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         */
        getUsageEndpoints(params: {  startDate: number; endDate: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsageApiFp.getUsageEndpoints(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Reporting_UsersApi - fetch parameter creator
 */
export const Reporting_UsersApiFetchParamCreator = {
    /**
     * Get user registration counts grouped by time range. <br><br><b>Permissions Needed:</b> REPORTING_USER_ADMIN
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/users/registrations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["granularity"] !== undefined) {
            urlObj.query["granularity"] = params["granularity"];
        }
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Reporting_UsersApi - functional programming interface
 */
export const Reporting_UsersApiFp = {
    /**
     * Get user registration counts grouped by time range. <br><br><b>Permissions Needed:</b> REPORTING_USER_ADMIN
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: { granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAggregateCountResource> {
        const fetchArgs = Reporting_UsersApiFetchParamCreator.getUserRegistrations(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Reporting_UsersApi - object-oriented interface
 */
export class Reporting_UsersApi extends BaseAPI {
    /**
     * Get user registration counts grouped by time range. <br><br><b>Permissions Needed:</b> REPORTING_USER_ADMIN
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return Reporting_UsersApiFp.getUserRegistrations(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Reporting_UsersApi - factory interface
 */
export const Reporting_UsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get user registration counts grouped by time range. <br><br><b>Permissions Needed:</b> REPORTING_USER_ADMIN
         * @summary Get user registration info
         * @param granularity The time duration to aggregate by
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Reporting_UsersApiFp.getUserRegistrations(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_ActionsApi - fetch parameter creator
 */
export const Rule_Engine_ActionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_ACTIONS_USER
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/actions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterTags"] !== undefined) {
            urlObj.query["filter_tags"] = params["filterTags"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_ActionsApi - functional programming interface
 */
export const Rule_Engine_ActionsApiFp = {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_ACTIONS_USER
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: { filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<ActionResource>> {
        const fetchArgs = Rule_Engine_ActionsApiFetchParamCreator.getBREActions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_ActionsApi - object-oriented interface
 */
export class Rule_Engine_ActionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_ACTIONS_USER
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, options: any = {}) {
        return Rule_Engine_ActionsApiFp.getBREActions(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_ActionsApi - factory interface
 */
export const Rule_Engine_ActionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_ACTIONS_USER
         * @summary Get a list of available actions
         * @param filterCategory Filter for actions that are within a specific category
         * @param filterName Filter for actions that have names containing the given string
         * @param filterTags Filter for actions that have all of the given tags (comma separated list)
         * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
         */
        getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_ActionsApiFp.getBREActions(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_EventsApi - fetch parameter creator
 */
export const Rule_Engine_EventsApiFetchParamCreator = {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_USER
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  breEvent?: BreEvent; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/events`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breEvent"]) {
            fetchOptions.body = JSON.stringify(params["breEvent"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_EventsApi - functional programming interface
 */
export const Rule_Engine_EventsApiFp = {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_USER
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: { breEvent?: BreEvent;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Rule_Engine_EventsApiFetchParamCreator.sendBREEvent(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_EventsApi - object-oriented interface
 */
export class Rule_Engine_EventsApi extends BaseAPI {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_USER
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  breEvent?: BreEvent; }, options: any = {}) {
        return Rule_Engine_EventsApiFp.sendBREEvent(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_EventsApi - factory interface
 */
export const Rule_Engine_EventsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EVENTS_USER
         * @summary Fire a new event, based on an existing trigger
         * @param breEvent The BRE event object
         */
        sendBREEvent(params: {  breEvent?: BreEvent; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_EventsApiFp.sendBREEvent(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_ExpressionsApi - fetch parameter creator
 */
export const Rule_Engine_ExpressionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Lookup a specific expression
     * @param type Specifiy the type of expression as returned by the listing endpoint
     */
    getBREExpression(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling getBREExpression");
        }
        const baseUrl = `/bre/expressions/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Each resource contains a type and a definition that are read-only, all the other fields must be provided when using the expression in a rule. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Get a list of supported expressions to use in conditions or actions.
     * @param filterTypeGroup Filter for expressions by type group
     */
    getBREExpressions(params: {  filterTypeGroup?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/expressions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTypeGroup"] !== undefined) {
            urlObj.query["filter_type_group"] = params["filterTypeGroup"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Returns the textual representation of an expression
     * @param expression The expression resource to be converted
     */
    getExpressionAsText(params: {  expression?: ExpressionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/expressions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["expression"]) {
            fetchOptions.body = JSON.stringify(params["expression"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_ExpressionsApi - functional programming interface
 */
export const Rule_Engine_ExpressionsApiFp = {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Lookup a specific expression
     * @param type Specifiy the type of expression as returned by the listing endpoint
     */
    getBREExpression(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ExpressionResource> {
        const fetchArgs = Rule_Engine_ExpressionsApiFetchParamCreator.getBREExpression(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Each resource contains a type and a definition that are read-only, all the other fields must be provided when using the expression in a rule. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Get a list of supported expressions to use in conditions or actions.
     * @param filterTypeGroup Filter for expressions by type group
     */
    getBREExpressions(params: { filterTypeGroup?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<ExpressionResource>> {
        const fetchArgs = Rule_Engine_ExpressionsApiFetchParamCreator.getBREExpressions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Returns the textual representation of an expression
     * @param expression The expression resource to be converted
     */
    getExpressionAsText(params: { expression?: ExpressionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StringWrapper> {
        const fetchArgs = Rule_Engine_ExpressionsApiFetchParamCreator.getExpressionAsText(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_ExpressionsApi - object-oriented interface
 */
export class Rule_Engine_ExpressionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Lookup a specific expression
     * @param type Specifiy the type of expression as returned by the listing endpoint
     */
    getBREExpression(params: {  type: string; }, options: any = {}) {
        return Rule_Engine_ExpressionsApiFp.getBREExpression(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Each resource contains a type and a definition that are read-only, all the other fields must be provided when using the expression in a rule. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Get a list of supported expressions to use in conditions or actions.
     * @param filterTypeGroup Filter for expressions by type group
     */
    getBREExpressions(params: {  filterTypeGroup?: string; }, options: any = {}) {
        return Rule_Engine_ExpressionsApiFp.getBREExpressions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
     * @summary Returns the textual representation of an expression
     * @param expression The expression resource to be converted
     */
    getExpressionAsText(params: {  expression?: ExpressionResource; }, options: any = {}) {
        return Rule_Engine_ExpressionsApiFp.getExpressionAsText(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_ExpressionsApi - factory interface
 */
export const Rule_Engine_ExpressionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
         * @summary Lookup a specific expression
         * @param type Specifiy the type of expression as returned by the listing endpoint
         */
        getBREExpression(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_ExpressionsApiFp.getBREExpression(params, configuration, options)(fetch, basePath);
        },
        /**
         * Each resource contains a type and a definition that are read-only, all the other fields must be provided when using the expression in a rule. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
         * @summary Get a list of supported expressions to use in conditions or actions.
         * @param filterTypeGroup Filter for expressions by type group
         */
        getBREExpressions(params: {  filterTypeGroup?: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_ExpressionsApiFp.getBREExpressions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_EXPRESSIONS_USER
         * @summary Returns the textual representation of an expression
         * @param expression The expression resource to be converted
         */
        getExpressionAsText(params: {  expression?: ExpressionResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_ExpressionsApiFp.getExpressionAsText(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_GlobalsApi - fetch parameter creator
 */
export const Rule_Engine_GlobalsApiFetchParamCreator = {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_GlobalsApi - functional programming interface
 */
export const Rule_Engine_GlobalsApiFp = {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: { breGlobalResource?: BreGlobalResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = Rule_Engine_GlobalsApiFetchParamCreator.createBREGlobal(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Rule_Engine_GlobalsApiFetchParamCreator.deleteBREGlobal(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = Rule_Engine_GlobalsApiFetchParamCreator.getBREGlobal(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: { filterSystem?: boolean; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreGlobalResource> {
        const fetchArgs = Rule_Engine_GlobalsApiFetchParamCreator.getBREGlobals(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: { id: string; breGlobalResource?: BreGlobalResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = Rule_Engine_GlobalsApiFetchParamCreator.updateBREGlobal(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_GlobalsApi - object-oriented interface
 */
export class Rule_Engine_GlobalsApi extends BaseAPI {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, options: any = {}) {
        return Rule_Engine_GlobalsApiFp.createBREGlobal(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  id: string; }, options: any = {}) {
        return Rule_Engine_GlobalsApiFp.deleteBREGlobal(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  id: string; }, options: any = {}) {
        return Rule_Engine_GlobalsApiFp.getBREGlobal(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, options: any = {}) {
        return Rule_Engine_GlobalsApiFp.getBREGlobals(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, options: any = {}) {
        return Rule_Engine_GlobalsApiFp.updateBREGlobal(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_GlobalsApi - factory interface
 */
export const Rule_Engine_GlobalsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
         * @summary Create a global definition
         * @param breGlobalResource The BRE global resource object
         */
        createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_GlobalsApiFp.createBREGlobal(params, configuration, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
         * @summary Delete a global
         * @param id The id of the global definition
         */
        deleteBREGlobal(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_GlobalsApiFp.deleteBREGlobal(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
         * @summary Get a single global definition
         * @param id The id of the global definition
         */
        getBREGlobal(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_GlobalsApiFp.getBREGlobal(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_USER
         * @summary List global definitions
         * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_GlobalsApiFp.getBREGlobals(params, configuration, options)(fetch, basePath);
        },
        /**
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_GLOBALS_ADMIN
         * @summary Update a global definition
         * @param id The id of the global definition
         * @param breGlobalResource The BRE global resource object
         */
        updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_GlobalsApiFp.updateBREGlobal(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_RulesApi - fetch parameter creator
 */
export const Rule_Engine_RulesApiFetchParamCreator = {
    /**
     * Rules define which actions to run when a given event verifies the specified condition. Full list of predicates and other type of expressions can be found at GET /bre/expressions/. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  breRule?: BreRule; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  expression?: Expressionobject; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules/expression-as-string`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["expression"]) {
            fetchOptions.body = JSON.stringify(params["expression"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterEnabled"] !== undefined) {
            urlObj.query["filter_enabled"] = params["filterEnabled"];
        }
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["filterTrigger"] !== undefined) {
            urlObj.query["filter_trigger"] = params["filterTrigger"];
        }
        if (params["filterAction"] !== undefined) {
            urlObj.query["filter_action"] = params["filterAction"];
        }
        if (params["filterCondition"] !== undefined) {
            urlObj.query["filter_condition"] = params["filterCondition"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  id: string; enabled?: BooleanResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setBRERule");
        }
        const baseUrl = `/bre/rules/{id}/enabled`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["enabled"]) {
            fetchOptions.body = JSON.stringify(params["enabled"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Cannot update system rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  id: string; breRule?: BreRule; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_RulesApi - functional programming interface
 */
export const Rule_Engine_RulesApiFp = {
    /**
     * Rules define which actions to run when a given event verifies the specified condition. Full list of predicates and other type of expressions can be found at GET /bre/expressions/. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: { breRule?: BreRule;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.createBRERule(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.deleteBRERule(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: { expression?: Expressionobject;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.getBREExpressionAsString(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.getBRERule(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: { filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreRule> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.getBRERules(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: { id: string; enabled?: BooleanResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.setBRERule(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Cannot update system rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: { id: string; breRule?: BreRule;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = Rule_Engine_RulesApiFetchParamCreator.updateBRERule(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_RulesApi - object-oriented interface
 */
export class Rule_Engine_RulesApi extends BaseAPI {
    /**
     * Rules define which actions to run when a given event verifies the specified condition. Full list of predicates and other type of expressions can be found at GET /bre/expressions/. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  breRule?: BreRule; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.createBRERule(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: {  id: string; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.deleteBRERule(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  expression?: Expressionobject; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.getBREExpressionAsString(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  id: string; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.getBRERule(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.getBRERules(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  id: string; enabled?: BooleanResource; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.setBRERule(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Cannot update system rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  id: string; breRule?: BreRule; }, options: any = {}) {
        return Rule_Engine_RulesApiFp.updateBRERule(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_RulesApi - factory interface
 */
export const Rule_Engine_RulesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Rules define which actions to run when a given event verifies the specified condition. Full list of predicates and other type of expressions can be found at GET /bre/expressions/. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Create a rule
         * @param breRule The BRE rule object
         */
        createBRERule(params: {  breRule?: BreRule; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.createBRERule(params, configuration, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Delete a rule
         * @param id The id of the rule
         */
        deleteBRERule(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.deleteBRERule(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Returns a string representation of the provided expression
         * @param expression The expression
         */
        getBREExpressionAsString(params: {  expression?: Expressionobject; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.getBREExpressionAsString(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Get a single rule
         * @param id The id of the rule
         */
        getBRERule(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.getBRERule(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary List rules
         * @param filterName Filter for rules containing the given name
         * @param filterEnabled Filter for rules by active status, null for both
         * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
         * @param filterTrigger Filter for rules that are for the trigger with the given name
         * @param filterAction Filter for rules that use the action with the given name
         * @param filterCondition Filter for rules that have a condition containing the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.getBRERules(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is helpful for turning off systems rules which cannot be deleted or modified otherwise. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Enable or disable a rule
         * @param id The id of the rule
         * @param enabled The boolean value
         */
        setBRERule(params: {  id: string; enabled?: BooleanResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.setBRERule(params, configuration, options)(fetch, basePath);
        },
        /**
         * Cannot update system rules. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_RULES_ADMIN
         * @summary Update a rule
         * @param id The id of the rule
         * @param breRule The BRE rule object
         */
        updateBRERule(params: {  id: string; breRule?: BreRule; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_RulesApiFp.updateBRERule(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_TriggersApi - fetch parameter creator
 */
export const Rule_Engine_TriggersApiFetchParamCreator = {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  eventName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling deleteBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  eventName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling getBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTags"] !== undefined) {
            urlObj.query["filter_tags"] = params["filterTags"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling updateBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_TriggersApi - functional programming interface
 */
export const Rule_Engine_TriggersApiFp = {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: { breTriggerResource?: BreTriggerResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = Rule_Engine_TriggersApiFetchParamCreator.createBRETrigger(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: { eventName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Rule_Engine_TriggersApiFetchParamCreator.deleteBRETrigger(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: { eventName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = Rule_Engine_TriggersApiFetchParamCreator.getBRETrigger(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: { filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreTriggerResource> {
        const fetchArgs = Rule_Engine_TriggersApiFetchParamCreator.getBRETriggers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: { eventName: string; breTriggerResource?: BreTriggerResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = Rule_Engine_TriggersApiFetchParamCreator.updateBRETrigger(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_TriggersApi - object-oriented interface
 */
export class Rule_Engine_TriggersApi extends BaseAPI {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, options: any = {}) {
        return Rule_Engine_TriggersApiFp.createBRETrigger(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  eventName: string; }, options: any = {}) {
        return Rule_Engine_TriggersApiFp.deleteBRETrigger(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  eventName: string; }, options: any = {}) {
        return Rule_Engine_TriggersApiFp.getBRETrigger(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, options: any = {}) {
        return Rule_Engine_TriggersApiFp.getBRETriggers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, options: any = {}) {
        return Rule_Engine_TriggersApiFp.updateBRETrigger(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_TriggersApi - factory interface
 */
export const Rule_Engine_TriggersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
         * @summary Create a trigger
         * @param breTriggerResource The BRE trigger resource object
         */
        createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_TriggersApiFp.createBRETrigger(params, configuration, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
         * @summary Delete a trigger
         * @param eventName The trigger event name
         */
        deleteBRETrigger(params: {  eventName: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_TriggersApiFp.deleteBRETrigger(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
         * @summary Get a single trigger
         * @param eventName The trigger event name
         */
        getBRETrigger(params: {  eventName: string; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_TriggersApiFp.getBRETrigger(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_USER
         * @summary List triggers
         * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
         * @param filterCategory Filter for triggers that are within a specific category
         * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
         * @param filterName Filter for triggers that have names containing the given string
         * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_TriggersApiFp.getBRETriggers(params, configuration, options)(fetch, basePath);
        },
        /**
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_TRIGGERS_ADMIN
         * @summary Update a trigger
         * @param eventName The trigger event name
         * @param breTriggerResource The BRE trigger resource object
         */
        updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_TriggersApiFp.updateBRETrigger(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Rule_Engine_VariablesApi - fetch parameter creator
 */
export const Rule_Engine_VariablesApiFetchParamCreator = {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/bre/variable-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getBREVariableValues");
        }
        const baseUrl = `/bre/variable-types/{name}/values`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Rule_Engine_VariablesApi - functional programming interface
 */
export const Rule_Engine_VariablesApiFp = {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<VariableTypeResource>> {
        const fetchArgs = Rule_Engine_VariablesApiFetchParamCreator.getBREVariableTypes(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: { name: string; filterName?: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleReferenceResourceobject> {
        const fetchArgs = Rule_Engine_VariablesApiFetchParamCreator.getBREVariableValues(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Rule_Engine_VariablesApi - object-oriented interface
 */
export class Rule_Engine_VariablesApi extends BaseAPI {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(options: any = {}) {
        return Rule_Engine_VariablesApiFp.getBREVariableTypes(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, options: any = {}) {
        return Rule_Engine_VariablesApiFp.getBREVariableValues(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Rule_Engine_VariablesApi - factory interface
 */
export const Rule_Engine_VariablesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
         * @summary Get a list of variable types available
         */
        getBREVariableTypes(configuration: Configuration, options: any = {}) {
            return Rule_Engine_VariablesApiFp.getBREVariableTypes(configuration, options)(fetch, basePath);
        },
        /**
         * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here. <br><br><b>Permissions Needed:</b> BRE_RULE_ENGINE_VARIABLES_USER
         * @summary List valid values for a type
         * @param name The name of the type
         * @param filterName Filter results by those with names starting with this string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Rule_Engine_VariablesApiFp.getBREVariableValues(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * SearchApi - fetch parameter creator
 */
export const SearchApiFetchParamCreator = {
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     */
    searchCountGET(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchCountGET");
        }
        const baseUrl = `/search/count/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchCountPOST(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchCountPOST");
        }
        const baseUrl = `/search/count/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchCountWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchCountWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchCountWithTemplateGET");
        }
        const baseUrl = `/search/count/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchCountWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchCountWithTemplatePOST");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchCountWithTemplatePOST");
        }
        const baseUrl = `/search/count/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with no template
     * @param type The index type
     * @param id The index id
     */
    searchDocumentGET(params: {  type: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchDocumentGET");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchDocumentGET");
        }
        const baseUrl = `/search/documents/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchDocumentWithTemplateGET(params: {  type: string; id: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchDocumentWithTemplateGET");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchDocumentWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchDocumentWithTemplateGET");
        }
        const baseUrl = `/search/documents/{type}/{template}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     */
    searchExplainGET(params: {  type: string; id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchExplainGET");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchExplainGET");
        }
        const baseUrl = `/search/explain/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     * @param query The query to be used for the search
     */
    searchExplainPOST(params: {  type: string; id: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchExplainPOST");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchExplainPOST");
        }
        const baseUrl = `/search/explain/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchExplainWithTemplateGET(params: {  type: string; id: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchExplainWithTemplateGET");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchExplainWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchExplainWithTemplateGET");
        }
        const baseUrl = `/search/explain/{type}/{template}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchExplainWithTemplatePOST(params: {  type: string; id: string; template: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchExplainWithTemplatePOST");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling searchExplainWithTemplatePOST");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchExplainWithTemplatePOST");
        }
        const baseUrl = `/search/explain/{type}/{template}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchIndex(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndex");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     */
    searchIndexGET(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndexGET");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     */
    searchIndexWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndexWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchIndexWithTemplateGET");
        }
        const baseUrl = `/search/index/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchIndexWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndexWithTemplatePOST");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchIndexWithTemplatePOST");
        }
        const baseUrl = `/search/index/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _cat/indices for indices.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get indices
     */
    searchIndicesGET(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/search/indices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with no template
     * @param type The index type
     */
    searchMappingsGET(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchMappingsGET");
        }
        const baseUrl = `/search/mappings/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with a template
     * @param type The index type
     * @param template The index template
     */
    searchMappingsWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchMappingsWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchMappingsWithTemplateGET");
        }
        const baseUrl = `/search/mappings/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     */
    searchValidateGET(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchValidateGET");
        }
        const baseUrl = `/search/validate/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchValidatePOST(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchValidatePOST");
        }
        const baseUrl = `/search/validate/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchValidateWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchValidateWithTemplateGET");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchValidateWithTemplateGET");
        }
        const baseUrl = `/search/validate/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchValidateWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchValidateWithTemplatePOST");
        }
        // verify required parameter "template" is set
        if (params["template"] == null) {
            throw new Error("Missing required parameter template when calling searchValidateWithTemplatePOST");
        }
        const baseUrl = `/search/validate/{type}/{template}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"template"}}`, `${ params["template"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = {
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     */
    searchCountGET(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchCountGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchCountPOST(params: { type: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchCountPOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchCountWithTemplateGET(params: { type: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchCountWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchCountWithTemplatePOST(params: { type: string; template: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchCountWithTemplatePOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with no template
     * @param type The index type
     * @param id The index id
     */
    searchDocumentGET(params: { type: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchDocumentGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchDocumentWithTemplateGET(params: { type: string; id: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchDocumentWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     */
    searchExplainGET(params: { type: string; id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchExplainGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     * @param query The query to be used for the search
     */
    searchExplainPOST(params: { type: string; id: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchExplainPOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchExplainWithTemplateGET(params: { type: string; id: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchExplainWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchExplainWithTemplatePOST(params: { type: string; id: string; template: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchExplainWithTemplatePOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchIndex(params: { type: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndex(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     */
    searchIndexGET(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndexGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     */
    searchIndexWithTemplateGET(params: { type: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndexWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchIndexWithTemplatePOST(params: { type: string; template: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndexWithTemplatePOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _cat/indices for indices.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get indices
     */
    searchIndicesGET(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndicesGET(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with no template
     * @param type The index type
     */
    searchMappingsGET(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchMappingsGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with a template
     * @param type The index type
     * @param template The index template
     */
    searchMappingsWithTemplateGET(params: { type: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchMappingsWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     */
    searchValidateGET(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchValidateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchValidatePOST(params: { type: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchValidatePOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchValidateWithTemplateGET(params: { type: string; template: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchValidateWithTemplateGET(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchValidateWithTemplatePOST(params: { type: string; template: string; query?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.searchValidateWithTemplatePOST(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     */
    searchCountGET(params: {  type: string; }, options: any = {}) {
        return SearchApiFp.searchCountGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchCountPOST(params: {  type: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchCountPOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchCountWithTemplateGET(params: {  type: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchCountWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Count matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchCountWithTemplatePOST(params: {  type: string; template: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchCountWithTemplatePOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with no template
     * @param type The index type
     * @param id The index id
     */
    searchDocumentGET(params: {  type: string; id: string; }, options: any = {}) {
        return SearchApiFp.searchDocumentGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get document with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchDocumentWithTemplateGET(params: {  type: string; id: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchDocumentWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     */
    searchExplainGET(params: {  type: string; id: string; }, options: any = {}) {
        return SearchApiFp.searchExplainGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with no template
     * @param type The index type
     * @param id The index id
     * @param query The query to be used for the search
     */
    searchExplainPOST(params: {  type: string; id: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchExplainPOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     */
    searchExplainWithTemplateGET(params: {  type: string; id: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchExplainWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Explain matches with a template
     * @param type The index type
     * @param id The index id
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchExplainWithTemplatePOST(params: {  type: string; id: string; template: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchExplainWithTemplatePOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchIndex(params: {  type: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchIndex(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with no template
     * @param type The index type
     */
    searchIndexGET(params: {  type: string; }, options: any = {}) {
        return SearchApiFp.searchIndexGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     */
    searchIndexWithTemplateGET(params: {  type: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchIndexWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Search an index with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchIndexWithTemplatePOST(params: {  type: string; template: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchIndexWithTemplatePOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _cat/indices for indices.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get indices
     */
    searchIndicesGET(options: any = {}) {
        return SearchApiFp.searchIndicesGET(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with no template
     * @param type The index type
     */
    searchMappingsGET(params: {  type: string; }, options: any = {}) {
        return SearchApiFp.searchMappingsGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Get mapping with a template
     * @param type The index type
     * @param template The index template
     */
    searchMappingsWithTemplateGET(params: {  type: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchMappingsWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     */
    searchValidateGET(params: {  type: string; }, options: any = {}) {
        return SearchApiFp.searchValidateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with no template
     * @param type The index type
     * @param query The query to be used for the search
     */
    searchValidatePOST(params: {  type: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchValidatePOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     */
    searchValidateWithTemplateGET(params: {  type: string; template: string; }, options: any = {}) {
        return SearchApiFp.searchValidateWithTemplateGET(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
     * @summary Validate matches with a template
     * @param type The index type
     * @param template The index template
     * @param query The query to be used for the search
     */
    searchValidateWithTemplatePOST(params: {  type: string; template: string; query?: any; }, options: any = {}) {
        return SearchApiFp.searchValidateWithTemplatePOST(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Count matches with no template
         * @param type The index type
         */
        searchCountGET(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchCountGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Count matches with no template
         * @param type The index type
         * @param query The query to be used for the search
         */
        searchCountPOST(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchCountPOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Count matches with a template
         * @param type The index type
         * @param template The index template
         */
        searchCountWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchCountWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _count.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Count matches with a template
         * @param type The index type
         * @param template The index template
         * @param query The query to be used for the search
         */
        searchCountWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchCountWithTemplatePOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Get document with no template
         * @param type The index type
         * @param id The index id
         */
        searchDocumentGET(params: {  type: string; id: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchDocumentGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Get document with a template
         * @param type The index type
         * @param id The index id
         * @param template The index template
         */
        searchDocumentWithTemplateGET(params: {  type: string; id: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchDocumentWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Explain matches with no template
         * @param type The index type
         * @param id The index id
         */
        searchExplainGET(params: {  type: string; id: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchExplainGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Explain matches with no template
         * @param type The index type
         * @param id The index id
         * @param query The query to be used for the search
         */
        searchExplainPOST(params: {  type: string; id: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchExplainPOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Explain matches with a template
         * @param type The index type
         * @param id The index id
         * @param template The index template
         */
        searchExplainWithTemplateGET(params: {  type: string; id: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchExplainWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _explain.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Explain matches with a template
         * @param type The index type
         * @param id The index id
         * @param template The index template
         * @param query The query to be used for the search
         */
        searchExplainWithTemplatePOST(params: {  type: string; id: string; template: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchExplainWithTemplatePOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Search an index with no template
         * @param type The index type
         * @param query The query to be used for the search
         */
        searchIndex(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchIndex(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Search an index with no template
         * @param type The index type
         */
        searchIndexGET(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchIndexGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Search an index with a template
         * @param type The index type
         * @param template The index template
         */
        searchIndexWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchIndexWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _search.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Search an index with a template
         * @param type The index type
         * @param template The index template
         * @param query The query to be used for the search
         */
        searchIndexWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchIndexWithTemplatePOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _cat/indices for indices.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Get indices
         */
        searchIndicesGET(configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchIndicesGET(configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Get mapping with no template
         * @param type The index type
         */
        searchMappingsGET(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchMappingsGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _mapping.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-get-mapping.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Get mapping with a template
         * @param type The index type
         * @param template The index template
         */
        searchMappingsWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchMappingsWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Validate matches with no template
         * @param type The index type
         */
        searchValidateGET(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchValidateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Validate matches with no template
         * @param type The index type
         * @param query The query to be used for the search
         */
        searchValidatePOST(params: {  type: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchValidatePOST(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Validate matches with a template
         * @param type The index type
         * @param template The index template
         */
        searchValidateWithTemplateGET(params: {  type: string; template: string; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchValidateWithTemplateGET(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a 1 to 1 mapping of a ElasticSearch call to _validate/query.  Further information can be found at their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/search-validate.html'>API guide</a>. <br><br><b>Permissions Needed:</b> SEARCH_ADMIN
         * @summary Validate matches with a template
         * @param type The index type
         * @param template The index template
         * @param query The query to be used for the search
         */
        searchValidateWithTemplatePOST(params: {  type: string; template: string; query?: any; }, configuration: Configuration, options: any = {}) {
            return SearchApiFp.searchValidateWithTemplatePOST(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Social_FacebookApi - fetch parameter creator
 */
export const Social_FacebookApiFetchParamCreator = {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-facebook user token
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: {  facebookToken?: FacebookToken; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/social/facebook/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["facebookToken"]) {
            fetchOptions.body = JSON.stringify(params["facebookToken"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Social_FacebookApi - functional programming interface
 */
export const Social_FacebookApiFp = {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-facebook user token
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: { facebookToken?: FacebookToken;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Social_FacebookApiFetchParamCreator.linkAccounts(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Social_FacebookApi - object-oriented interface
 */
export class Social_FacebookApi extends BaseAPI {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-facebook user token
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: {  facebookToken?: FacebookToken; }, options: any = {}) {
        return Social_FacebookApiFp.linkAccounts(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Social_FacebookApi - factory interface
 */
export const Social_FacebookApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-facebook user token
         * @summary Link facebook account
         * @param facebookToken The token from facebook
         */
        linkAccounts(params: {  facebookToken?: FacebookToken; }, configuration: Configuration, options: any = {}) {
            return Social_FacebookApiFp.linkAccounts(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Social_GoogleApi - fetch parameter creator
 */
export const Social_GoogleApiFetchParamCreator = {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-google user token
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: {  googleToken?: GoogleToken; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/social/google/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["googleToken"]) {
            fetchOptions.body = JSON.stringify(params["googleToken"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Social_GoogleApi - functional programming interface
 */
export const Social_GoogleApiFp = {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-google user token
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: { googleToken?: GoogleToken;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Social_GoogleApiFetchParamCreator.linkAccounts1(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Social_GoogleApi - object-oriented interface
 */
export class Social_GoogleApi extends BaseAPI {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-google user token
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: {  googleToken?: GoogleToken; }, options: any = {}) {
        return Social_GoogleApiFp.linkAccounts1(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Social_GoogleApi - factory interface
 */
export const Social_GoogleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired. <br><br><b>Permissions Needed:</b> Non-google user token
         * @summary Link google account
         * @param googleToken The token from google
         */
        linkAccounts1(params: {  googleToken?: GoogleToken; }, configuration: Configuration, options: any = {}) {
            return Social_GoogleApiFp.linkAccounts1(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * StoreApi - fetch parameter creator
 */
export const StoreApiFetchParamCreator = {
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints. <br><br><b>Permissions Needed:</b> STORE_ADMIN
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available item behaviors
     */
    getBehaviors(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/items/behaviors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If called without permission STORE_ADMIN the only items marked displayable, whose start and end date are null or appropriate to the current date, and whose geo policy allows the caller's country will be returned. Similarly skus will be filtered, possibly resulting in an item returned with no skus the user can purchase. br><br><b>Permissions Needed:</b> ANY
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterNameSearch"] !== undefined) {
            urlObj.query["filter_name_search"] = params["filterNameSearch"];
        }
        if (params["filterUniqueKey"] !== undefined) {
            urlObj.query["filter_unique_key"] = params["filterUniqueKey"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterDisplayable"] !== undefined) {
            urlObj.query["filter_displayable"] = params["filterDisplayable"];
        }
        if (params["filterStart"] !== undefined) {
            urlObj.query["filter_start"] = params["filterStart"];
        }
        if (params["filterEnd"] !== undefined) {
            urlObj.query["filter_end"] = params["filterEnd"];
        }
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterStopDate"] !== undefined) {
            urlObj.query["filter_stop_date"] = params["filterStopDate"];
        }
        if (params["filterSku"] !== undefined) {
            urlObj.query["filter_sku"] = params["filterSku"];
        }
        if (params["filterPrice"] !== undefined) {
            urlObj.query["filter_price"] = params["filterPrice"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterItemsByType"] !== undefined) {
            urlObj.query["filter_items_by_type"] = params["filterItemsByType"];
        }
        if (params["filterBundledSkus"] !== undefined) {
            urlObj.query["filter_bundled_skus"] = params["filterBundledSkus"];
        }
        if (params["filterVendor"] !== undefined) {
            urlObj.query["filter_vendor"] = params["filterVendor"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted. <br><br><b>Permissions Needed:</b> PAYMENTS_USER and owner, or PAYMENTS_ADMIN
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/quick-buy`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["quickBuyRequest"]) {
            fetchOptions.body = JSON.stringify(params["quickBuyRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreApi - functional programming interface
 */
export const StoreApiFp = {
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: { itemTemplateResource?: StoreItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.createItemTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints. <br><br><b>Permissions Needed:</b> STORE_ADMIN
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: { cascade?: boolean; storeItem?: StoreItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.createStoreItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteItemTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteStoreItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available item behaviors
     */
    getBehaviors(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BehaviorDefinitionResource>> {
        const fetchArgs = StoreApiFetchParamCreator.getBehaviors(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If called without permission STORE_ADMIN the only items marked displayable, whose start and end date are null or appropriate to the current date, and whose geo policy allows the caller's country will be returned. Similarly skus will be filtered, possibly resulting in an item returned with no skus the user can purchase. br><br><b>Permissions Needed:</b> ANY
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: { filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItems(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted. <br><br><b>Permissions Needed:</b> PAYMENTS_USER and owner, or PAYMENTS_ADMIN
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: { quickBuyRequest?: QuickBuyRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = StoreApiFetchParamCreator.quickBuy(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: { id: string; itemTemplateResource?: StoreItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.updateItemTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: { id: number; cascade?: boolean; storeItem?: StoreItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.updateStoreItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreApi - object-oriented interface
 */
export class StoreApi extends BaseAPI {
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
        return StoreApiFp.createItemTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints. <br><br><b>Permissions Needed:</b> STORE_ADMIN
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
        return StoreApiFp.createStoreItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreApiFp.deleteItemTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  id: number; }, options: any = {}) {
        return StoreApiFp.deleteStoreItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available item behaviors
     */
    getBehaviors(options: any = {}) {
        return StoreApiFp.getBehaviors(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: {  id: string; }, options: any = {}) {
        return StoreApiFp.getItemTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreApiFp.getItemTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  id: number; }, options: any = {}) {
        return StoreApiFp.getStoreItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If called without permission STORE_ADMIN the only items marked displayable, whose start and end date are null or appropriate to the current date, and whose geo policy allows the caller's country will be returned. Similarly skus will be filtered, possibly resulting in an item returned with no skus the user can purchase. br><br><b>Permissions Needed:</b> ANY
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreApiFp.getStoreItems(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted. <br><br><b>Permissions Needed:</b> PAYMENTS_USER and owner, or PAYMENTS_ADMIN
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, options: any = {}) {
        return StoreApiFp.quickBuy(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
        return StoreApiFp.updateItemTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> STORE_ADMIN
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
        return StoreApiFp.updateStoreItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreApi - factory interface
 */
export const StoreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an item template
         * @param itemTemplateResource The new item template
         */
        createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.createItemTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints. <br><br><b>Permissions Needed:</b> STORE_ADMIN
         * @summary Create a store item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param storeItem The store item object
         */
        createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.createStoreItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an item template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteItemTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.deleteItemTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> STORE_ADMIN
         * @summary Delete a store item
         * @param id The id of the item
         */
        deleteStoreItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.deleteStoreItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List available item behaviors
         */
        getBehaviors(configuration: Configuration, options: any = {}) {
            return StoreApiFp.getBehaviors(configuration, options)(fetch, basePath);
        },
        /**
         * Item Templates define a type of item and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Get a single item template
         * @param id The id of the template
         */
        getItemTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.getItemTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary List and search item templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getItemTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.getItemTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single store item
         * @param id The id of the item
         */
        getStoreItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.getStoreItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * If called without permission STORE_ADMIN the only items marked displayable, whose start and end date are null or appropriate to the current date, and whose geo policy allows the caller's country will be returned. Similarly skus will be filtered, possibly resulting in an item returned with no skus the user can purchase. br><br><b>Permissions Needed:</b> ANY
         * @summary List and search store items
         * @param filterNameSearch Filter for items whose name starts with a given string.
         * @param filterUniqueKey Filter for items whose unique_key is a given string.
         * @param filterPublished Filter for skus that have been published.
         * @param filterDisplayable Filter for items that are displayable.
         * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterSku Filter for skus whose name starts with a given string.
         * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
         * @param filterItemsByType Filter for item type based on its type hint.
         * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
         * @param filterVendor Filter for items from a given vendor, by id.
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.getStoreItems(params, configuration, options)(fetch, basePath);
        },
        /**
         * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted. <br><br><b>Permissions Needed:</b> PAYMENTS_USER and owner, or PAYMENTS_ADMIN
         * @summary One-step purchase and pay for a single SKU item from a user's wallet
         * @param quickBuyRequest Quick buy details
         */
        quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.quickBuy(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an item template
         * @param id The id of the template
         * @param itemTemplateResource The item template resource object
         */
        updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.updateItemTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> STORE_ADMIN
         * @summary Update a store item
         * @param id The id of the item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param storeItem The store item object
         */
        updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, configuration: Configuration, options: any = {}) {
            return StoreApiFp.updateStoreItem(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_BundlesApi - fetch parameter creator
 */
export const Store_BundlesApiFetchParamCreator = {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_BundlesApi - functional programming interface
 */
export const Store_BundlesApiFp = {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: { cascade?: boolean; bundleItem?: BundleItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.createBundleItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: { bundleTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.createBundleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.deleteBundleItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.deleteBundleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.getBundleItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.getBundleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.getBundleTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: { id: number; cascade?: boolean; bundleItem?: BundleItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.updateBundleItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: { id: string; bundleTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_BundlesApiFetchParamCreator.updateBundleTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_BundlesApi - object-oriented interface
 */
export class Store_BundlesApi extends BaseAPI {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
        return Store_BundlesApiFp.createBundleItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_BundlesApiFp.createBundleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  id: number; }, options: any = {}) {
        return Store_BundlesApiFp.deleteBundleItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Store_BundlesApiFp.deleteBundleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  id: number; }, options: any = {}) {
        return Store_BundlesApiFp.getBundleItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: {  id: string; }, options: any = {}) {
        return Store_BundlesApiFp.getBundleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_BundlesApiFp.getBundleTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
        return Store_BundlesApiFp.updateBundleItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> BUNDLES_ADMIN
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_BundlesApiFp.updateBundleTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_BundlesApi - factory interface
 */
export const Store_BundlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Create a bundle item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param bundleItem The bundle item object
         */
        createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.createBundleItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Create a bundle template
         * @param bundleTemplateResource The new bundle template
         */
        createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.createBundleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Delete a bundle item
         * @param id The id of the bundle
         */
        deleteBundleItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.deleteBundleItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Delete a bundle template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteBundleTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.deleteBundleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single bundle item
         * @param id The id of the bundle
         */
        getBundleItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.getBundleItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Bundle Templates define a type of bundle and the properties they have. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get a single bundle template
         * @param id The id of the template
         */
        getBundleTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.getBundleTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search bundle templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.getBundleTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Update a bundle item
         * @param id The id of the bundle
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param bundleItem The bundle item object
         */
        updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.updateBundleItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> BUNDLES_ADMIN
         * @summary Update a bundle template
         * @param id The id of the template
         * @param bundleTemplateResource The bundle template resource object
         */
        updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_BundlesApiFp.updateBundleTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_CouponsApi - fetch parameter creator
 */
export const Store_CouponsApiFetchParamCreator = {
    /**
     * SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a coupon by sku
     * @param sku A sku of the coupon
     */
    getCouponItemBySku(params: {  sku: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling getCouponItemBySku");
        }
        const baseUrl = `/store/coupons/skus/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_CouponsApi - functional programming interface
 */
export const Store_CouponsApiFp = {
    /**
     * SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: { cascade?: boolean; couponItem?: CouponItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.createCouponItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: { couponTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.createCouponTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.deleteCouponItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.deleteCouponTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.getCouponItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a coupon by sku
     * @param sku A sku of the coupon
     */
    getCouponItemBySku(params: { sku: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.getCouponItemBySku(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.getCouponTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.getCouponTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: { id: number; cascade?: boolean; couponItem?: CouponItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.updateCouponItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: { id: string; couponTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_CouponsApiFetchParamCreator.updateCouponTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_CouponsApi - object-oriented interface
 */
export class Store_CouponsApi extends BaseAPI {
    /**
     * SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
        return Store_CouponsApiFp.createCouponItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_CouponsApiFp.createCouponTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  id: number; }, options: any = {}) {
        return Store_CouponsApiFp.deleteCouponItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Store_CouponsApiFp.deleteCouponTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  id: number; }, options: any = {}) {
        return Store_CouponsApiFp.getCouponItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a coupon by sku
     * @param sku A sku of the coupon
     */
    getCouponItemBySku(params: {  sku: string; }, options: any = {}) {
        return Store_CouponsApiFp.getCouponItemBySku(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: {  id: string; }, options: any = {}) {
        return Store_CouponsApiFp.getCouponTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_CouponsApiFp.getCouponTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> COUPONS_ADMIN
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
        return Store_CouponsApiFp.updateCouponItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_CouponsApiFp.updateCouponTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_CouponsApi - factory interface
 */
export const Store_CouponsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> COUPONS_ADMIN
         * @summary Create a coupon item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param couponItem The coupon item object
         */
        createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.createCouponItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a coupon template
         * @param couponTemplateResource The new coupon template
         */
        createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.createCouponTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> COUPONS_ADMIN
         * @summary Delete a coupon item
         * @param id The id of the coupon
         */
        deleteCouponItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.deleteCouponItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a coupon template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteCouponTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.deleteCouponTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> COUPONS_ADMIN
         * @summary Get a single coupon item
         * @param id The id of the coupon
         */
        getCouponItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.getCouponItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a coupon by sku
         * @param sku A sku of the coupon
         */
        getCouponItemBySku(params: {  sku: string; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.getCouponItemBySku(params, configuration, options)(fetch, basePath);
        },
        /**
         * Coupon Templates define a type of coupon and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
         * @summary Get a single coupon template
         * @param id The id of the template
         */
        getCouponTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.getCouponTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or COUPONS_ADMIN
         * @summary List and search coupon templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.getCouponTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> COUPONS_ADMIN
         * @summary Update a coupon item
         * @param id The id of the coupon
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param couponItem The coupon item object
         */
        updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.updateCouponItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a coupon template
         * @param id The id of the template
         * @param couponTemplateResource The coupon template resource object
         */
        updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_CouponsApiFp.updateCouponTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_SalesApi - fetch parameter creator
 */
export const Store_SalesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  catalogSale?: CatalogSale; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_SalesApi - functional programming interface
 */
export const Store_SalesApiFp = {
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: { catalogSale?: CatalogSale;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = Store_SalesApiFetchParamCreator.createCatalogSale(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_SalesApiFetchParamCreator.deleteCatalogSale(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = Store_SalesApiFetchParamCreator.getCatalogSale(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCatalogSale> {
        const fetchArgs = Store_SalesApiFetchParamCreator.getCatalogSales(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: { id: number; catalogSale?: CatalogSale;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = Store_SalesApiFetchParamCreator.updateCatalogSale(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_SalesApi - object-oriented interface
 */
export class Store_SalesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  catalogSale?: CatalogSale; }, options: any = {}) {
        return Store_SalesApiFp.createCatalogSale(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  id: number; }, options: any = {}) {
        return Store_SalesApiFp.deleteCatalogSale(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  id: number; }, options: any = {}) {
        return Store_SalesApiFp.getCatalogSale(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_SalesApiFp.getCatalogSales(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SALES_ADMIN
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, options: any = {}) {
        return Store_SalesApiFp.updateCatalogSale(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_SalesApi - factory interface
 */
export const Store_SalesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> SALES_ADMIN
         * @summary Create a sale
         * @param catalogSale The catalog sale object
         */
        createCatalogSale(params: {  catalogSale?: CatalogSale; }, configuration: Configuration, options: any = {}) {
            return Store_SalesApiFp.createCatalogSale(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SALES_ADMIN
         * @summary Delete a sale
         * @param id The id of the sale
         */
        deleteCatalogSale(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_SalesApiFp.deleteCatalogSale(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
         * @summary Get a single sale
         * @param id The id of the sale
         */
        getCatalogSale(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_SalesApiFp.getCatalogSale(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SALES_USER or SALES_ADMIN
         * @summary List and search sales
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCatalogSales(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_SalesApiFp.getCatalogSales(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SALES_ADMIN
         * @summary Update a sale
         * @param id The id of the sale
         * @param catalogSale The catalog sale object
         */
        updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, configuration: Configuration, options: any = {}) {
            return Store_SalesApiFp.updateCatalogSale(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_ShippingApi - fetch parameter creator
 */
export const Store_ShippingApiFetchParamCreator = {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_ShippingApi - functional programming interface
 */
export const Store_ShippingApiFp = {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: { cascade?: boolean; shippingItem?: ShippingItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.createShippingItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: { shippingTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.createShippingTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.deleteShippingItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.deleteShippingTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.getShippingItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.getShippingTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.getShippingTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: { id: number; cascade?: boolean; shippingItem?: ShippingItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.updateShippingItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: { id: string; shippingTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_ShippingApiFetchParamCreator.updateShippingTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_ShippingApi - object-oriented interface
 */
export class Store_ShippingApi extends BaseAPI {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
        return Store_ShippingApiFp.createShippingItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_ShippingApiFp.createShippingTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  id: number; }, options: any = {}) {
        return Store_ShippingApiFp.deleteShippingItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Store_ShippingApiFp.deleteShippingTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  id: number; }, options: any = {}) {
        return Store_ShippingApiFp.getShippingItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: {  id: string; }, options: any = {}) {
        return Store_ShippingApiFp.getShippingTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_ShippingApiFp.getShippingTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHIPPING_ADMIN
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
        return Store_ShippingApiFp.updateShippingItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_ShippingApiFp.updateShippingTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_ShippingApi - factory interface
 */
export const Store_ShippingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store. <br><br><b>Permissions Needed:</b> SHIPPING_ADMIN
         * @summary Create a shipping item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param shippingItem The shipping item object
         */
        createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.createShippingItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Shipping Templates define a type of shipping and the properties they have.
         * @summary Create a shipping template
         * @param shippingTemplateResource The new shipping template
         */
        createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.createShippingTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHIPPING_ADMIN
         * @summary Delete a shipping item
         * @param id The id of the shipping item
         */
        deleteShippingItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.deleteShippingItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a shipping template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteShippingTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.deleteShippingTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single shipping item
         * @param id The id of the shipping item
         */
        getShippingItem(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.getShippingItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Shipping Templates define a type of shipping and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
         * @summary Get a single shipping template
         * @param id The id of the template
         */
        getShippingTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.getShippingTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SHIPPING_ADMIN
         * @summary List and search shipping templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.getShippingTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHIPPING_ADMIN
         * @summary Update a shipping item
         * @param id The id of the shipping item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param shippingItem The shipping item object
         */
        updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.updateShippingItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a shipping template
         * @param id The id of the template
         * @param shippingTemplateResource The shipping template resource object
         */
        updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_ShippingApiFp.updateShippingTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_Shopping_CartsApi - fetch parameter creator
 */
export const Store_Shopping_CartsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addCustomDiscount");
        }
        const baseUrl = `/carts/{id}/custom-discounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["customDiscount"]) {
            fetchOptions.body = JSON.stringify(params["customDiscount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addDiscountToCart");
        }
        const baseUrl = `/carts/{id}/discounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["skuRequest"]) {
            fetchOptions.body = JSON.stringify(params["skuRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout. <br><br><b>Permissions Needed:</b> ANY
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  owner?: number; currencyCode?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["owner"] !== undefined) {
            urlObj.query["owner"] = params["owner"];
        }
        if (params["currencyCode"] !== undefined) {
            urlObj.query["currency_code"] = params["currencyCode"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCart");
        }
        const baseUrl = `/carts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterOwnerId"] !== undefined) {
            urlObj.query["filter_owner_id"] = params["filterOwnerId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippable");
        }
        const baseUrl = `/carts/{id}/shippable`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingCountries");
        }
        const baseUrl = `/carts/{id}/countries`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  id: string; code: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeDiscountFromCart");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling removeDiscountFromCart");
        }
        const baseUrl = `/carts/{id}/discounts/{code}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May be disallowed by site settings. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartCurrency");
        }
        const baseUrl = `/carts/{id}/currency`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currencyCode"]) {
            fetchOptions.body = JSON.stringify(params["currencyCode"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  id: string; userId?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartOwner");
        }
        const baseUrl = `/carts/{id}/owner`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A quantity of zero will remove the item from the cart altogether. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemInCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingAddress");
        }
        const baseUrl = `/carts/{id}/shipping-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartShippingAddressRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartShippingAddressRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_Shopping_CartsApi - functional programming interface
 */
export const Store_Shopping_CartsApiFp = {
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: { id: string; customDiscount?: CouponDefinition;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.addCustomDiscount(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: { id: string; skuRequest?: SkuRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.addDiscountToCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: { id: string; cartItemRequest?: CartItemRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.addItemToCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout. <br><br><b>Permissions Needed:</b> ANY
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: { owner?: number; currencyCode?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.createCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Cart> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.getCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: { filterOwnerId?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCartSummary> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.getCarts(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CartShippableResponse> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.getShippable(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SampleCountriesResponse> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.getShippingCountries(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: { id: string; code: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.removeDiscountFromCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May be disallowed by site settings. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: { id: string; currencyCode?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.setCartCurrency(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: { id: string; userId?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.setCartOwner(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A quantity of zero will remove the item from the cart altogether. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: { id: string; cartItemRequest?: CartItemRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.updateItemInCart(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: { id: string; cartShippingAddressRequest?: CartShippingAddressRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_Shopping_CartsApiFetchParamCreator.updateShippingAddress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_Shopping_CartsApi - object-oriented interface
 */
export class Store_Shopping_CartsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.addCustomDiscount(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.addDiscountToCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.addItemToCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout. <br><br><b>Permissions Needed:</b> ANY
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  owner?: number; currencyCode?: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.createCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  id: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.getCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.getCarts(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  id: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.getShippable(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: {  id: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.getShippingCountries(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  id: string; code: string; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.removeDiscountFromCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May be disallowed by site settings. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.setCartCurrency(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  id: string; userId?: IntWrapper; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.setCartOwner(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A quantity of zero will remove the item from the cart altogether. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.updateItemInCart(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, options: any = {}) {
        return Store_Shopping_CartsApiFp.updateShippingAddress(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_Shopping_CartsApi - factory interface
 */
export const Store_Shopping_CartsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN
         * @summary Adds a custom discount to the cart
         * @param id The id of the cart
         * @param customDiscount The details of the discount to add
         */
        addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.addCustomDiscount(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Adds a discount coupon to the cart
         * @param id The id of the cart
         * @param skuRequest The request of the sku
         */
        addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.addDiscountToCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Add an item to the cart
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.addItemToCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * You don't have to have a user to create a cart but the API requires authentication to checkout. <br><br><b>Permissions Needed:</b> ANY
         * @summary Create a cart
         * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
         * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
         */
        createCart(params: {  owner?: number; currencyCode?: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.createCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Returns the cart with the given GUID
         * @param id The id of the cart
         */
        getCart(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.getCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Get a list of carts
         * @param filterOwnerId Filter by the id of the owner
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.getCarts(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Returns whether a cart requires shipping
         * @param id The id of the cart
         */
        getShippable(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.getShippable(params, configuration, options)(fetch, basePath);
        },
        /**
         * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Get the list of available shipping countries per vendor
         * @param id The id of the cart
         */
        getShippingCountries(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.getShippingCountries(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Removes a discount coupon from the cart
         * @param id The id of the cart
         * @param code The SKU code of the coupon to remove
         */
        removeDiscountFromCart(params: {  id: string; code: string; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.removeDiscountFromCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * May be disallowed by site settings. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Sets the currency to use for the cart
         * @param id The id of the cart
         * @param currencyCode The code of the currency
         */
        setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.setCartCurrency(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Sets the owner of a cart if none is set already
         * @param id The id of the cart
         * @param userId The id of the user
         */
        setCartOwner(params: {  id: string; userId?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.setCartOwner(params, configuration, options)(fetch, basePath);
        },
        /**
         * A quantity of zero will remove the item from the cart altogether. <br><br><b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Changes the quantity of an item already in the cart
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.updateItemInCart(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SHOPPING_CARTS_ADMIN or owner
         * @summary Modifies or sets the order shipping address
         * @param id The id of the cart
         * @param cartShippingAddressRequest The cart shipping address request object
         */
        updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, configuration: Configuration, options: any = {}) {
            return Store_Shopping_CartsApiFp.updateShippingAddress(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_SubscriptionsApi - fetch parameter creator
 */
export const Store_SubscriptionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Must not be locked or a migration target. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  id: number; planId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscription");
        }
        // verify required parameter "planId" is set
        if (params["planId"] == null) {
            throw new Error("Missing required parameter planId when calling deleteSubscription");
        }
        const baseUrl = `/subscriptions/{id}/plans/{plan_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"plan_id"}}`, `${ params["planId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SUBSCRIPTIONS_ADMIN
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/process`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will not remove plans left out. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_SubscriptionsApi - functional programming interface
 */
export const Store_SubscriptionsApiFp = {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: { subscriptionResource?: SubscriptionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.createSubscription(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: { subscriptionTemplateResource?: SubscriptionTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.createSubscriptionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Must not be locked or a migration target. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: { id: number; planId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.deleteSubscription(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.deleteSubscriptionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.getSubscription(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.getSubscriptionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SUBSCRIPTIONS_ADMIN
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionTemplateResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.getSubscriptionTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.getSubscriptions(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.processSubscriptions(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will not remove plans left out. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: { id: number; subscriptionResource?: SubscriptionResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.updateSubscription(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: { id: string; subscriptionTemplateResource?: SubscriptionTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = Store_SubscriptionsApiFetchParamCreator.updateSubscriptionTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_SubscriptionsApi - object-oriented interface
 */
export class Store_SubscriptionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, options: any = {}) {
        return Store_SubscriptionsApiFp.createSubscription(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
        return Store_SubscriptionsApiFp.createSubscriptionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Must not be locked or a migration target. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  id: number; planId: string; }, options: any = {}) {
        return Store_SubscriptionsApiFp.deleteSubscription(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Store_SubscriptionsApiFp.deleteSubscriptionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  id: number; }, options: any = {}) {
        return Store_SubscriptionsApiFp.getSubscription(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  id: string; }, options: any = {}) {
        return Store_SubscriptionsApiFp.getSubscriptionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SUBSCRIPTIONS_ADMIN
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_SubscriptionsApiFp.getSubscriptionTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_SubscriptionsApiFp.getSubscriptions(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(options: any = {}) {
        return Store_SubscriptionsApiFp.processSubscriptions(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will not remove plans left out. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, options: any = {}) {
        return Store_SubscriptionsApiFp.updateSubscription(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
        return Store_SubscriptionsApiFp.updateSubscriptionTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_SubscriptionsApi - factory interface
 */
export const Store_SubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
         * @summary Creates a subscription item and associated plans
         * @param subscriptionResource The subscription to be created
         */
        createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.createSubscription(params, configuration, options)(fetch, basePath);
        },
        /**
         * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a subscription template
         * @param subscriptionTemplateResource The new subscription template
         */
        createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.createSubscriptionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Must not be locked or a migration target. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
         * @summary Delete a subscription plan
         * @param id The id of the subscription
         * @param planId The id of the plan
         */
        deleteSubscription(params: {  id: number; planId: string; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.deleteSubscription(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a subscription template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.deleteSubscriptionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Retrieve a single subscription item and associated plans
         * @param id The id of the subscription
         */
        getSubscription(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.getSubscription(params, configuration, options)(fetch, basePath);
        },
        /**
         * Subscription Templates define a type of subscription and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Get a single subscription template
         * @param id The id of the template
         */
        getSubscriptionTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.getSubscriptionTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or SUBSCRIPTIONS_ADMIN
         * @summary List and search subscription templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.getSubscriptionTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List available subscription items and associated plans
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptions(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.getSubscriptions(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
         * @summary Processes subscriptions and charge dues
         */
        processSubscriptions(configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.processSubscriptions(configuration, options)(fetch, basePath);
        },
        /**
         * Will not remove plans left out. <br><br><b>Permissions Needed:</b> SUBSCRIPTIONS_ADMIN
         * @summary Updates a subscription item and associated plans
         * @param id The id of the subscription
         * @param subscriptionResource The subscription resource object
         */
        updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.updateSubscription(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a subscription template
         * @param id The id of the template
         * @param subscriptionTemplateResource The subscription template resource object
         */
        updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_SubscriptionsApiFp.updateSubscriptionTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Store_VendorsApi - fetch parameter creator
 */
export const Store_VendorsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  vendor?: VendorResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/vendors/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendorTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["vendorTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/vendors/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  id: number; vendor?: VendorResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendorTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["vendorTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Store_VendorsApi - functional programming interface
 */
export const Store_VendorsApiFp = {
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: { vendor?: VendorResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.createVendor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: { vendorTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.createVendorTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.deleteVendor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.deleteVendorTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.getVendor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.getVendorTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.getVendorTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: { filterName?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVendorResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.getVendors(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: { id: number; vendor?: VendorResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.updateVendor(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: { id: string; vendorTemplateResource?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Store_VendorsApiFetchParamCreator.updateVendorTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Store_VendorsApi - object-oriented interface
 */
export class Store_VendorsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  vendor?: VendorResource; }, options: any = {}) {
        return Store_VendorsApiFp.createVendor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_VendorsApiFp.createVendorTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  id: number; }, options: any = {}) {
        return Store_VendorsApiFp.deleteVendor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Store_VendorsApiFp.deleteVendorTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  id: number; }, options: any = {}) {
        return Store_VendorsApiFp.getVendor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: {  id: string; }, options: any = {}) {
        return Store_VendorsApiFp.getVendorTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_VendorsApiFp.getVendorTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Store_VendorsApiFp.getVendors(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> VENDORS_ADMIN
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  id: number; vendor?: VendorResource; }, options: any = {}) {
        return Store_VendorsApiFp.updateVendor(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return Store_VendorsApiFp.updateVendorTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Store_VendorsApi - factory interface
 */
export const Store_VendorsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> VENDORS_ADMIN
         * @summary Create a vendor
         * @param vendor The vendor
         */
        createVendor(params: {  vendor?: VendorResource; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.createVendor(params, configuration, options)(fetch, basePath);
        },
        /**
         * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a vendor template
         * @param vendorTemplateResource The new vendor template
         */
        createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.createVendorTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VENDORS_ADMIN
         * @summary Delete a vendor
         * @param id The id of the vendor
         */
        deleteVendor(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.deleteVendor(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a vendor template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteVendorTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.deleteVendorTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single vendor
         * @param id The id of the vendor
         */
        getVendor(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.getVendor(params, configuration, options)(fetch, basePath);
        },
        /**
         * Vendor Templates define a type of vendor and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Get a single vendor template
         * @param id The id of the template
         */
        getVendorTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.getVendorTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary List and search vendor templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.getVendorTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search vendors
         * @param filterName Filters vendors by name starting with the text provided in the filter
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.getVendors(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> VENDORS_ADMIN
         * @summary Update a vendor
         * @param id The id of the vendor
         * @param vendor The vendor
         */
        updateVendor(params: {  id: number; vendor?: VendorResource; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.updateVendor(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a vendor template
         * @param id The id of the template
         * @param vendorTemplateResource The vendor template resource object
         */
        updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Store_VendorsApiFp.updateVendorTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * TaxesApi - fetch parameter creator
 */
export const TaxesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  taxResource?: CountryTaxResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling createStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling deleteStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling getStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/tax/states`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTaxesForCountry");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling updateStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxesApi - functional programming interface
 */
export const TaxesApiFp = {
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: { taxResource?: CountryTaxResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.createCountryTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: { countryCodeIso3: string; taxResource?: StateTaxResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.createStateTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: { countryCodeIso3: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteCountryTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: { countryCodeIso3: string; stateCode: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteStateTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: { countryCodeIso3: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTaxes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: { countryCodeIso3: string; stateCode: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountries(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: { countryCodeIso3: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountry(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: { countryCodeIso3: string; taxResource?: CountryTaxResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.updateCountryTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: { countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.updateStateTax(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxesApi - object-oriented interface
 */
export class TaxesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  taxResource?: CountryTaxResource; }, options: any = {}) {
        return TaxesApiFp.createCountryTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, options: any = {}) {
        return TaxesApiFp.createStateTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
        return TaxesApiFp.deleteCountryTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
        return TaxesApiFp.deleteStateTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
        return TaxesApiFp.getCountryTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getCountryTaxes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
        return TaxesApiFp.getStateTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getStateTaxesForCountries(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getStateTaxesForCountry(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, options: any = {}) {
        return TaxesApiFp.updateCountryTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TAX_ADMIN
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, options: any = {}) {
        return TaxesApiFp.updateStateTax(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxesApi - factory interface
 */
export const TaxesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Create a country tax
         * @param taxResource The tax object
         */
        createCountryTax(params: {  taxResource?: CountryTaxResource; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.createCountryTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Create a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.createStateTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Delete an existing tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        deleteCountryTax(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.deleteCountryTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Delete an existing state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.deleteStateTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryTax(params: {  countryCodeIso3: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.getCountryTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary List and search taxes
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.getCountryTaxes(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.getStateTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search taxes across all countries
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.getStateTaxesForCountries(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search taxes within a country
         * @param countryCodeIso3 The iso3 code of the country
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.getStateTaxesForCountry(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Create or update a tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.updateCountryTax(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TAX_ADMIN
         * @summary Create or update a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         * @param taxResource The tax object
         */
        updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, configuration: Configuration, options: any = {}) {
            return TaxesApiFp.updateStateTax(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Templates_PropertiesApi - fetch parameter creator
 */
export const Templates_PropertiesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: {  type: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling getTemplatePropertyType");
        }
        const baseUrl = `/templates/properties/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List template property types
     */
    getTemplatePropertyTypes(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/templates/properties`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Templates_PropertiesApi - functional programming interface
 */
export const Templates_PropertiesApiFp = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: { type: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PropertyFieldListResource> {
        const fetchArgs = Templates_PropertiesApiFetchParamCreator.getTemplatePropertyType(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List template property types
     */
    getTemplatePropertyTypes(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<PropertyFieldListResource>> {
        const fetchArgs = Templates_PropertiesApiFetchParamCreator.getTemplatePropertyTypes(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Templates_PropertiesApi - object-oriented interface
 */
export class Templates_PropertiesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: {  type: string; }, options: any = {}) {
        return Templates_PropertiesApiFp.getTemplatePropertyType(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List template property types
     */
    getTemplatePropertyTypes(options: any = {}) {
        return Templates_PropertiesApiFp.getTemplatePropertyTypes(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Templates_PropertiesApi - factory interface
 */
export const Templates_PropertiesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get details for a template property type
         * @param type type
         */
        getTemplatePropertyType(params: {  type: string; }, configuration: Configuration, options: any = {}) {
            return Templates_PropertiesApiFp.getTemplatePropertyType(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List template property types
         */
        getTemplatePropertyTypes(configuration: Configuration, options: any = {}) {
            return Templates_PropertiesApiFp.getTemplatePropertyTypes(configuration, options)(fetch, basePath);
        },
    };
};


/**
 * UsersApi - fetch parameter creator
 */
export const UsersApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  userId: number; tag: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling addUserTag");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * User Templates define a type of user and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of direct messages with this user
     * @param recipientId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getDirectMessages1(params: {  recipientId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "recipientId" is set
        if (params["recipientId"] == null) {
            throw new Error("Missing required parameter recipientId when calling getDirectMessages1");
        }
        const baseUrl = `/users/{recipient_id}/messages`
            .replace(`{${"recipient_id"}}`, `${ params["recipientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserTags");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterIdList A comma separated list of ids.
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterLastActivity?: string; filterIdList?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterDisplayname"] !== undefined) {
            urlObj.query["filter_displayname"] = params["filterDisplayname"];
        }
        if (params["filterEmail"] !== undefined) {
            urlObj.query["filter_email"] = params["filterEmail"];
        }
        if (params["filterFirstname"] !== undefined) {
            urlObj.query["filter_firstname"] = params["filterFirstname"];
        }
        if (params["filterFullname"] !== undefined) {
            urlObj.query["filter_fullname"] = params["filterFullname"];
        }
        if (params["filterLastname"] !== undefined) {
            urlObj.query["filter_lastname"] = params["filterLastname"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterRole"] !== undefined) {
            urlObj.query["filter_role"] = params["filterRole"];
        }
        if (params["filterLastActivity"] !== undefined) {
            urlObj.query["filter_last_activity"] = params["filterLastActivity"];
        }
        if (params["filterIdList"] !== undefined) {
            urlObj.query["filter_id_list"] = params["filterIdList"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling passwordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newPasswordRequest"]) {
            fetchOptions.body = JSON.stringify(params["newPasswordRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Send a user message
     * @param recipientId The user id
     * @param chatMessageRequest The chat message request
     */
    postUserMessage(params: {  recipientId: number; chatMessageRequest?: ChatMessageRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "recipientId" is set
        if (params["recipientId"] == null) {
            throw new Error("Missing required parameter recipientId when calling postUserMessage");
        }
        const baseUrl = `/users/{recipient_id}/messages`
            .replace(`{${"recipient_id"}}`, `${ params["recipientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["chatMessageRequest"]) {
            fetchOptions.body = JSON.stringify(params["chatMessageRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: {  userResource?: UserResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  userId: number; tag: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeUserTag");
        }
        const baseUrl = `/users/{user_id}/tags/{tag}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> USERS_ADMIN or (USERS_USER and owner)
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  id: number; password?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPassword");
        }
        const baseUrl = `/users/{id}/password`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["password"]) {
            fetchOptions.body = JSON.stringify(params["password"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling startPasswordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/password-reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["passwordReset"]) {
            fetchOptions.body = JSON.stringify(params["passwordReset"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password will not be edited on this endpoint, use password specific endpoints. <br><br><b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  id: string; userResource?: UserResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: { userId: number; tag: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.addUserTag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * User Templates define a type of user and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: { userTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.createUserTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.deleteUserTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of direct messages with this user
     * @param recipientId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getDirectMessages1(params: { recipientId: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatMessageResource> {
        const fetchArgs = UsersApiFetchParamCreator.getDirectMessages1(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: { userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterIdList A comma separated list of ids.
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: { filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterLastActivity?: string; filterIdList?: string; filterSearch?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserBaseResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUsers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: { id: number; newPasswordRequest?: NewPasswordRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.passwordReset(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Send a user message
     * @param recipientId The user id
     * @param chatMessageRequest The chat message request
     */
    postUserMessage(params: { recipientId: number; chatMessageRequest?: ChatMessageRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChatMessageResource> {
        const fetchArgs = UsersApiFetchParamCreator.postUserMessage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: { userResource?: UserResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.registerUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: { userId: number; tag: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.removeUserTag(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> USERS_ADMIN or (USERS_USER and owner)
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: { id: number; password?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.setPassword(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.startPasswordReset(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: { passwordReset?: PasswordResetRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.submitPasswordReset(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password will not be edited on this endpoint, use password specific endpoints. <br><br><b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: { id: string; userResource?: UserResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.updateUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: { id: string; userTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.updateUserTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  userId: number; tag: StringWrapper; }, options: any = {}) {
        return UsersApiFp.addUserTag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * User Templates define a type of user and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersApiFp.createUserTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return UsersApiFp.deleteUserTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of direct messages with this user
     * @param recipientId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getDirectMessages1(params: {  recipientId: number; size?: number; page?: number; }, options: any = {}) {
        return UsersApiFp.getDirectMessages1(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  id: string; }, options: any = {}) {
        return UsersApiFp.getUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  userId: number; }, options: any = {}) {
        return UsersApiFp.getUserTags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  id: string; }, options: any = {}) {
        return UsersApiFp.getUserTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersApiFp.getUserTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterIdList A comma separated list of ids.
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterLastActivity?: string; filterIdList?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersApiFp.getUsers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, options: any = {}) {
        return UsersApiFp.passwordReset(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Send a user message
     * @param recipientId The user id
     * @param chatMessageRequest The chat message request
     */
    postUserMessage(params: {  recipientId: number; chatMessageRequest?: ChatMessageRequest; }, options: any = {}) {
        return UsersApiFp.postUserMessage(params, options)(this.fetch, this.basePath);
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: {  userResource?: UserResource; }, options: any = {}) {
        return UsersApiFp.registerUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  userId: number; tag: string; }, options: any = {}) {
        return UsersApiFp.removeUserTag(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> USERS_ADMIN or (USERS_USER and owner)
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  id: number; password?: StringWrapper; }, options: any = {}) {
        return UsersApiFp.setPassword(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: {  id: number; }, options: any = {}) {
        return UsersApiFp.startPasswordReset(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. <br><br><b>Permissions Needed:</b> ANY
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, options: any = {}) {
        return UsersApiFp.submitPasswordReset(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Password will not be edited on this endpoint, use password specific endpoints. <br><br><b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  id: string; userResource?: UserResource; }, options: any = {}) {
        return UsersApiFp.updateUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersApiFp.updateUserTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN
         * @summary Add a tag to a user
         * @param userId The id of the user
         * @param tag tag
         */
        addUserTag(params: {  userId: number; tag: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.addUserTag(params, configuration, options)(fetch, basePath);
        },
        /**
         * User Templates define a type of user and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a user template
         * @param userTemplateResource The user template resource object
         */
        createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.createUserTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a user template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteUserTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.deleteUserTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a list of direct messages with this user
         * @param recipientId The user id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getDirectMessages1(params: {  recipientId: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getDirectMessages1(params, configuration, options)(fetch, basePath);
        },
        /**
         * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get a single user
         * @param id The id of the user or &#39;me&#39;
         */
        getUser(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN
         * @summary List tags for a user
         * @param userId The id of the user
         */
        getUserTags(params: {  userId: number; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getUserTags(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
         * @summary Get a single user template
         * @param id The id of the template
         */
        getUserTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getUserTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or USERS_ADMIN
         * @summary List and search user templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getUserTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * Additional private info is included as USERS_ADMIN. <br><br><b>Permissions Needed:</b> ANY
         * @summary List and search users
         * @param filterDisplayname Filter for users whose display name starts with provided string.
         * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
         * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
         * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
         * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
         * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
         * @param filterTag Filter for users who have a given tag
         * @param filterGroup Filter for users in a given group, by unique name
         * @param filterRole Filter for users with a given role
         * @param filterLastActivity A comma separated string without spaces.  First value is the operator to search on, second value is the date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterIdList A comma separated list of ids.
         * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterLastActivity?: string; filterIdList?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.getUsers(params, configuration, options)(fetch, basePath);
        },
        /**
         * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
         * @summary Choose a new password after a reset
         * @param id The id of the user
         * @param newPasswordRequest The new password request object
         */
        passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.passwordReset(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a user message
         * @param recipientId The user id
         * @param chatMessageRequest The chat message request
         */
        postUserMessage(params: {  recipientId: number; chatMessageRequest?: ChatMessageRequest; }, options: any = {}) {
            return UsersApiFp.postUserMessage(params, options)(fetch, basePath);
        },
        /**
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> ANY
         * @summary Register a new user
         * @param userResource The user resource object
         */
        registerUser(params: {  userResource?: UserResource; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.registerUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN
         * @summary Remove a tag from a user
         * @param userId The id of the user
         * @param tag The tag to remove
         */
        removeUserTag(params: {  userId: number; tag: string; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.removeUserTag(params, configuration, options)(fetch, basePath);
        },
        /**
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security. <br><br><b>Permissions Needed:</b> USERS_ADMIN or (USERS_USER and owner)
         * @summary Set a user's password
         * @param id The id of the user
         * @param password The new plain text password
         */
        setPassword(params: {  id: number; password?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.setPassword(params, configuration, options)(fetch, basePath);
        },
        /**
         * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit. <br><br><b>Permissions Needed:</b> ANY
         * @summary Reset a user's password
         * @param id The id of the user
         */
        startPasswordReset(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.startPasswordReset(params, configuration, options)(fetch, basePath);
        },
        /**
         * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number. <br><br><b>Permissions Needed:</b> ANY
         * @summary Reset a user's password without user id
         * @param passwordReset An object containing one of three methods to look up a user
         */
        submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.submitPasswordReset(params, configuration, options)(fetch, basePath);
        },
        /**
         * Password will not be edited on this endpoint, use password specific endpoints. <br><br><b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary Update a user
         * @param id The id of the user or &#39;me&#39;
         * @param userResource The user resource object
         */
        updateUser(params: {  id: string; userResource?: UserResource; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.updateUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a user template
         * @param id The id of the template
         * @param userTemplateResource The user template resource object
         */
        updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return UsersApiFp.updateUserTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_AddressesApi - fetch parameter creator
 */
export const Users_AddressesApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createAddress");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deleteAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddresses");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_AddressesApi - functional programming interface
 */
export const Users_AddressesApiFp = {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: { userId: string; savedAddressResource?: SavedAddressResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = Users_AddressesApiFetchParamCreator.createAddress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: { userId: string; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_AddressesApiFetchParamCreator.deleteAddress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: { userId: string; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = Users_AddressesApiFetchParamCreator.getAddress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: { userId: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSavedAddressResource> {
        const fetchArgs = Users_AddressesApiFetchParamCreator.getAddresses(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: { userId: string; id: number; savedAddressResource?: SavedAddressResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = Users_AddressesApiFetchParamCreator.updateAddress(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_AddressesApi - object-oriented interface
 */
export class Users_AddressesApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
        return Users_AddressesApiFp.createAddress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  userId: string; id: number; }, options: any = {}) {
        return Users_AddressesApiFp.deleteAddress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  userId: string; id: number; }, options: any = {}) {
        return Users_AddressesApiFp.getAddress(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_AddressesApiFp.getAddresses(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_ADMIN or owner
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
        return Users_AddressesApiFp.updateAddress(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_AddressesApi - factory interface
 */
export const Users_AddressesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary Create a new address
         * @param userId The id of the user
         * @param savedAddressResource The new address
         */
        createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, configuration: Configuration, options: any = {}) {
            return Users_AddressesApiFp.createAddress(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary Delete an address
         * @param userId The id of the user
         * @param id The id of the address
         */
        deleteAddress(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}) {
            return Users_AddressesApiFp.deleteAddress(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary Get a single address
         * @param userId The id of the user
         * @param id The id of the address
         */
        getAddress(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}) {
            return Users_AddressesApiFp.getAddress(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary List and search addresses
         * @param userId The id of the user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_AddressesApiFp.getAddresses(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_ADMIN or owner
         * @summary Update an address
         * @param userId The id of the user
         * @param id The id of the address
         * @param savedAddressResource The saved address resource object
         */
        updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, configuration: Configuration, options: any = {}) {
            return Users_AddressesApiFp.updateAddress(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_FriendshipsApi - fetch parameter creator
 */
export const Users_FriendshipsApiFetchParamCreator = {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param filterUsername Filter for friends with the given username
     * @param filterUserId Filter for friends by user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: {  userId: string; filterUsername?: string; filterUserId?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getFriends");
        }
        const baseUrl = `/users/{user_id}/friends`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterUserId"] !== undefined) {
            urlObj.query["filter_user_id"] = params["filterUserId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  userId: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInviteToken");
        }
        const baseUrl = `/users/{user_id}/invite-token`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Invites that the specified user received. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: {  userId: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInvites");
        }
        const baseUrl = `/users/{user_id}/invites`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling redeemFriendshipToken");
        }
        const baseUrl = `/users/{user_id}/friends/tokens`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["token"]) {
            fetchOptions.body = JSON.stringify(params["token"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeOrDeclineFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeOrDeclineFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_FriendshipsApi - functional programming interface
 */
export const Users_FriendshipsApiFp = {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: { userId: string; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.addFriend(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param filterUsername Filter for friends with the given username
     * @param filterUserId Filter for friends by user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: { userId: string; filterUsername?: string; filterUserId?: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.getFriends(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: { userId: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.getInviteToken(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Invites that the specified user received. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: { userId: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.getInvites(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: { userId: string; token?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.redeemFriendshipToken(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: { userId: string; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_FriendshipsApiFetchParamCreator.removeOrDeclineFriend(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_FriendshipsApi - object-oriented interface
 */
export class Users_FriendshipsApi extends BaseAPI {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  userId: string; id: number; }, options: any = {}) {
        return Users_FriendshipsApiFp.addFriend(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param filterUsername Filter for friends with the given username
     * @param filterUserId Filter for friends by user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: {  userId: string; filterUsername?: string; filterUserId?: number; size?: number; page?: number; }, options: any = {}) {
        return Users_FriendshipsApiFp.getFriends(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  userId: string; }, options: any = {}) {
        return Users_FriendshipsApiFp.getInviteToken(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Invites that the specified user received. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: {  userId: string; size?: number; page?: number; }, options: any = {}) {
        return Users_FriendshipsApiFp.getInvites(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, options: any = {}) {
        return Users_FriendshipsApiFp.redeemFriendshipToken(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  userId: string; id: number; }, options: any = {}) {
        return Users_FriendshipsApiFp.removeOrDeclineFriend(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_FriendshipsApi - factory interface
 */
export const Users_FriendshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Add a friend
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        addFriend(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.addFriend(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Get friends list
         * @param userId The id of the user or &#39;me&#39;
         * @param filterUsername Filter for friends with the given username
         * @param filterUserId Filter for friends by user id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getFriends(params: {  userId: string; filterUsername?: string; filterUserId?: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.getFriends(params, configuration, options)(fetch, basePath);
        },
        /**
         * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Returns the invite token
         * @param userId The id of the user or &#39;me&#39; if logged in
         */
        getInviteToken(params: {  userId: string; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.getInviteToken(params, configuration, options)(fetch, basePath);
        },
        /**
         * Invites that the specified user received. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Get pending invites
         * @param userId The id of the user or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getInvites(params: {  userId: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.getInvites(params, configuration, options)(fetch, basePath);
        },
        /**
         * Immediately connects the requested user with the user mapped by the provided invite token. <br><br><b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Redeem friendship token
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param token The invite token
         */
        redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.redeemFriendshipToken(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> FRIENDSHIPS_ADMIN or (FRIENDSHIPS_USER and owner)
         * @summary Remove or decline a friend
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        removeOrDeclineFriend(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}) {
            return Users_FriendshipsApiFp.removeOrDeclineFriend(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_GroupsApi - fetch parameter creator
 */
export const Users_GroupsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling addMemberToGroup");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling addMemberToGroup");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling addMembersToGroup");
        }
        // verify required parameter "users" is set
        if (params["users"] == null) {
            throw new Error("Missing required parameter users when calling addMembersToGroup");
        }
        const baseUrl = `/users/groups/{unique_name}/members/batch-add`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["users"]) {
            fetchOptions.body = JSON.stringify(params["users"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  groupResource?: GroupResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * GroupMember Templates define a type of group member and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an group member template
     * @param groupMemberTemplateResource The group member template resource object
     */
    createGroupMemberTemplate(params: {  groupMemberTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/members/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupMemberTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupMemberTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Group Templates define a type of group and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * All groups listing this as the parent are also removed and users are in turn removed from this and those groups. This may result in users no longer being in this group's parent if they were not added to it directly as well. <br><br><b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Removes a group from the system
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling deleteGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an group member template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupMemberTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteGroupMemberTemplate");
        }
        const baseUrl = `/users/groups/members/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable notification of group messages
     * @param uniqueName The group unique name
     * @param userId The user id of the member or &#39;me&#39;
     * @param disabled disabled
     */
    disableGroupNotification(params: {  uniqueName: string; userId: string; disabled: ValueWrapperboolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling disableGroupNotification");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling disableGroupNotification");
        }
        // verify required parameter "disabled" is set
        if (params["disabled"] == null) {
            throw new Error("Missing required parameter disabled when calling disableGroupNotification");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/messages/disabled`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["disabled"]) {
            fetchOptions.body = JSON.stringify(params["disabled"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a list of ancestor groups in reverse order (parent, then grandparent, etc). <br><br><b>Permissions Needed:</b> ANY
     * @summary Get group ancestors
     * @param uniqueName The group unique name
     */
    getGroupAncestors(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupAncestors");
        }
        const baseUrl = `/users/groups/{unique_name}/ancestors`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  uniqueName: string; userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group member template
     * @param id The id of the template
     */
    getGroupMemberTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getGroupMemberTemplate");
        }
        const baseUrl = `/users/groups/members/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group member templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMemberTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/members/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMembers");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of group messages
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getGroupMessages(params: {  uniqueName: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMessages");
        }
        const baseUrl = `/users/groups/{unique_name}/messages`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List groups a user is in
     * @param userId The id of the user
     * @param filterChildren Whether to limit group list to children of groups only. If true, shows only groups with parents. If false, shows only groups with no parent.
     */
    getGroupsForUser(params: {  userId: number; filterChildren?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupsForUser");
        }
        const baseUrl = `/users/{user_id}/groups`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterChildren"] !== undefined) {
            urlObj.query["filter_children"] = params["filterChildren"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["filterMemberCount"] !== undefined) {
            urlObj.query["filter_member_count"] = params["filterMemberCount"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterUniqueName"] !== undefined) {
            urlObj.query["filter_unique_name"] = params["filterUniqueName"];
        }
        if (params["filterParent"] !== undefined) {
            urlObj.query["filter_parent"] = params["filterParent"];
        }
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Send a group message
     * @param uniqueName The group unique name
     * @param chatMessageRequest The chat message request
     */
    postGroupMessage(params: {  uniqueName: string; chatMessageRequest?: ChatMessageRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling postGroupMessage");
        }
        const baseUrl = `/users/groups/{unique_name}/messages`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["chatMessageRequest"]) {
            fetchOptions.body = JSON.stringify(params["chatMessageRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  uniqueName: string; userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling removeGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If adding/removing/changing parent, user membership in group/new parent groups may be modified. The parent being removed will remove members from this sub group unless they were added explicitly to the parent and the new parent will gain members unless they were already a part of it. <br><br><b>Permissions Needed:</b> GROUP_ADMIN or admin of the group
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's order
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param order The new order for the membership
     */
    updateGroupMemberProperties(params: {  uniqueName: string; userId: number; order: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroupMemberProperties");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateGroupMemberProperties");
        }
        // verify required parameter "order" is set
        if (params["order"] == null) {
            throw new Error("Missing required parameter order when calling updateGroupMemberProperties");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/order`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["order"]) {
            fetchOptions.body = JSON.stringify(params["order"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's membership properties
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param properties The new properties for the membership
     */
    updateGroupMemberProperties1(params: {  uniqueName: string; userId: number; properties: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroupMemberProperties1");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateGroupMemberProperties1");
        }
        // verify required parameter "properties" is set
        if (params["properties"] == null) {
            throw new Error("Missing required parameter properties when calling updateGroupMemberProperties1");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/properties`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["properties"]) {
            fetchOptions.body = JSON.stringify(params["properties"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: GroupMemberStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroupMemberStatus");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateGroupMemberStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling updateGroupMemberStatus");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/status`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an group member template
     * @param id The id of the template
     * @param groupMemberTemplateResource The group member template resource object
     */
    updateGroupMemberTemplate(params: {  id: string; groupMemberTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateGroupMemberTemplate");
        }
        const baseUrl = `/users/groups/members/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupMemberTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupMemberTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_GroupsApi - functional programming interface
 */
export const Users_GroupsApiFp = {
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: { uniqueName: string; user: GroupMemberResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.addMemberToGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: { uniqueName: string; users: Array<GroupMemberResource>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<GroupMemberResource>> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.addMembersToGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: { groupResource?: GroupResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.createGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * GroupMember Templates define a type of group member and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an group member template
     * @param groupMemberTemplateResource The group member template resource object
     */
    createGroupMemberTemplate(params: { groupMemberTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.createGroupMemberTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Group Templates define a type of group and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: { groupTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.createGroupTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * All groups listing this as the parent are also removed and users are in turn removed from this and those groups. This may result in users no longer being in this group's parent if they were not added to it directly as well. <br><br><b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Removes a group from the system
     * @param uniqueName The group unique name
     */
    deleteGroup(params: { uniqueName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.deleteGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an group member template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupMemberTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.deleteGroupMemberTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.deleteGroupTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable notification of group messages
     * @param uniqueName The group unique name
     * @param userId The user id of the member or &#39;me&#39;
     * @param disabled disabled
     */
    disableGroupNotification(params: { uniqueName: string; userId: string; disabled: ValueWrapperboolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.disableGroupNotification(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: { uniqueName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a list of ancestor groups in reverse order (parent, then grandparent, etc). <br><br><b>Permissions Needed:</b> ANY
     * @summary Get group ancestors
     * @param uniqueName The group unique name
     */
    getGroupAncestors(params: { uniqueName: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<GroupResource>> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupAncestors(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: { uniqueName: string; userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupMember(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group member template
     * @param id The id of the template
     */
    getGroupMemberTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupMemberTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group member templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMemberTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupMemberTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: { uniqueName: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceGroupMemberResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupMembers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of group messages
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getGroupMessages(params: { uniqueName: string; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChatMessageResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupMessages(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List groups a user is in
     * @param userId The id of the user
     * @param filterChildren Whether to limit group list to children of groups only. If true, shows only groups with parents. If false, shows only groups with no parent.
     */
    getGroupsForUser(params: { userId: number; filterChildren?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.getGroupsForUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listGroups(params: { filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceGroupResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.listGroups(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Send a group message
     * @param uniqueName The group unique name
     * @param chatMessageRequest The chat message request
     */
    postGroupMessage(params: { uniqueName: string; chatMessageRequest?: ChatMessageRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChatMessageResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.postGroupMessage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: { uniqueName: string; userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.removeGroupMember(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If adding/removing/changing parent, user membership in group/new parent groups may be modified. The parent being removed will remove members from this sub group unless they were added explicitly to the parent and the new parent will gain members unless they were already a part of it. <br><br><b>Permissions Needed:</b> GROUP_ADMIN or admin of the group
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: { uniqueName: string; groupResource?: GroupResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroup(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's order
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param order The new order for the membership
     */
    updateGroupMemberProperties(params: { uniqueName: string; userId: number; order: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroupMemberProperties(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's membership properties
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param properties The new properties for the membership
     */
    updateGroupMemberProperties1(params: { uniqueName: string; userId: number; properties: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroupMemberProperties1(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: { uniqueName: string; userId: number; status: GroupMemberStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroupMemberStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an group member template
     * @param id The id of the template
     * @param groupMemberTemplateResource The group member template resource object
     */
    updateGroupMemberTemplate(params: { id: string; groupMemberTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroupMemberTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: { id: string; groupTemplateResource?: TemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = Users_GroupsApiFetchParamCreator.updateGroupTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_GroupsApi - object-oriented interface
 */
export class Users_GroupsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, options: any = {}) {
        return Users_GroupsApiFp.addMemberToGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, options: any = {}) {
        return Users_GroupsApiFp.addMembersToGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  groupResource?: GroupResource; }, options: any = {}) {
        return Users_GroupsApiFp.createGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * GroupMember Templates define a type of group member and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an group member template
     * @param groupMemberTemplateResource The group member template resource object
     */
    createGroupMemberTemplate(params: {  groupMemberTemplateResource?: TemplateResource; }, options: any = {}) {
        return Users_GroupsApiFp.createGroupMemberTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Group Templates define a type of group and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, options: any = {}) {
        return Users_GroupsApiFp.createGroupTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * All groups listing this as the parent are also removed and users are in turn removed from this and those groups. This may result in users no longer being in this group's parent if they were not added to it directly as well. <br><br><b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Removes a group from the system
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  uniqueName: string; }, options: any = {}) {
        return Users_GroupsApiFp.deleteGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an group member template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupMemberTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Users_GroupsApiFp.deleteGroupMemberTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Users_GroupsApiFp.deleteGroupTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TOPICS_ADMIN or self
     * @summary Enable or disable notification of group messages
     * @param uniqueName The group unique name
     * @param userId The user id of the member or &#39;me&#39;
     * @param disabled disabled
     */
    disableGroupNotification(params: {  uniqueName: string; userId: string; disabled: ValueWrapperboolean; }, options: any = {}) {
        return Users_GroupsApiFp.disableGroupNotification(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  uniqueName: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a list of ancestor groups in reverse order (parent, then grandparent, etc). <br><br><b>Permissions Needed:</b> ANY
     * @summary Get group ancestors
     * @param uniqueName The group unique name
     */
    getGroupAncestors(params: {  uniqueName: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupAncestors(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupMember(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group member template
     * @param id The id of the template
     */
    getGroupMemberTemplate(params: {  id: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupMemberTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group member templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMemberTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupMemberTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupMembers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a list of group messages
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getGroupMessages(params: {  uniqueName: string; size?: number; page?: number; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupMessages(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  id: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List groups a user is in
     * @param userId The id of the user
     * @param filterChildren Whether to limit group list to children of groups only. If true, shows only groups with parents. If false, shows only groups with no parent.
     */
    getGroupsForUser(params: {  userId: number; filterChildren?: boolean; }, options: any = {}) {
        return Users_GroupsApiFp.getGroupsForUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    listGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_GroupsApiFp.listGroups(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Send a group message
     * @param uniqueName The group unique name
     * @param chatMessageRequest The chat message request
     */
    postGroupMessage(params: {  uniqueName: string; chatMessageRequest?: ChatMessageRequest; }, options: any = {}) {
        return Users_GroupsApiFp.postGroupMessage(params, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
        return Users_GroupsApiFp.removeGroupMember(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If adding/removing/changing parent, user membership in group/new parent groups may be modified. The parent being removed will remove members from this sub group unless they were added explicitly to the parent and the new parent will gain members unless they were already a part of it. <br><br><b>Permissions Needed:</b> GROUP_ADMIN or admin of the group
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroup(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's order
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param order The new order for the membership
     */
    updateGroupMemberProperties(params: {  uniqueName: string; userId: number; order: StringWrapper; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroupMemberProperties(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's membership properties
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param properties The new properties for the membership
     */
    updateGroupMemberProperties1(params: {  uniqueName: string; userId: number; properties: any; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroupMemberProperties1(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> GROUP_ADMIN
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: GroupMemberStatusWrapper; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroupMemberStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an group member template
     * @param id The id of the template
     * @param groupMemberTemplateResource The group member template resource object
     */
    updateGroupMemberTemplate(params: {  id: string; groupMemberTemplateResource?: TemplateResource; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroupMemberTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, options: any = {}) {
        return Users_GroupsApiFp.updateGroupTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_GroupsApi - factory interface
 */
export const Users_GroupsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
         * @summary Adds a new member to the group
         * @param uniqueName The group unique name
         * @param user The id and status for a user to add to the group
         */
        addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.addMemberToGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Adds multiple members to the group
         * @param uniqueName The group unique name
         * @param users The id and status for a list of users to add to the group
         */
        addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.addMembersToGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Create a group
         * @param groupResource The new group
         */
        createGroup(params: {  groupResource?: GroupResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.createGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * GroupMember Templates define a type of group member and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an group member template
         * @param groupMemberTemplateResource The group member template resource object
         */
        createGroupMemberTemplate(params: {  groupMemberTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.createGroupMemberTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * Group Templates define a type of group and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create a group template
         * @param groupTemplateResource The group template resource object
         */
        createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.createGroupTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * All groups listing this as the parent are also removed and users are in turn removed from this and those groups. This may result in users no longer being in this group's parent if they were not added to it directly as well. <br><br><b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Removes a group from the system
         * @param uniqueName The group unique name
         */
        deleteGroup(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.deleteGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an group member template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteGroupMemberTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.deleteGroupMemberTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete a group template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteGroupTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.deleteGroupTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TOPICS_ADMIN or self
         * @summary Enable or disable notification of group messages
         * @param uniqueName The group unique name
         * @param userId The user id of the member or &#39;me&#39;
         * @param disabled disabled
         */
        disableGroupNotification(params: {  uniqueName: string; userId: string; disabled: ValueWrapperboolean; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.disableGroupNotification(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Loads a specific group's details
         * @param uniqueName The group unique name
         */
        getGroup(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * Returns a list of ancestor groups in reverse order (parent, then grandparent, etc). <br><br><b>Permissions Needed:</b> ANY
         * @summary Get group ancestors
         * @param uniqueName The group unique name
         */
        getGroupAncestors(params: {  uniqueName: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupAncestors(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user
         */
        getGroupMember(params: {  uniqueName: string; userId: number; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupMember(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
         * @summary Get a single group member template
         * @param id The id of the template
         */
        getGroupMemberTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupMemberTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
         * @summary List and search group member templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupMemberTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupMemberTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Lists members of the group
         * @param uniqueName The group unique name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupMembers(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a list of group messages
         * @param uniqueName The group unique name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getGroupMessages(params: {  uniqueName: string; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupMessages(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
         * @summary Get a single group template
         * @param id The id of the template
         */
        getGroupTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or GROUP_ADMIN
         * @summary List and search group templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List groups a user is in
         * @param userId The id of the user
         * @param filterChildren Whether to limit group list to children of groups only. If true, shows only groups with parents. If false, shows only groups with no parent.
         */
        getGroupsForUser(params: {  userId: number; filterChildren?: boolean; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.getGroupsForUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search groups
         * @param filterTemplate Filter for groups using a specific template, by id
         * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
         * @param filterName Filter for groups with names starting with the given string
         * @param filterUniqueName Filter for groups whose unique_name starts with provided string
         * @param filterParent Filter for groups with a specific parent, by unique name
         * @param filterStatus Filter for groups with a certain status
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        listGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.listGroups(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a group message
         * @param uniqueName The group unique name
         * @param chatMessageRequest The chat message request
         */
        postGroupMessage(params: {  uniqueName: string; chatMessageRequest?: ChatMessageRequest; }, options: any = {}) {
            return Users_GroupsApiFp.postGroupMessage(params, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN or self if open
         * @summary Removes a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user to remove
         */
        removeGroupMember(params: {  uniqueName: string; userId: number; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.removeGroupMember(params, configuration, options)(fetch, basePath);
        },
        /**
         * If adding/removing/changing parent, user membership in group/new parent groups may be modified. The parent being removed will remove members from this sub group unless they were added explicitly to the parent and the new parent will gain members unless they were already a part of it. <br><br><b>Permissions Needed:</b> GROUP_ADMIN or admin of the group
         * @summary Update a group
         * @param uniqueName The group unique name
         * @param groupResource The updated group
         */
        updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroup(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Change a user's order
         * @param uniqueName The group unique name
         * @param userId The user id of the member to modify
         * @param order The new order for the membership
         */
        updateGroupMemberProperties(params: {  uniqueName: string; userId: number; order: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroupMemberProperties(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Change a user's membership properties
         * @param uniqueName The group unique name
         * @param userId The user id of the member to modify
         * @param properties The new properties for the membership
         */
        updateGroupMemberProperties1(params: {  uniqueName: string; userId: number; properties: any; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroupMemberProperties1(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> GROUP_ADMIN
         * @summary Change a user's status
         * @param uniqueName The group unique name
         * @param userId The user id of the member to modify
         * @param status The new status for the user
         */
        updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: GroupMemberStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroupMemberStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an group member template
         * @param id The id of the template
         * @param groupMemberTemplateResource The group member template resource object
         */
        updateGroupMemberTemplate(params: {  id: string; groupMemberTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroupMemberTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update a group template
         * @param id The id of the template
         * @param groupTemplateResource The group template resource object
         */
        updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_GroupsApiFp.updateGroupTemplate(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_InventoryApi - fetch parameter creator
 */
export const Users_InventoryApiFetchParamCreator = {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToUserInventory");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userInventoryAddRequest"]) {
            fetchOptions.body = JSON.stringify(params["userInventoryAddRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Useful for pre-check and accounts for all various buisness rules. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling checkUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling checkUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/check`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["sku"] !== undefined) {
            urlObj.query["sku"] = params["sku"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Entitlement templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  entitlementId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling deleteEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  entitlementId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling getEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search entitlement items
     * @param filterTemplate Filter for entitlements using a specified template
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  filterTemplate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventories");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["inactive"] !== undefined) {
            urlObj.query["inactive"] = params["inactive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterItemId"] !== undefined) {
            urlObj.query["filter_item_id"] = params["filterItemId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventory");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventory");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventoryLog");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventoryLog");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/log`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/inventories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["inactive"] !== undefined) {
            urlObj.query["inactive"] = params["inactive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterItemId"] !== undefined) {
            urlObj.query["filter_item_id"] = params["filterItemId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling grantUserEntitlement");
        }
        // verify required parameter "grantRequest" is set
        if (params["grantRequest"] == null) {
            throw new Error("Missing required parameter grantRequest when calling grantUserEntitlement");
        }
        const baseUrl = `/users/{user_id}/entitlements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantRequest"]) {
            fetchOptions.body = JSON.stringify(params["grantRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling updateEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryBehaviorData");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryBehaviorData");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/behavior-data`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill). <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryExpires");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryExpires");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/expires`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["timestamp"]) {
            fetchOptions.body = JSON.stringify(params["timestamp"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: InventoryStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryStatus");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryStatus");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["inventoryStatus"]) {
            fetchOptions.body = JSON.stringify(params["inventoryStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling useUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling useUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/use`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["sku"] !== undefined) {
            urlObj.query["sku"] = params["sku"];
        }
        if (params["info"] !== undefined) {
            urlObj.query["info"] = params["info"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_InventoryApi - functional programming interface
 */
export const Users_InventoryApiFp = {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: { id: number; userInventoryAddRequest?: UserInventoryAddRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.addItemToUserInventory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Useful for pre-check and accounts for all various buisness rules. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: { userId: string; itemId: number; sku?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.checkUserEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: { cascade?: boolean; entitlementItem?: EntitlementItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.createEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Entitlement templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: { template?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.createEntitlementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: { entitlementId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.deleteEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: { id: string; cascade?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.deleteEntitlementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: { entitlementId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search entitlement items
     * @param filterTemplate Filter for entitlements using a specified template
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: { filterTemplate?: string; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceEntitlementItem> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getEntitlementItems(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: { id: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getEntitlementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getEntitlementTemplates(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: { id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getUserInventories(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: { userId: string; id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserInventoryResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getUserInventory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: { userId: string; id: number; size?: number; page?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserItemLogResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getUserInventoryLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: { inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.getUsersInventory(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: { userId: number; grantRequest: EntitlementGrantRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.grantUserEntitlement(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: { entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.updateEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: { id: string; template?: ItemTemplateResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.updateEntitlementTemplate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: { userId: number; id: number; data?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.updateUserInventoryBehaviorData(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill). <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: { userId: number; id: number; timestamp?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.updateUserInventoryExpires(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: { userId: number; id: number; inventoryStatus?: InventoryStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.updateUserInventoryStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: { userId: string; itemId: number; sku?: string; info?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_InventoryApiFetchParamCreator.useUserEntitlementItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_InventoryApi - object-oriented interface
 */
export class Users_InventoryApi extends BaseAPI {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, options: any = {}) {
        return Users_InventoryApiFp.addItemToUserInventory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Useful for pre-check and accounts for all various buisness rules. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, options: any = {}) {
        return Users_InventoryApiFp.checkUserEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
        return Users_InventoryApiFp.createEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Entitlement templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, options: any = {}) {
        return Users_InventoryApiFp.createEntitlementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
        return Users_InventoryApiFp.deleteEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return Users_InventoryApiFp.deleteEntitlementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
        return Users_InventoryApiFp.getEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary List and search entitlement items
     * @param filterTemplate Filter for entitlements using a specified template
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  filterTemplate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_InventoryApiFp.getEntitlementItems(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  id: string; }, options: any = {}) {
        return Users_InventoryApiFp.getEntitlementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_InventoryApiFp.getEntitlementTemplates(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
        return Users_InventoryApiFp.getUserInventories(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  userId: string; id: number; }, options: any = {}) {
        return Users_InventoryApiFp.getUserInventory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, options: any = {}) {
        return Users_InventoryApiFp.getUserInventoryLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
        return Users_InventoryApiFp.getUsersInventory(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, options: any = {}) {
        return Users_InventoryApiFp.grantUserEntitlement(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
        return Users_InventoryApiFp.updateEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> TEMPLATE_ADMIN
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, options: any = {}) {
        return Users_InventoryApiFp.updateEntitlementTemplate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, options: any = {}) {
        return Users_InventoryApiFp.updateUserInventoryBehaviorData(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill). <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, options: any = {}) {
        return Users_InventoryApiFp.updateUserInventoryExpires(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: InventoryStatusWrapper; }, options: any = {}) {
        return Users_InventoryApiFp.updateUserInventoryStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, options: any = {}) {
        return Users_InventoryApiFp.useUserEntitlementItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_InventoryApi - factory interface
 */
export const Users_InventoryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Adds an item to the user inventory
         * @param id The id of the user
         * @param userInventoryAddRequest The user inventory add request object
         */
        addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.addItemToUserInventory(params, configuration, options)(fetch, basePath);
        },
        /**
         * Useful for pre-check and accounts for all various buisness rules. <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN or owner
         * @summary Check for access to an item without consuming
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         */
        checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.checkUserEntitlementItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Create an entitlement item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param entitlementItem The entitlement item object
         */
        createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.createEntitlementItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Entitlement templates define a type of entitlement and the properties they have. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Create an entitlement template
         * @param template The entitlement template to be created
         */
        createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.createEntitlementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Delete an entitlement item
         * @param entitlementId The id of the entitlement
         */
        deleteEntitlementItem(params: {  entitlementId: number; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.deleteEntitlementItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects. <br><br><b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Delete an entitlement template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.deleteEntitlementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get a single entitlement item
         * @param entitlementId The id of the entitlement
         */
        getEntitlementItem(params: {  entitlementId: number; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getEntitlementItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary List and search entitlement items
         * @param filterTemplate Filter for entitlements using a specified template
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementItems(params: {  filterTemplate?: string; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getEntitlementItems(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary Get a single entitlement template
         * @param id The id of the template
         */
        getEntitlementTemplate(params: {  id: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getEntitlementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN or ACHIEVEMENTS_ADMIN
         * @summary List and search entitlement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getEntitlementTemplates(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
         * @summary List the user inventory entries for a given user
         * @param id The id of the user
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterItemId Filter by item id
         * @param filterUsername Filter by entries owned by the user with the specified username
         * @param filterGroup Filter by entries owned by the users in a given group, by unique name
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         */
        getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getUserInventories(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Get an inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         */
        getUserInventory(params: {  userId: string; id: number; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getUserInventory(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
         * @summary List the log entries for this inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getUserInventoryLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary List the user inventory entries for all users
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterItemId Filter by item id
         * @param filterUsername Filter by entries owned by the user with the specified username
         * @param filterGroup Filter by entries owned by the users in a given group, by unique name
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         */
        getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.getUsersInventory(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Grant an entitlement
         * @param userId The id of the user to grant the entitlement to
         * @param grantRequest grantRequest
         */
        grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.grantUserEntitlement(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Update an entitlement item
         * @param entitlementId The id of the entitlement
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param entitlementItem The entitlement item object
         */
        updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.updateEntitlementItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> TEMPLATE_ADMIN
         * @summary Update an entitlement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.updateEntitlementTemplate(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Set the behavior data for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param data The data map
         */
        updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.updateUserInventoryBehaviorData(params, configuration, options)(fetch, basePath);
        },
        /**
         * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill). <br><br><b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Set the expiration date
         * @param userId user_id
         * @param id The id of the user inventory
         * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
         */
        updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.updateUserInventoryExpires(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN
         * @summary Set the status for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param inventoryStatus The inventory status object
         */
        updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: InventoryStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.updateUserInventoryStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> INVENTORY_ADMIN or owner
         * @summary Use an item
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         * @param info Any additional info to add to the log about this use
         */
        useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, configuration: Configuration, options: any = {}) {
            return Users_InventoryApiFp.useUserEntitlementItem(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_RelationshipsApi - fetch parameter creator
 */
export const Users_RelationshipsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  relationship?: UserRelationshipResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  id: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_RelationshipsApi - functional programming interface
 */
export const Users_RelationshipsApiFp = {
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: { relationship?: UserRelationshipResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = Users_RelationshipsApiFetchParamCreator.createUserRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_RelationshipsApiFetchParamCreator.deleteUserRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: { id: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = Users_RelationshipsApiFetchParamCreator.getUserRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: { size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserRelationshipResource> {
        const fetchArgs = Users_RelationshipsApiFetchParamCreator.getUserRelationships(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: { id: number; relationship?: UserRelationshipResource;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = Users_RelationshipsApiFetchParamCreator.updateUserRelationship(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_RelationshipsApi - object-oriented interface
 */
export class Users_RelationshipsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  relationship?: UserRelationshipResource; }, options: any = {}) {
        return Users_RelationshipsApiFp.createUserRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  id: number; }, options: any = {}) {
        return Users_RelationshipsApiFp.deleteUserRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  id: number; }, options: any = {}) {
        return Users_RelationshipsApiFp.getUserRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return Users_RelationshipsApiFp.getUserRelationships(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, options: any = {}) {
        return Users_RelationshipsApiFp.updateUserRelationship(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_RelationshipsApi - factory interface
 */
export const Users_RelationshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
         * @summary Create a user relationship
         * @param relationship The new relationship
         */
        createUserRelationship(params: {  relationship?: UserRelationshipResource; }, configuration: Configuration, options: any = {}) {
            return Users_RelationshipsApiFp.createUserRelationship(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
         * @summary Delete a user relationship
         * @param id The id of the relationship
         */
        deleteUserRelationship(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Users_RelationshipsApiFp.deleteUserRelationship(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
         * @summary Get a user relationship
         * @param id The id of the relationship
         */
        getUserRelationship(params: {  id: number; }, configuration: Configuration, options: any = {}) {
            return Users_RelationshipsApiFp.getUserRelationship(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> RELATIONSHIPS_USER or RELATIONSHIPS_ADMIN
         * @summary Get a list of user relationships
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserRelationships(params: {  size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Users_RelationshipsApiFp.getUserRelationships(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> RELATIONSHIPS_ADMIN
         * @summary Update a user relationship
         * @param id The id of the relationship
         * @param relationship The new relationship
         */
        updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, configuration: Configuration, options: any = {}) {
            return Users_RelationshipsApiFp.updateUserRelationship(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Users_SubscriptionsApi - fetch parameter creator
 */
export const Users_SubscriptionsApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserSubscriptionDetails");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling getUserSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  userId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUsersSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling reactivateUserSubscription");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling reactivateUserSubscription");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/reactivate`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reactivateSubscriptionRequest"]) {
            fetchOptions.body = JSON.stringify(params["reactivateSubscriptionRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionBillDate");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionBillDate");
        }
        // verify required parameter "billDate" is set
        if (params["billDate"] == null) {
            throw new Error("Missing required parameter billDate when calling setSubscriptionBillDate");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/bill-date`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billDate"]) {
            fetchOptions.body = JSON.stringify(params["billDate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May send null to use floating default. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionPaymentMethod");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/payment-method`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethodId"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethodId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription
     */
    setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: SubscriptionStatusWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionStatus");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setSubscriptionStatus");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserSubscriptionPlan");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setUserSubscriptionPlan");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/plan`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["planId"]) {
            fetchOptions.body = JSON.stringify(params["planId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserSubscriptionPrice");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setUserSubscriptionPrice");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/price-override`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["the override details"]) {
            fetchOptions.body = JSON.stringify(params["the override details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Users_SubscriptionsApi - functional programming interface
 */
export const Users_SubscriptionsApiFp = {
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: { userId: number; inventoryId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InventorySubscriptionResource> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.getUserSubscriptionDetails(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: { userId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<InventorySubscriptionResource>> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.getUsersSubscriptionDetails(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: { userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.reactivateUserSubscription(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: { userId: number; inventoryId: number; billDate: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.setSubscriptionBillDate(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May send null to use floating default. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: { userId: number; inventoryId: number; paymentMethodId?: IntWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.setSubscriptionPaymentMethod(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription
     */
    setSubscriptionStatus(params: { userId: number; inventoryId: number; status: SubscriptionStatusWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.setSubscriptionStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: { userId: number; inventoryId: number; planId?: StringWrapper;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.setUserSubscriptionPlan(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: { userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Users_SubscriptionsApiFetchParamCreator.setUserSubscriptionPrice(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Users_SubscriptionsApi - object-oriented interface
 */
export class Users_SubscriptionsApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, options: any = {}) {
        return Users_SubscriptionsApiFp.getUserSubscriptionDetails(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  userId: number; }, options: any = {}) {
        return Users_SubscriptionsApiFp.getUsersSubscriptionDetails(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, options: any = {}) {
        return Users_SubscriptionsApiFp.reactivateUserSubscription(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, options: any = {}) {
        return Users_SubscriptionsApiFp.setSubscriptionBillDate(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * May send null to use floating default. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, options: any = {}) {
        return Users_SubscriptionsApiFp.setSubscriptionPaymentMethod(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription
     */
    setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: SubscriptionStatusWrapper; }, options: any = {}) {
        return Users_SubscriptionsApiFp.setSubscriptionStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, options: any = {}) {
        return Users_SubscriptionsApiFp.setUserSubscriptionPlan(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, options: any = {}) {
        return Users_SubscriptionsApiFp.setUserSubscriptionPrice(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Users_SubscriptionsApi - factory interface
 */
export const Users_SubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
         * @summary Get details about a user's subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         */
        getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.getUserSubscriptionDetails(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
         * @summary Get details about a user's subscriptions
         * @param userId The id of the user
         */
        getUsersSubscriptionDetails(params: {  userId: number; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.getUsersSubscriptionDetails(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
         * @summary Reactivate a subscription and charge fee
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
         */
        reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.reactivateUserSubscription(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
         * @summary Set a new date to bill a subscription on
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param billDate The new bill date. Unix timestamp in seconds
         */
        setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.setSubscriptionBillDate(params, configuration, options)(fetch, basePath);
        },
        /**
         * May send null to use floating default. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
         * @summary Set the payment method to use for a subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param paymentMethodId The id of the payment method
         */
        setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.setSubscriptionPaymentMethod(params, configuration, options)(fetch, basePath);
        },
        /**
         * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN or owner
         * @summary Set the status of a subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param status The new status for the subscription
         */
        setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: SubscriptionStatusWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.setSubscriptionStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
         * @summary Set a new subscription plan for a user
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param planId The id of the new plan. Must be from the same subscription
         */
        setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.setUserSubscriptionPlan(params, configuration, options)(fetch, basePath);
        },
        /**
         * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint. <br><br><b>Permissions Needed:</b> USERS_SUBSCRIPTIONS_ADMIN
         * @summary Set a new subscription price for a user
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param the override details override
         */
        setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, configuration: Configuration, options: any = {}) {
            return Users_SubscriptionsApiFp.setUserSubscriptionPrice(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Util_BatchApi - fetch parameter creator
 */
export const Util_BatchApiFetchParamCreator = {
    /**
     * Tokens expire in 24 hours. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: {  token: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling getBatch");
        }
        const baseUrl = `/batch/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service. <br><br><b>Permissions Needed:</b> ANY
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  batch?: Batch; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/batch`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["batch"]) {
            fetchOptions.body = JSON.stringify(params["batch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Util_BatchApi - functional programming interface
 */
export const Util_BatchApiFp = {
    /**
     * Tokens expire in 24 hours. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: { token: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BatchReturn>> {
        const fetchArgs = Util_BatchApiFetchParamCreator.getBatch(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service. <br><br><b>Permissions Needed:</b> ANY
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: { batch?: Batch;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BatchReturn>> {
        const fetchArgs = Util_BatchApiFetchParamCreator.sendBatch(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Util_BatchApi - object-oriented interface
 */
export class Util_BatchApi extends BaseAPI {
    /**
     * Tokens expire in 24 hours. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: {  token: string; }, options: any = {}) {
        return Util_BatchApiFp.getBatch(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service. <br><br><b>Permissions Needed:</b> ANY
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  batch?: Batch; }, options: any = {}) {
        return Util_BatchApiFp.sendBatch(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Util_BatchApi - factory interface
 */
export const Util_BatchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Tokens expire in 24 hours. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get batch result with token
         * @param token token
         */
        getBatch(params: {  token: string; }, configuration: Configuration, options: any = {}) {
            return Util_BatchApiFp.getBatch(params, configuration, options)(fetch, basePath);
        },
        /**
         * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service. <br><br><b>Permissions Needed:</b> ANY
         * @summary Request to run API call given the method, content type, path url, and body of request
         * @param batch The batch object
         */
        sendBatch(params: {  batch?: Batch; }, configuration: Configuration, options: any = {}) {
            return Util_BatchApiFp.sendBatch(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Util_HealthApi - fetch parameter creator
 */
export const Util_HealthApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get health info
     */
    getHealth(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/health`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Util_HealthApi - functional programming interface
 */
export const Util_HealthApiFp = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get health info
     */
    getHealth(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Util_HealthApiFetchParamCreator.getHealth(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Util_HealthApi - object-oriented interface
 */
export class Util_HealthApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get health info
     */
    getHealth(options: any = {}) {
        return Util_HealthApiFp.getHealth(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Util_HealthApi - factory interface
 */
export const Util_HealthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get health info
         */
        getHealth(configuration: Configuration, options: any = {}) {
            return Util_HealthApiFp.getHealth(configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Util_MaintenanceApi - fetch parameter creator
 */
export const Util_MaintenanceApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Delete maintenance info
     */
    deleteMaintenance(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get current maintenance info. 404 if no maintenance. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get current maintenance info
     */
    getMaintenance(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  maintenance?: Maintenance; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  maintenance?: Maintenance; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Util_MaintenanceApi - functional programming interface
 */
export const Util_MaintenanceApiFp = {
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Delete maintenance info
     */
    deleteMaintenance(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Util_MaintenanceApiFetchParamCreator.deleteMaintenance(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get current maintenance info. 404 if no maintenance. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get current maintenance info
     */
    getMaintenance(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Maintenance> {
        const fetchArgs = Util_MaintenanceApiFetchParamCreator.getMaintenance(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: { maintenance?: Maintenance;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Util_MaintenanceApiFetchParamCreator.setMaintenance(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: { maintenance?: Maintenance;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = Util_MaintenanceApiFetchParamCreator.updateMaintenance(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Util_MaintenanceApi - object-oriented interface
 */
export class Util_MaintenanceApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Delete maintenance info
     */
    deleteMaintenance(options: any = {}) {
        return Util_MaintenanceApiFp.deleteMaintenance(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get current maintenance info. 404 if no maintenance. <br><br><b>Permissions Needed:</b> ANY
     * @summary Get current maintenance info
     */
    getMaintenance(options: any = {}) {
        return Util_MaintenanceApiFp.getMaintenance(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
        return Util_MaintenanceApiFp.setMaintenance(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
        return Util_MaintenanceApiFp.updateMaintenance(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Util_MaintenanceApi - factory interface
 */
export const Util_MaintenanceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
         * @summary Delete maintenance info
         */
        deleteMaintenance(configuration: Configuration, options: any = {}) {
            return Util_MaintenanceApiFp.deleteMaintenance(configuration, options)(fetch, basePath);
        },
        /**
         * Get current maintenance info. 404 if no maintenance. <br><br><b>Permissions Needed:</b> ANY
         * @summary Get current maintenance info
         */
        getMaintenance(configuration: Configuration, options: any = {}) {
            return Util_MaintenanceApiFp.getMaintenance(configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
         * @summary Set current maintenance info
         * @param maintenance The maintenance object
         */
        setMaintenance(params: {  maintenance?: Maintenance; }, configuration: Configuration, options: any = {}) {
            return Util_MaintenanceApiFp.setMaintenance(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> MAINTENANCE_ADMIN
         * @summary Update current maintenance info
         * @param maintenance The maintenance object
         */
        updateMaintenance(params: {  maintenance?: Maintenance; }, configuration: Configuration, options: any = {}) {
            return Util_MaintenanceApiFp.updateMaintenance(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Util_SecurityApi - fetch parameter creator
 */
export const Util_SecurityApiFetchParamCreator = {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available. <br><br><b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/security/country-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["userId"] !== undefined) {
            urlObj.query["user_id"] = params["userId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * <b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Util_SecurityApi - functional programming interface
 */
export const Util_SecurityApiFp = {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available. <br><br><b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: { userId?: number; size?: number; page?: number; order?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceLocationLogResource> {
        const fetchArgs = Util_SecurityApiFetchParamCreator.getUserLocationLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * <b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TokenDetailsResource> {
        const fetchArgs = Util_SecurityApiFetchParamCreator.getUserTokenDetails(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Util_SecurityApi - object-oriented interface
 */
export class Util_SecurityApi extends BaseAPI {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available. <br><br><b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return Util_SecurityApiFp.getUserLocationLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * <b>Permissions Needed:</b> SECURITY_ADMIN
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(options: any = {}) {
        return Util_SecurityApiFp.getUserTokenDetails(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Util_SecurityApi - factory interface
 */
export const Util_SecurityApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A log entry is recorded everytime a user requests a new token. Standard pagination available. <br><br><b>Permissions Needed:</b> SECURITY_ADMIN
         * @summary Returns the authentication log for a user
         * @param userId The user id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, configuration: Configuration, options: any = {}) {
            return Util_SecurityApiFp.getUserLocationLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * <b>Permissions Needed:</b> SECURITY_ADMIN
         * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
         */
        getUserTokenDetails(configuration: Configuration, options: any = {}) {
            return Util_SecurityApiFp.getUserTokenDetails(configuration, options)(fetch, basePath);
        },
    };
};


/**
 * Util_VersionApi - fetch parameter creator
 */
export const Util_VersionApiFetchParamCreator = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get current version info
     */
    getVersion(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/version`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (oauth2_client_credentials_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }
        // authentication (oauth2_password_grant) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * Util_VersionApi - functional programming interface
 */
export const Util_VersionApiFp = {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get current version info
     */
    getVersion(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Version> {
        const fetchArgs = Util_VersionApiFetchParamCreator.getVersion(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * Util_VersionApi - object-oriented interface
 */
export class Util_VersionApi extends BaseAPI {
    /**
     * <b>Permissions Needed:</b> ANY
     * @summary Get current version info
     */
    getVersion(options: any = {}) {
        return Util_VersionApiFp.getVersion(this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * Util_VersionApi - factory interface
 */
export const Util_VersionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * <b>Permissions Needed:</b> ANY
         * @summary Get current version info
         */
        getVersion(configuration: Configuration, options: any = {}) {
            return Util_VersionApiFp.getVersion(configuration, options)(fetch, basePath);
        },
    };
};

