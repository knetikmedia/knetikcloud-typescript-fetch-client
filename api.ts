/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

import { Configuration } from "./configuration";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://sandbox.knetikcloud.com".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    public configuration: Configuration;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH, configuration: Configuration = new Configuration()) {
        this.basePath = basePath;
        this.fetch = fetch;
        this.configuration = configuration;
    }
};

export interface AchievementDefinitionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this resource type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The description of the achievement. Must be at least 2 characters in length.
     */
    "description"?: string;
    /**
     * Whether the achievement is hidden from the user
     */
    "hidden": boolean;
    /**
     * The name of the achievement. Must be at least 6 characters in length. IMMUTABLE
     */
    "name": string;
    /**
     * The required progress for the achievement definition
     */
    "requiredProgress": number;
    /**
     * The id of the rule generated for this achievement
     */
    "ruleId"?: string;
    /**
     * The tags for the achievement definition
     */
    "tags"?: Array<string>;
    /**
     * An achievement template this achievement is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The name of the trigger event associated with this achievement
     */
    "triggerEventName"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ActionResource {
    /**
     * The category the action is in. All customer specific actions are in the 'custom' category
     */
    "category"?: ActionResourceCategoryEnum;
    /**
     * The description of the action
     */
    "description": string;
    /**
     * The name of the action. Used as the unique id for reference
     */
    "name": string;
    /**
     * A list of tags for searching
     */
    "tags"?: Array<string>;
    /**
     * The variables required for the action
     */
    "variables": Array<ActionVariableResource>;
}

export type ActionResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "device" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface ActionVariableResource {
    /**
     * The name of the variable
     */
    "name": string;
    /**
     * Whether this variable is optional and can be left out/null
     */
    "optional": boolean;
    /**
     * The type of the variable (see variable type endpoint for list)
     */
    "type": string;
}

export interface ActivityEntitlementResource {
    /**
     * The ISO3 currency code the price is in, if available
     */
    "currencyCode"?: string;
    /**
     * The id of the entitlement item
     */
    "itemId": number;
    /**
     * The name of the entitlement item
     */
    "name"?: string;
    /**
     * The price of the sku, if available
     */
    "price"?: number;
    /**
     * The sku id, if available. If multiple are available, then first one is returned
     */
    "sku"?: string;
}

export interface ActivityOccurrenceCreationFailure {
    /**
     * The details of each user's entry, or just the current user's if not run with ACTIVITIES_ADMIN permission
     */
    "userResults"?: Array<ActivityOccurrenceJoinResult>;
}

export interface ActivityOccurrenceJoinResult {
    /**
     * The details on the entitlement object needed to enter the occurrence (if any)
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * Zero if the user was/could be added to the occurrence. Jsapi error code indicating the reason of the failure otherwise
     */
    "errorCode": number;
    /**
     * An error message if failure
     */
    "message"?: string;
    /**
     * The user's id
     */
    "userId": number;
}

/**
 * A occurrence of an activity (the actual game for example). Used to track scores, participants, and provide settings
 */
export interface ActivityOccurrenceResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge activity (as part of the event, required if eventId set)
     */
    "challengeActivityId"?: number;
    /**
     * The date this occurrence was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The entitlement item required to enter the occurrence. Required if not part of an event. Must come from the set of entitlement items listed in the activity
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The id of the event
     */
    "eventId"?: number;
    /**
     * The id of the activity occurrence
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: ActivityOccurrenceResourceRewardStatusEnum;
    /**
     * The values selected from the available settings defined for the activity. Ex: difficulty: hard. Can be left out if the activity is played during an event and the settings are already set at the event level. Ex: every monday, difficulty: hard, number of questions: 10, category: sport. Otherwise, the set must exactly match those of the activity.
     */
    "settings"?: Array<SelectedSettingResource>;
    /**
     * Whether this occurrence will be ran as a simulation. Simulations will not be rewarded. Useful for bot play or trials
     */
    "simulated"?: boolean;
    /**
     * The date this occurrence was started, unix timestamp in seconds. null if not yet started
     */
    "startDate"?: number;
    /**
     * The current status of the occurrence (default: OPEN)
     */
    "status"?: ActivityOccurrenceResourceStatusEnum;
    /**
     * The date this occurrence was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The list of users participating in this occurrence. Can only be set directly with ACTIVITIES_ADMIN permission
     */
    "users"?: Array<ActivityUserResource>;
}

export type ActivityOccurrenceResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export type ActivityOccurrenceResourceStatusEnum = "SETUP" | "OPEN" | "PLAYING" | "FINISHED" | "ABANDONED";
export interface ActivityOccurrenceResults {
    /**
     * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
     */
    "users": Array<UserActivityResults>;
}

export interface ActivityOccurrenceResultsResource {
    /**
     * The game results for each user. Include all users that played (paid to get in) even if they were eliminated without a result. A null metric is allowed
     */
    "users": Array<UserActivityResultsResource>;
}

/**
 * Represents an activity that can be parameterized and tracked through metrics (scores, etc)
 */
export interface ActivityResource {
    /**
     * A map of additional properties keyed on the property name. Used to further describe an activity. While settings will vary from one activity occurrence (a game) to another, additional properties are shared by all the occurrences of this activity. Ex: Activity Logo, Disclaimer, Greeting, etc. Validated against template if one exists for activities
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The list of items that can be used for entitlement (wager amounts/etc)
     */
    "entitlements"?: Array<ActivityEntitlementResource>;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * Define what parameters are required/available to start and run an activity. For example: Difficulty, Number of Questions, Character name, Avatar, Duration, etc. Not populated when getting listing
     */
    "settings"?: Array<AvailableSettingResource>;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * An activity template this activity is validated against (private). May be null and no validation of additional_properties will be done
     */
    "templateId"?: string;
    /**
     * The type of the activity
     */
    "type": string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ActivityUserResource {
    /**
     * Whether this user is the 'host' of the occurrence and has increased access to settings/etc (default: false)
     */
    "host"?: boolean;
    /**
     * The id of the activity user entry
     */
    "id"?: number;
    /**
     * The date this user last joined the occurrence, unix timestamp in seconds
     */
    "joinedDate"?: number;
    /**
     * The date this user last left the occurrence, unix timestamp in seconds. Null if still present
     */
    "leftDate"?: number;
    /**
     * The metric for the user's results, after the game is over
     */
    "metric"?: MetricResource;
    /**
     * The current status of the user in the occurrence (default: present)
     */
    "status"?: ActivityUserResourceStatusEnum;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export type ActivityUserResourceStatusEnum = "present" | "ready" | "left" | "surrendered" | "disconnected";
export interface AddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface AggregateCountResource {
    "count"?: number;
    "date"?: string;
}

export interface AggregateInvoiceReportResource {
    "count"?: number;
    "date"?: string;
    "revenue"?: number;
    "userCount"?: number;
}

export interface AmazonS3Activity {
    /**
     * S3 action (i.e., 'PUT') associated with the activity
     */
    "action"?: string;
    /**
     * URL for accessing the resource via CDN if configured (will default to the main url if not)
     */
    "cdnUrl"?: string;
    /**
     * Date the resource was created in S3
     */
    "createdDate"?: number;
    /**
     * Name of the file being processed as a resource in S3
     */
    "filename"?: string;
    /**
     * Unique id of the S3 activity
     */
    "id"?: number;
    /**
     * S3 object key for the resource
     */
    "objectKey"?: string;
    /**
     * URL for posting and later accessing the S3 resource
     */
    "url"?: string;
    /**
     * The id of the user that created this S3 activity
     */
    "userId"?: number;
}

export interface AnswerResource {
    /**
     * The answer to the question. Different 'type' values indicate different structures as the answer may be test, image, etc. See information on additional properties for the list and their structures
     */
    "answer": Property;
    /**
     * Whether the answer is correct or not
     */
    "correct": boolean;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
}

export interface ApplyPaymentRequest {
    /**
     * The id of the local invoice being paid.
     */
    "invoiceId": number;
    /**
     * The encoded receipt string from Apple's services.
     */
    "receipt": string;
    /**
     * The id of the specific transaction from Apple's services.
     */
    "transactionId": string;
}

export interface ArticleResource {
    /**
     * Whether the article is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The body of the article
     */
    "body": string;
    /**
     * The category for the article
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the article
     */
    "id"?: string;
    /**
     * The tags for the article
     */
    "tags"?: Array<string>;
    /**
     * An article template this article is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The title of the article
     */
    "title": string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ArtistResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * YYYY/MM/DD when this artist was born
     */
    "born"?: string;
    /**
     * The current number of contributions the artist has made
     */
    "contributionCount"?: number;
    /**
     * The list of media this artist has contributed to as well as role(s) during contribution.  Use media endpoint to add contributions
     */
    "contributions"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * YYYY/MM/DD when this artist died
     */
    "died"?: string;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order priority ofr the artist.  Default 100
     */
    "priority"?: number;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * An artist template this artist is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

/**
 * The definition of an activity parameters: ex: difficulty level
 */
export interface AvailableSettingResource {
    /**
     * Whether the setting is advanced. Default: false
     */
    "advancedOption"?: boolean;
    /**
     * The default value of the setting (must be in options array). Ex: easy
     */
    "defaultValue": string;
    /**
     * The description of the setting: Ex: Choose the difficulty level to show more or less complicated questions (for a trivia activity)
     */
    "description"?: string;
    /**
     * The unique ID for the setting: Ex: difficulty
     */
    "key": string;
    /**
     * The textual name of the setting: Ex: Difficulty Level
     */
    "name": string;
    /**
     * The set of options available for this setting, Ex: easy, medium, hard
     */
    "options": Array<SettingOption>;
}

export interface BareActivityResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * Details about how to launch the activity
     */
    "launch"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * Whether this activity is a template for other activities. Default: false
     */
    "template"?: boolean;
    /**
     * The type of the activity
     */
    "type": string;
    /**
     * The unique key (for static reference in code) of the activity
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface BareChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * The id of the challenge
     */
    "challengeId": number;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
}

export interface Batch {
    /**
     * The list of batch requests
     */
    "batch": Array<BatchRequest>;
    /**
     * The amount of time before a request token is returned instead of the batch result.  Default is 60.  Range is 0-300
     */
    "timeout": number;
}

export interface BatchRequest {
    /**
     * The request body as would be passed to the URI
     */
    "body": any;
    /**
     * Content type used, Ex:(application/json)
     */
    "contentType": string;
    /**
     * The HTTP method used, Ex: (GET)
     */
    "method": string;
    /**
     * Time in seconds before process will timeout.  Default is 60.  Range is 1-300
     */
    "timeout": number;
    /**
     * The oauth token only
     */
    "token"?: string;
    /**
     * Full URI of REST call
     */
    "uri": string;
}

export interface BatchResult {
    /**
     * List of batch responses.  Returns in the order requested
     */
    "batchReturn"?: Array<BatchReturn>;
    /**
     * The date the batch call started processing
     */
    "createdDate"?: number;
    /**
     * The token to use at the /batch/{token} endpoint if the request times out
     */
    "id"?: string;
    /**
     * The date the batch call finished processing
     */
    "updatedDate"?: number;
}

export interface BatchReturn {
    /**
     * The result body
     */
    "body"?: any;
    /**
     * The HTTP response code
     */
    "code"?: number;
    /**
     * Full URI of REST call
     */
    "uri"?: string;
}

export interface Behavior {
    "description"?: string;
    /**
     * Used for polymorphic type recognition and thus must match an expected type with additional properties
     */
    "typeHint"?: string;
}

export interface BehaviorDefinitionResource {
    /**
     * Description of the behavior
     */
    "description"?: string;
    /**
     * Pre-requisite behaviors that an item must have in order to also have this behavior
     */
    "prerequisiteBehaviors"?: Array<Behavior>;
    /**
     * Configurable properties of the behavior
     */
    "properties": Array<PropertyFieldResource>;
    /**
     * The behavior type
     */
    "typeHint": string;
}

export interface BillingReport {
    "created"?: number;
    "id"?: string;
    "lastKnownFailures"?: Array<string>;
    "statistics"?: { [key: string]: number; };
}

export interface BooleanResource {
    "value"?: boolean;
}

export interface BreCategoryResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The name of the category. Serves as the unique id
     */
    "name"?: string;
    /**
     * A template this BRE category is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface BreEvent {
    /**
     * The event name of the trigger to be fired
     */
    "eventName": string;
    /**
     * The parameters to the event. A Map (assosiative array) with a key for each trigger parameter name and a corrosponding value.
     */
    "params": any;
}

export interface BreEventLog {
    /**
     * The customer of the BRE event log
     */
    "customer"?: string;
    /**
     * The event id of the BRE event log
     */
    "eventId"?: string;
    /**
     * The event name of the BRE event log
     */
    "eventName"?: string;
    /**
     * The event start date of the BRE event log
     */
    "eventStartDate"?: number;
    /**
     * The id of the BRE event log
     */
    "id"?: string;
    /**
     * The event paramters of the BRE event log
     */
    "parameters"?: any;
    /**
     * The rules of the BRE event log
     */
    "rules"?: Array<BreRuleLog>;
}

export interface BreGlobalResource {
    /**
     * A human readable description for display in admin pages
     */
    "description"?: string;
    /**
     * The id of the global definition. Default is a random guid. Cannot be updated
     */
    "id"?: string;
    /**
     * The key for the global. Must be unique when combined with scope names. Usually a single descriptive word like 'purchases' or 'logins'
     */
    "key": string;
    /**
     * A human readable name for display in admin pages
     */
    "name"?: string;
    /**
     * A list of scoping parameters. Allows the global to have a different value in different context such as a count of purchases for each user (by putting a 'user' scope in this list). When using this global in a rule these scopes will need to be mapped with an expression to provide a value, similar to the parameters in an action
     */
    "scopes"?: Array<BreGlobalScopeDefinition>;
    /**
     * Where this global came from. System globals cannot be removed or updated
     */
    "systemGlobal"?: boolean;
    /**
     * The variable type the global stores. See the See Bre Variables enpoint for list
     */
    "type": string;
}

export interface BreGlobalScopeDefinition {
    /**
     * The name of the scoping parameter. This is used as the unique identifier of this scope
     */
    "name": string;
    /**
     * The variable type of this scoping parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreRule {
    /**
     * A list of actions to execute, and the mapping for their parameters, when the rule runs. Minimum 1
     */
    "actions": ActionResource;
    /**
     * A condition expression that must be met in a given event for the rule to run. Empty to always run
     */
    "condition"?: PredicateOperation;
    /**
     * The condition as a readable string. Filled in by the system from the condition
     */
    "conditionText"?: string;
    /**
     * The human readable description of the rule
     */
    "description"?: string;
    /**
     * Whether the rule is enabled to run (in conjunction with dates). Default true
     */
    "enabled"?: boolean;
    /**
     * The date the rule ceases to take effect, or null if never. Unix timestamp in seconds
     */
    "endDate"?: number;
    /**
     * The event name of the trigger this rule runs for. Affects which parameters are available
     */
    "eventName": string;
    /**
     * The id of the rule for later references. If left null a random guid will be generated. Must be unique. Cannot be changed
     */
    "id"?: string;
    /**
     * The human readable name of the rule
     */
    "name": string;
    /**
     * Used to sort rules to control the order they run in. Larger numbered sort values run first.  Default 500
     */
    "sort"?: number;
    /**
     * The date the rule begins to take effect, or null if always. Unix timestamp in seconds
     */
    "startDate"?: number;
    /**
     * Whether the rule is a default part of the system. System rules cannot be edited or deleted, but may be disabled
     */
    "systemRule"?: boolean;
}

export interface BreRuleLog {
    /**
     * Whether the rule ran
     */
    "ran"?: boolean;
    /**
     * The reason for the rule
     */
    "reason"?: string;
    /**
     * The end date of the rule in seconds
     */
    "ruleEndDate"?: number;
    /**
     * The id of the rule
     */
    "ruleId"?: string;
    /**
     * The name of the rule
     */
    "ruleName"?: string;
    /**
     * The start date of the rule in seconds
     */
    "ruleStartDate"?: number;
}

export interface BreTriggerParameterDefinition {
    /**
     * The name of the parameter. This is used as the unique identifier of this parameter
     */
    "name": string;
    /**
     * Whether this parameter can be left off when firing the event. Default false
     */
    "optional"?: boolean;
    /**
     * The variable type of this parameter. See Bre Variables endpoint for list
     */
    "type": string;
}

export interface BreTriggerResource {
    /**
     * The category this trigger belongs to. See endpoints for related asset information. All new triggers are in category 'custom'
     */
    "category"?: BreTriggerResourceCategoryEnum;
    /**
     * The unique name for the event. This serves as the unique identifier. Cannot be changed after creation
     */
    "eventName": string;
    /**
     * A list of parameters that will be sent with the event when the trigger is fired. These must be included in the event and match the described types
     */
    "parameters"?: Array<BreTriggerParameterDefinition>;
    /**
     * Where this trigger came from. System triggers cannot be removed or updated
     */
    "systemTrigger"?: boolean;
    /**
     * A list of tags for filtering
     */
    "tags"?: Array<string>;
    /**
     * A description of the trigger
     */
    "triggerDescription": string;
    /**
     * A human readable name for this trigger
     */
    "triggerName": string;
}

export type BreTriggerResourceCategoryEnum = "achievement" | "behavior" | "comment" | "disposition" | "device" | "entitlement" | "friends" | "fulfillment" | "gamification" | "inventory" | "invoice" | "media" | "scheduler" | "store" | "subscription" | "user" | "wallet" | "custom" | "challenge" | "activity" | "campaign" | "event";
export interface BroadcastableEvent {
    "client"?: string;
    "customer"?: string;
    "doNotBroadcast"?: boolean;
    "section"?: string;
    "source"?: any;
    "specifics"?: string;
    "synchronous"?: boolean;
    "timestamp"?: number;
    /**
     * The type of the event. Used for polymorphic type recognition and thus must match an expected type
     */
    "type": string;
}

export interface BundledSku {
    /**
     * The amount this item will cost inside the bundle instead of its regular price
     */
    "priceOverride"?: number;
    /**
     * The quantity of this item within the bundle
     */
    "quantity": number;
    /**
     * The stock keeping unit (SKU) for an item included in the bundle
     */
    "sku": string;
}

export interface CampaignResource {
    /**
     * Whether the campaign is active or not.  Defaults to false
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The name of the next challenge coming up
     */
    "nextChallenge"?: string;
    /**
     * The date/time of the next challenge coming up
     */
    "nextChallengeDate"?: number;
    /**
     * The rewards to give at the end of the campaign. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * Indicate if the rewards have been given out already
     */
    "rewardStatus"?: CampaignResourceRewardStatusEnum;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * A campaign template this campaign is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type CampaignResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface Cart {
    "availableShippingOptions"?: Array<CartShippingOption>;
    "countryTax"?: number;
    "coupons"?: Array<CouponDefinition>;
    "created"?: number;
    "currencyCode"?: string;
    "discountTotal"?: number;
    "errorCode"?: number;
    "errorMessage"?: string;
    "grandTotal"?: number;
    "id"?: string;
    "invoiceId"?: number;
    "items"?: Array<CartLineItem>;
    "owner"?: number;
    "selectedShippingOptions"?: Array<CartShippingOption>;
    "shippable"?: boolean;
    "shippingAddress"?: CartShippingAddressRequest;
    "shippingCost"?: number;
    "stateTax"?: number;
    "status"?: CartStatusEnum;
    "subtotal"?: number;
    "updated"?: number;
}

export type CartStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CartItemRequest {
    /**
     * The affiliate key of the item
     */
    "affiliateKey"?: string;
    /**
     * The catalog SKU of the item
     */
    "catalogSku": string;
    /**
     * Allows to override the price of an item, if the behavior configuration permits it
     */
    "priceOverride": number;
    /**
     * The quantity of the item
     */
    "quantity": number;
}

export interface CartLineItem {
    "currencyCode"?: string;
    "description"?: string;
    "discount"?: Discount;
    "lineTotal"?: number;
    "name"?: string;
    "originalLineTotal"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "storeItemId"?: number;
    "tags"?: Array<string>;
    "thumbUrl"?: string;
    "uniqueKey"?: string;
    "unitPrice"?: number;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartShippableResponse {
    /**
     * The id of the cart
     */
    "cartId"?: number;
    /**
     * Whether the item is shippable
     */
    "shippable"?: boolean;
}

export interface CartShippingAddressRequest {
    /**
     * The city of the user
     */
    "city"?: string;
    /**
     * The country code of the user
     */
    "countryCodeIso3"?: string;
    /**
     * The email of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    "namePrefix"?: string;
    /**
     * The order notes the user
     */
    "orderNotes"?: string;
    /**
     * The phone number of the user
     */
    "phoneNumber"?: string;
    /**
     * The postal state code of the user
     */
    "postalStateCode"?: string;
    /**
     * The shipping address of the user, first line
     */
    "shippingAddressLine1"?: string;
    /**
     * The shipping address of the user, second line
     */
    "shippingAddressLine2"?: string;
    /**
     * The zipcode of the user
     */
    "zip"?: string;
}

export interface CartShippingOption {
    "currencyCode"?: string;
    "description"?: string;
    "name"?: string;
    "originalPrice"?: number;
    "price"?: number;
    "shippingItemId"?: number;
    "sku"?: string;
    "taxable"?: boolean;
    "vendorId"?: number;
    "vendorName"?: string;
}

export interface CartSummary {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique id code for the currency used in the cart
     */
    "currencyCode"?: string;
    /**
     * The grand total for the cart
     */
    "grandTotal"?: number;
    /**
     * The unique ID for the cart
     */
    "id"?: string;
    /**
     * The ID of the invoice associated with this cart
     */
    "invoiceId"?: number;
    /**
     * The number of items in the cart
     */
    "itemsInCart"?: number;
    /**
     * The status of the cart
     */
    "status"?: CartSummaryStatusEnum;
    /**
     * The subtotal of all items in the cart
     */
    "subtotal"?: number;
}

export type CartSummaryStatusEnum = "active" | "processing" | "closed" | "onhold";
export interface CatalogSale {
    /**
     * The iso3 code for the currency for this discountValue.  The sku purchased will have to match for it this sale to apply
     */
    "currencyCode": string;
    /**
     * The way in which the price is reduced. 'value' means subtracting directly, 'percentage' means subtracting by the price times the discountValue (1.0 == 100%)
     */
    "discountType": CatalogSaleDiscountTypeEnum;
    /**
     * The amount deducted from the price, in the same currencyCode as the item
     */
    "discountValue"?: number;
    /**
     * The id of the sale
     */
    "id"?: number;
    /**
     * The id of the item this sale applies to.  Leave null to use other filters
     */
    "item"?: number;
    /**
     * The long description of the sale
     */
    "longDescription"?: string;
    /**
     * The name of the sale.  Max 40 characters
     */
    "name": string;
    /**
     * The date the sale ends, null for never.  Unix timestamp in seconds
     */
    "saleEndDate"?: number;
    /**
     * The date the sale begins.  Unix timestamp in seconds
     */
    "saleStartDate": number;
    /**
     * The short description of the sale.  Max 140 characters
     */
    "shortDescription"?: string;
    /**
     * The tag this sale applies to.  Leave null to skip this filter (applies to all tags)
     */
    "tag"?: string;
    /**
     * The id of the vendor this sale applies to.  Leave null to skip this filter (applies to all vendors)
     */
    "vendor"?: number;
}

export type CatalogSaleDiscountTypeEnum = "value" | "percentage";
export interface CategoryResource {
    /**
     * Whether the category is currently active. If not, it and its questions will be filtered out.
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The unique ID for this category
     */
    "id"?: string;
    /**
     * The name of this category. Cannot be blank
     */
    "name": string;
    /**
     * A category template this category is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface ChallengeActivityResource {
    /**
     * The id of the activity
     */
    "activityId": number;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * The entitlement item needed to participate in the activity as part of this event. Null indicates free entry. When creating/updating only id is used. Item must be pre-existing
     */
    "entitlement"?: ActivityEntitlementResource;
    /**
     * The unique ID for this resource
     */
    "id"?: number;
    /**
     * The rewards to give at the end of each occurence of the activity. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The list of settings and the select options
     */
    "settings"?: Array<SelectedSettingResource>;
    /**
     * A challenge activity template this challenge activity is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
}

export interface ChallengeEventParticipantResource {
    /**
     * The email address of the user
     */
    "email"?: string;
    /**
     * The full name of the user
     */
    "fullname"?: string;
    /**
     * The user's score
     */
    "score"?: number;
    /**
     * The id of the user
     */
    "userId"?: number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface ChallengeEventResource {
    /**
     * The id of the challenge
     */
    "challengeId"?: number;
    /**
     * The end date in seconds
     */
    "endDate"?: number;
    /**
     * The id of the challenge event
     */
    "id"?: number;
    /**
     * Indicate if the rewards have been given out already 
     */
    "rewardStatus"?: ChallengeEventResourceRewardStatusEnum;
    /**
     * The start date in seconds
     */
    "startDate"?: number;
}

export type ChallengeEventResourceRewardStatusEnum = "pending" | "failed" | "complete" | "partial";
export interface ChallengeResource {
    /**
     * The number of activities allowed to this challenge
     */
    "activities"?: number;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The id of the campaign this challenge is a part of. The challenge must be tied to an active campaign before it will spawn events
     */
    "campaignId"?: number;
    /**
     * The ID of the original challenge it was copied from
     */
    "copyOf"?: number;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The end date of this challenge in seconds since epoch. required if part of a campaign
     */
    "endDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The strategy for calculating the leaderboard. Defaults to highest score. Value MUST come from the list of available strategies from the Leaderboard Service.
     */
    "leaderboardStrategy"?: string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The next date this challenge will be occur in seconds since epoch
     */
    "nextEventDate"?: number;
    /**
     * The number of minutes minimum to wait at the end of this challenge before running rewards, to allow activities to complete
     */
    "rewardLagMinutes"?: number;
    /**
     * The rewards to give at the end of the challenge. When creating/updating only id is used. Reward set must be pre-existing
     */
    "rewardSet"?: RewardSetResource;
    /**
     * The repeat schedule for the challenge
     */
    "schedule"?: Schedule;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The start date of this challenge in seconds since epoch. required if part of a campaign
     */
    "startDate"?: number;
    /**
     * A challenge template this challenge is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface ClientResource {
    /**
     * The expiration time of an initial oauth token in seconds
     */
    "accessTokenValiditySeconds"?: number;
    /**
     * The client_id field of the oauth token request
     */
    "clientKey": string;
    /**
     * The oauth grant type as in: password (username/password auth), client_credentials (server-to-server, private clients), refresh_token (to allow clients to refresh their initial token), facebook, google, etc) See documentation for a complete list. Use dedicated endpoint PUT /grant-types to edit this list
     */
    "grantTypes"?: Array<string>;
    /**
     * Generated unique ID for the client
     */
    "id"?: number;
    /**
     * Set to true if the client is public i.e the secret key can be secured
     */
    "isPublic"?: boolean;
    /**
     * Used to flag system clients that are not meant to be tinkered with
     */
    "locked"?: boolean;
    /**
     * The friendly name of the client
     */
    "name": string;
    /**
     * A redirection URL to use when granting access to third-parties (seldomly used)
     */
    "redirectUris"?: Array<string>;
    /**
     * The expiration time of a refresh oauth token in seconds
     */
    "refreshTokenValiditySeconds"?: number;
    /**
     * The client-secret field of the oauth request when creating a private client
     */
    "secret": string;
}

export interface CollectionCountry {
}

export interface Collectionstring {
}

export interface CommentResource {
    /**
     * The comment content of that resource
     */
    "content": string;
    /**
     * The type of object this comment applies to (ex: video, article, etc). Required when passed to /comments
     */
    "context"?: string;
    /**
     * The id of the object this comment applies to.  Required when passed to /comments
     */
    "contextId"?: number;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The summary of that resource
     */
    "summary"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The user who created the comment
     */
    "user"?: SimpleUserResource;
}

export interface CommentSearch {
    "content"?: string;
    "context"?: string;
    "contextId"?: number;
    "id"?: number;
    "ownerId"?: number;
    "ownerUsername"?: string;
}

export interface Config {
    /**
     * The description of the config.  Max 140 characters
     */
    "description"?: string;
    /**
     * The name of the config
     */
    "name": string;
    /**
     * Whether the config is public for viewing. True means that it can be publicly viewed by all. Default: false
     */
    "publicRead"?: boolean;
    /**
     * The value of the config
     */
    "value"?: string;
}

export interface ConfigLookupResource {
    "lookupKey"?: ExpressionResource;
    "type"?: string;
    "valueType"?: string;
}

export interface ConstantResource {
    "type"?: string;
    "value"?: any;
    "valueType"?: string;
}

export interface ContributionResource {
    /**
     * A reference to the contributing artist
     */
    "artist": SimpleReferenceResourcelong;
    /**
     * A reference to the media being contributed to
     */
    "media": SimpleReferenceResourcelong;
    /**
     * The nature of the contribution (role of the artist as in 'producer', 'performer', etc)
     */
    "role": string;
}

export interface Country {
    "id"?: number;
    "iso2"?: string;
    "iso3"?: string;
    "name"?: string;
}

export interface CountryResource {
    /**
     * The iso2 of the country
     */
    "iso2"?: string;
    /**
     * The iso3 of the country
     */
    "iso3"?: string;
    /**
     * The name of the country resource
     */
    "name"?: string;
}

export interface CountryTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface CouponDefinition {
    /**
     * A unique identifier for the discount. Can be used to remove the discount, and uniqueness within the cart will be enforced.
     */
    "code": string;
    /**
     * A description for the discount.
     */
    "description"?: string;
    /**
     * The type of discount in terms of how it deducts price.
     */
    "discountType": CouponDefinitionDiscountTypeEnum;
    /**
     * Whether this discount is exclusive and cannot be used in conjunction with other discounts/coupons. default=false
     */
    "exclusive"?: boolean;
    /**
     * For coupon_cart, a minimum total price that the cart must meet to be valid.
     */
    "maxDiscount"?: number;
    /**
     * The maximum number of items to count this discount for (not for cart_coupon).
     */
    "maxQuantity"?: number;
    /**
     * For coupon_cart, a minimum total price that the cart must meet to be valid.
     */
    "minCartTotal"?: number;
    /**
     * A name for the discount.
     */
    "name": string;
    /**
     * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
     */
    "selfExclusive"?: boolean;
    /**
     * The id of the item this discount applies to, which must be present in the cart. Applies if coupon_type_hint is coupon_single_item or coupon_voucher.
     */
    "targetItemId"?: number;
    /**
     * The type of discount in terms of what it applies to. coupon_cart applies to the cart as a whole, other types apply to specific items based on different criteria.
     */
    "type": CouponDefinitionTypeEnum;
    /**
     * A unique identifier string for the discount.
     */
    "uniqueKey": string;
    /**
     * Which tags this applies for (item must have at least one of them), if coupon_type is coupon_tag.
     */
    "validForTags"?: Array<string>;
    /**
     * The amount of the discount. If discount_type is value then this is the raw currency amount to remove. If discount_type is percentage then this will be multiplied by the cart total or item price to get the discount amount (0.5 is half price).
     */
    "value": number;
    /**
     * Which vendor this applies for, if coupon_type is coupon_vendor.
     */
    "vendorId"?: number;
}

export type CouponDefinitionDiscountTypeEnum = "value" | "percentage";
export type CouponDefinitionTypeEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
export interface CreateBillingAgreementRequest {
    /**
     * The endpoint URL to which PayPal should forward the user if they cancel (do not accept) the agreement
     */
    "cancelUrl": string;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept the agreement. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface CreatePayPalPaymentRequest {
    /**
     * The endpoint URL to which PayPal should forward the user to if they cancel the checkout process
     */
    "cancelUrl": string;
    /**
     * The ID of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL to which PayPal should forward the user after they accept. This endpoint will receive information needed for the next step
     */
    "returnUrl": string;
}

export interface CurrencyResource {
    /**
     * Whether the currency is active. Default true
     */
    "active"?: boolean;
    /**
     * The unique id code for the currency. Maximum 5 characters
     */
    "code": string;
    /**
     * The unix timestamp in seconds the currency was added to the system
     */
    "createdDate"?: number;
    /**
     * The decimal to multiply the system base currency (from config 'currency') to localize to this one. Should be 1 for the base currency itself.
     */
    "factor": number;
    /**
     * The url for an icon of the currency
     */
    "icon"?: string;
    /**
     * The name of the currency
     */
    "name": string;
    /**
     * The type of currency. Default 'real'
     */
    "type"?: CurrencyResourceTypeEnum;
    /**
     * The unix timestamp in seconds the currency was last updated in the system.
     */
    "updatedDate"?: number;
}

export type CurrencyResourceTypeEnum = "real" | "virtual";
export interface CustomerConfig {
    "aliases"?: string;
    "database"?: DatabaseConfig;
    "io"?: IOConfig;
    "name"?: string;
    "s3Config"?: S3Config;
}

export interface DatabaseConfig {
    "mongo"?: MongoDatabaseConfig;
    "sql"?: SqlDatabaseConfig;
}

export interface DateOperationResource {
    "args"?: Array<ExpressionResource>;
    "op"?: string;
    "type"?: string;
}

export interface DeltaResource {
    /**
     * The id of the category for question
     */
    "categoryId"?: string;
    /**
     * The media type of the question
     */
    "mediaType"?: string;
    /**
     * The id of the question
     */
    "questionId"?: string;
    /**
     * Whether the question was updated or removed
     */
    "state"?: DeltaResourceStateEnum;
    /**
     * The tags for the question
     */
    "tags"?: Array<string>;
    /**
     * The date this question was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type DeltaResourceStateEnum = "UPDATED" | "REMOVED";
export interface DeviceResource {
    /**
     * The authorization code for the device
     */
    "authorization"?: string;
    /**
     * The current condition of the device (New, Defective, Reconditioned)
     */
    "condition"?: DeviceResourceConditionEnum;
    /**
     * The date the device log was created
     */
    "createdDate"?: number;
    /**
     * The key/value pairs for extended data
     */
    "data"?: { [key: string]: string; };
    /**
     * The description of the device
     */
    "description"?: string;
    /**
     * The type of the device
     */
    "deviceType"?: string;
    /**
     * The unique ID for this device. Cannot be changed once created
     */
    "id": number;
    /**
     * The location of the device
     */
    "location"?: string;
    /**
     * The MAC (media access control) address of the device
     */
    "macAddress"?: string;
    /**
     * The make of the device
     */
    "make"?: string;
    /**
     * The model of the device
     */
    "model"?: string;
    /**
     * The name of the device
     */
    "name"?: string;
    /**
     * The OS (operating system) on the device
     */
    "os"?: string;
    /**
     * The serial number of the device
     */
    "serial"?: string;
    /**
     * The current status the device (Active, Pending Active, Inactive, Repair
     */
    "status"?: DeviceResourceStatusEnum;
    /**
     * The date the device log was updated
     */
    "updatedDate"?: number;
    /**
     * The user that owns the device
     */
    "user"?: SimpleUserResource;
    /**
     * The users currently using the device
     */
    "users"?: Array<SimpleUserResource>;
}

export type DeviceResourceConditionEnum = "New" | "Defective" | "Reconditioned";
export type DeviceResourceStatusEnum = "Active" | "PendingActive" | "Inactive" | "Repair";
export interface Discount {
    "description"?: string;
    "name"?: string;
    "sku"?: string;
    "uniqueKey"?: string;
    "value"?: number;
}

export interface DispositionCount {
    /**
     * The number of users that have expressed this disposition
     */
    "count"?: number;
    /**
     * The name of the disposition this count is for
     */
    "name"?: string;
}

export interface DispositionResource {
    /**
     * The context of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "context"?: string;
    /**
     * The context_id of that resource. Required when passed to /dispositions rather than context specific endpoint
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The name of the disposition, 1-20 characters. (ex: like/dislike/favorite, etc)
     */
    "name": string;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

export interface DoubleOperationResource {
    "args"?: Array<ExpressionResource>;
    "op"?: string;
    "type"?: string;
}

export interface EntitlementGrantRequest {
    /**
     * The ID of the entitlement item to grant
     */
    "entitlementId": number;
}

export interface ErrorResource {
    /**
     * Extra details about the error, if needed
     */
    "details"?: any;
    /**
     * The JSON key the message pertains to
     */
    "field"?: any;
    /**
     * The message explaining the error
     */
    "message"?: string;
}

export interface EventContextResource {
    "eventName"?: string;
    "parameters"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

export interface ExpressionResource {
    "type"?: string;
}

export interface Expressionobject {
}

export interface FacebookToken {
    /**
     * A valid access token from facebook. See facebook documention for how to obtain one.
     */
    "accessToken": string;
}

export interface FattMerchantPaymentMethod {
    "address1"?: string;
    "address2"?: string;
    "addressCity"?: string;
    "addressCountry"?: string;
    "addressState"?: string;
    "addressZip"?: string;
    /**
     * Last four digits of the credit card
     */
    "cardLastFour": string;
    "createdAt"?: string;
    /**
     * Unique FattMerchant customer ID
     */
    "customerId": string;
    "deletedAt"?: string;
    "id"?: string;
    /**
     * Nickname given to the FattMerchant payment method
     */
    "nickname": string;
    "updatedAt"?: string;
}

export interface FattMerchantPaymentMethodRequest {
    /**
     * The FattMerchant payment method being created/updated
     */
    "method": FattMerchantPaymentMethod;
    /**
     * ID of the JSAPI user for whom the payment method is being created/updated. If ID is not that of the currently logged in user, FATMMERCHANT_ADMIN privilege is required. If ID is null, will use the currently logged in user's ID.
     */
    "userId"?: number;
}

export interface FinalizeBillingAgreementRequest {
    /**
     * The ID of the invoice being paid along with the creation of this agreement
     */
    "invoiceId"?: number;
    /**
     * Whether the new payment method created should be the user's default
     */
    "newDefault"?: boolean;
    /**
     * The payer ID from PayPal (passed as a parameter in the return URL). Only required if an invoice ID was included
     */
    "payerId"?: string;
    /**
     * The token from PayPal (passed as a parameter in the return URL)
     */
    "token": string;
    /**
     * The ID of the user. Defaults to the logged in user
     */
    "userId"?: number;
}

export interface FinalizePayPalPaymentRequest {
    /**
     * The ID of the invoice that is being paid. Must match the invoice sent in originally
     */
    "invoiceId": number;
    /**
     * The ID of the payer that PayPal returned with the user at the return URL
     */
    "payerId": string;
    /**
     * The token that PayPal returned with the user in the return URL
     */
    "token": string;
}

export interface FlagReportResource {
    /**
     * The context of that resource 
     */
    "context"?: string;
    /**
     * The context ID of that resource
     */
    "contextId"?: string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The reason of that resource required only in case of active resolution
     */
    "reason"?: string;
    /**
     * The resolution of that resource
     */
    "resolution": FlagReportResourceResolutionEnum;
    /**
     * The date/time this report was resolved in seconds since epoch. Null if not resolved yet
     */
    "resolved"?: number;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
}

export type FlagReportResourceResolutionEnum = "banned" | "ignored";
export interface FlagResource {
    /**
     * The context of that resource
     */
    "context": string;
    /**
     * The context_id of that resource
     */
    "contextId": string;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The flag reason of that resource
     */
    "reason"?: string;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The basic user resource
     */
    "user"?: SimpleUserResource;
}

export interface ForwardLog {
    /**
     * The end date of the forward log entry
     */
    "endDate"?: number;
    "errorMsg"?: string;
    /**
     * The http status code the forward log entry
     */
    "httpStatusCode"?: number;
    /**
     * The id of the forward log entry
     */
    "id"?: string;
    /**
     * The payload of the forward log entry
     */
    "payload"?: any;
    /**
     * The response string of the forward log entry
     */
    "response"?: string;
    /**
     * The retry count of the forward log entry
     */
    "retryCount"?: number;
    /**
     * The start date of the forward log entry
     */
    "startDate"?: number;
    /**
     * The endpoint url of the forward log entry
     */
    "url"?: string;
}

export interface FulfillmentType {
    /**
     * Whether the type is core and cannot be altered/deleted, read-only
     */
    "core"?: boolean;
    /**
     * A description of the type
     */
    "description"?: string;
    /**
     * The unique id of the type, read-only
     */
    "id"?: number;
    /**
     * The name of the type
     */
    "name": string;
}

export interface GlobalCheckAndIncrementResource {
    "checkValueResource"?: ExpressionResource;
    "globalResource"?: ExpressionResource;
    "type"?: string;
}

export interface GlobalResource {
    "globalDefId"?: string;
    "scopes"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

export interface GooglePaymentRequest {
    /**
     * The json payload exactly as sent from Google
     */
    "jsonPayload": string;
    /**
     * The signature from Google to verify the payload
     */
    "signature": string;
}

export interface GoogleToken {
    /**
     * A valid authorization code from google. See google documention for how to obtain one.
     */
    "authorizationCode": string;
}

export interface GrantTypeResource {
    /**
     * The description of the grant type
     */
    "description"?: string;
    /**
     * The name of the grant type
     */
    "name"?: string;
}

export interface GroupMemberResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The member's access level. Default: member
     */
    "status"?: GroupMemberResourceStatusEnum;
    /**
     * The username of the user
     */
    "username"?: string;
}

export type GroupMemberResourceStatusEnum = "moderator" | "member";
export interface GroupResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * A description of the group. Max 250 characters
     */
    "description"?: string;
    /**
     * The number of users in the group
     */
    "memberCount"?: number;
    /**
     * A message of the day for members of the group
     */
    "messageOfTheDay"?: string;
    /**
     * The name of the group. Max 50 characters
     */
    "name": string;
    /**
     * The unique name of another group that this group is a subset of
     */
    "parent"?: string;
    /**
     * The status which describes whether other users can freely join the group or not
     */
    "status": GroupResourceStatusEnum;
    /**
     * The number of users in child groups
     */
    "subMemberCount"?: number;
    /**
     * A group template this group is validated against. May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * Unique name used in url and references. Uppercase, lowercase, numbers and hyphens only. Max 50 characters. Cannot be altered once created
     */
    "uniqueName": string;
}

export type GroupResourceStatusEnum = "open" | "closed";
export interface IOConfig {
    "customer"?: string;
    "enabled"?: boolean;
    "environment"?: string;
    "product"?: string;
}

export interface ImportJobOutputResource {
    /**
     * The description of the import job
     */
    "description"?: string;
    /**
     * The line number of the import job
     */
    "lineNumber"?: number;
}

export interface ImportJobResource {
    /**
     * The id of the category to assign all questions in the import to
     */
    "categoryId": string;
    /**
     * The date the job was created in seconds since unix epoc
     */
    "createdDate"?: number;
    /**
     * The id of the job
     */
    "id"?: number;
    /**
     * A name for this import for later reference
     */
    "name": string;
    /**
     * Error information from validation
     */
    "output"?: Array<ImportJobOutputResource>;
    /**
     * The number of questions form the CSV file. Filled in after validation
     */
    "recordCount"?: number;
    /**
     * The status of the job
     */
    "status"?: ImportJobResourceStatusEnum;
    /**
     * The date the job was last updated in seconds since unix epoc
     */
    "updatedDate"?: number;
    /**
     * The url of a CSV file to pull trivia questions from. Cannot be changed after initial POST
     */
    "url": string;
    /**
     * The vendor who supplied this set of questions
     */
    "vendor": string;
}

export type ImportJobResourceStatusEnum = "PENDING_VALIDATION" | "VALIDATING" | "VALID" | "INVALID" | "PENDING_PROCESS" | "PROCESSING" | "PROCESSED" | "FAILED";
export interface IntWrapper {
    "value"?: number;
}

export interface IntegerOperationResource {
    "args"?: Array<ExpressionResource>;
    "op"?: string;
    "type"?: string;
}

export interface InventorySubscriptionResource {
    /**
     * The date the subscription will be billed
     */
    "billDate"?: number;
    /**
     * A credit of money already applied to a subscription for the next bill, or a debt if negative
     */
    "credit"?: number;
    /**
     * A record of past and present credit/debt changes
     */
    "creditLog"?: Array<SubscriptionCreditResource>;
    /**
     * The date the grace period ends
     */
    "graceEnd"?: number;
    /**
     * The id of the inventory
     */
    "inventoryId"?: number;
    /**
     * The inventory status object
     */
    "inventoryStatus"?: InventorySubscriptionResourceInventoryStatusEnum;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The payment method object
     */
    "paymentMethod"?: PaymentMethodResource;
    /**
     * The recurring price that has been set to override the base price. Null if not overriding
     */
    "priceOverride"?: number;
    /**
     * An explanation for the reason the price is being overridden
     */
    "priceOverrideReason"?: string;
    /**
     * The default recurring price
     */
    "recurringPrice"?: number;
    /**
     * The recurring sku of the subscription
     */
    "sku"?: string;
    /**
     * The date the subscription will start
     */
    "startDate"?: number;
    /**
     * The status of the subscription
     */
    "subscriptionStatus"?: number;
    /**
     * The user
     */
    "user"?: SimpleUserResource;
}

export type InventorySubscriptionResourceInventoryStatusEnum = "pending" | "active" | "inactive";
export interface InvoiceCreateRequest {
    /**
     * The guid of a cart to create a new invoice for
     */
    "cartGuid": string;
}

export interface InvoiceItemResource {
    "bundleSku"?: string;
    "currentFulfillmentStatus"?: string;
    "id"?: number;
    "invoiceId"?: number;
    "itemId"?: number;
    "itemName"?: string;
    "originalTotalPrice"?: number;
    "originalUnitPrice"?: number;
    "qty"?: number;
    "saleName"?: string;
    "sku"?: string;
    "skuDescription"?: string;
    "systemPrice"?: number;
    "totalPrice"?: number;
    "typeHint"?: string;
    "unitPrice"?: number;
}

export interface InvoiceLogEntry {
    /**
     * The date this event occurred as a unix timestamp in seconds
     */
    "date"?: number;
    /**
     * The ID of the invoice
     */
    "invoiceId"?: number;
    /**
     * A message describing the event
     */
    "message"?: string;
    /**
     * The type of event
     */
    "type"?: string;
}

export interface InvoicePaymentStatusRequest {
    /**
     * If included, will set the payment method used on the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The new status for the invoice. Additional options may be available based on configuration.  Allowable values: 'new', 'paid', 'hold', 'canceled', 'payment failed', 'partial refund', 'refund'
     */
    "status": string;
}

export interface InvoiceResource {
    /**
     * Line one of the customer's billing address
     */
    "billingAddress1"?: string;
    /**
     * Line two of the customer's billing address
     */
    "billingAddress2"?: string;
    /**
     * The city for the customer's billing address
     */
    "billingCityName"?: string;
    /**
     * The country for the customer's billing address
     */
    "billingCountryName"?: string;
    /**
     * The customer's name for the billing address
     */
    "billingFullName"?: string;
    /**
     * The postal code for the customer's billing address
     */
    "billingPostalCode"?: string;
    /**
     * The state for the customer's billing address
     */
    "billingStateName"?: string;
    /**
     * The guid of the cart this invoice came from
     */
    "cartId"?: string;
    /**
     * The date the invoice was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The code for the currency invoice prices are in
     */
    "currency"?: string;
    /**
     * The fulfillment status of the invoice
     */
    "currentFulfillmentStatus"?: string;
    /**
     * The payment status of the invoice
     */
    "currentPaymentStatus"?: string;
    /**
     * The amount of money saved through coupons
     */
    "discount"?: number;
    /**
     * The customer's email address
     */
    "email"?: string;
    /**
     * An external reference to filter on
     */
    "externalRef"?: string;
    /**
     * The amount of federal tax added
     */
    "fedTax"?: number;
    /**
     * The final price of the invoice
     */
    "grandTotal"?: number;
    /**
     * The id of the invoice
     */
    "id"?: number;
    /**
     * A reference number for the invoice
     */
    "invoiceNumber"?: string;
    /**
     * A list of items within the invoice
     */
    "items"?: Array<InvoiceItemResource>;
    /**
     * The customer's name prefix
     */
    "namePrefix"?: string;
    /**
     * Notes about the order
     */
    "orderNotes"?: string;
    /**
     * The id of an invoice this is a child of
     */
    "parentInvoiceId"?: number;
    /**
     * The id of a saved payment method used to pay for the invoice
     */
    "paymentMethodId"?: number;
    /**
     * The customer's phone number
     */
    "phone"?: string;
    /**
     * The customer's phone number
     */
    "phoneNumber"?: string;
    /**
     * The shipping cost
     */
    "shipping"?: number;
    /**
     * Line one of the customer's shipping address
     */
    "shippingAddress1"?: string;
    /**
     * Line two of the customer's shipping address
     */
    "shippingAddress2"?: string;
    /**
     * The city for the customer's shipping address
     */
    "shippingCityName"?: string;
    /**
     * The country for the customer's shipping address
     */
    "shippingCountryName"?: string;
    /**
     * The customer's name for the shipping address
     */
    "shippingFullName"?: string;
    /**
     * The postal code for the customer's shipping address
     */
    "shippingPostalCode"?: string;
    /**
     * The state for the customer's shipping address
     */
    "shippingStateName"?: string;
    /**
     * A number to use in sorting items. default 500.
     */
    "sort"?: number;
    /**
     * The amount of state tax added
     */
    "stateTax"?: number;
    /**
     * The sum price of all items before shipping, coupons and tax
     */
    "subtotal"?: number;
    /**
     * The date the invoice was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The owner of the invoice
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the vendor
     */
    "vendorId"?: number;
    /**
     * The name of the invoice
     */
    "vendorName"?: string;
}

export interface Item {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the item
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * A short description of the item, max 255 chars
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against.  May be null and no validation of additional_properties will be done.  Default = null
     */
    "template"?: string;
    /**
     * The type of the item
     */
    "typeHint": string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated, unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface ItemBehaviorDefinitionResource {
    /**
     * The default version of the behavior
     */
    "behavior": Behavior;
    /**
     * Whether the behavior's values can be modified
     */
    "modifiable": boolean;
    /**
     * Whether the behavior can be removed
     */
    "required": boolean;
}

export interface ItemTemplateResource {
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface KeyValuePairstringstring {
    "key"?: string;
    "value"?: string;
}

export interface LeaderboardEntryResource {
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * The date this score was recorded or updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface LeaderboardResource {
    /**
     * The paginated list of user results, in order from best to worst
     */
    "entries"?: Array<LeaderboardEntryResource>;
    /**
     * The id of the leaderboard
     */
    "id"?: number;
    /**
     * The name of the strategy that defines how entries are stored and compared
     */
    "strategy"?: string;
}

export interface LevelingResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the leveling schema was created
     */
    "createdDate"?: number;
    /**
     * The description of the leveling schema
     */
    "description"?: string;
    /**
     * The name of the leveling schema.  IMMUTABLE
     */
    "name": string;
    /**
     * A set of tiers that contain experience boundaries
     */
    "tiers"?: Array<TierResource>;
    /**
     * The date the leveling schema was updated
     */
    "updatedDate"?: number;
}

export interface LimitedGettableGroup {
    /**
     * Whether to get active items only
     */
    "activeOnly": boolean;
    /**
     * The name of the group. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that owned_limit and active_only will be the same for all, but this is not enforced and the item being recieved will use its settings.
     */
    "name"?: string;
    /**
     * The max number of items that can be purchased
     */
    "ownedLimit": number;
}

export interface Localizer {
}

export interface LocationLogResource {
    "country"?: string;
    "ip"?: string;
    "time"?: number;
}

export interface LookupResource {
    "lookupKey"?: ExpressionResource;
    "type"?: string;
    "valueType"?: string;
}

export interface LookupTypeResource {
    /**
     * The description of the expression type
     */
    "description": string;
    /**
     * The variable type the key expression must be, or null if it's dependent (see description for explanation in this case)
     */
    "keyType": string;
    /**
     * The name of the expression type
     */
    "name": string;
    /**
     * The variable type of the value this expression returns, or null if it's dependent (see description for explanation in this case)
     */
    "valueType": string;
}

export interface Maintenance {
    /**
     * Whether access to the system has been locked
     */
    "accessLocked": boolean;
    /**
     * A simple object of any schema for client side use and processing
     */
    "details"?: any;
    /**
     * User displayable message about the maintenance
     */
    "message": string;
}

export interface MapResource {
    "map"?: { [key: string]: ExpressionResource; };
    "type"?: string;
}

export interface Mapstringobject extends null<String, any> {
}

export interface MetricResource {
    /**
     * The id of the activity occurence where this score/metric occurred
     */
    "activityOccurenceId": number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The value/score of the metric
     */
    "value": number;
}

export interface MongoDatabaseConfig {
    "dbName"?: string;
    "options"?: string;
    "password"?: string;
    "servers"?: string;
    "username"?: string;
}

export interface NestedCategory {
    /**
     * Whether the category is active
     */
    "active"?: boolean;
    /**
     * The id of the category
     */
    "id": string;
    /**
     * The name of the category
     */
    "name"?: string;
}

export interface NewPasswordRequest {
    /**
     * The new password in plain text
     */
    "password": string;
    /**
     * The secret provided after the password reset
     */
    "secret": string;
}

export interface OAuth2Resource {
    /**
     * The access token issued by the authorization server
     */
    "accessToken"?: string;
    /**
     * The lifetime in seconds of the access token
     */
    "expiresIn"?: string;
    /**
     * The scope of the access token. Currently these values can be ignored, as security defaults to roles and permissions
     */
    "scope"?: string;
    /**
     * The type of the token issued
     */
    "tokenType"?: string;
}

export interface OauthAccessTokenResource {
    /**
     * The key of the client assosciated with the token
     */
    "clientId"?: string;
    /**
     * The token.  Not shown in list view
     */
    "token"?: string;
    /**
     * The username of the user associated with the token
     */
    "username"?: string;
}

export interface Operator {
}

export interface OptimalPaymentRequest {
    /**
     * The email address of the user
     */
    "email"?: string;
    /**
     * The first name of the user
     */
    "firstName"?: string;
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * The last name of the user
     */
    "lastName"?: string;
    /**
     * The url to redirect the user to after declining payment
     */
    "onDecline": string;
    /**
     * The url to redirect the user to after an error in payment
     */
    "onError": string;
    /**
     * The url to redirect the user to after successful payment
     */
    "onSuccess": string;
}

export interface Order {
    "ascending"?: boolean;
    "descending"?: boolean;
    "direction"?: OrderDirectionEnum;
    "ignoreCase"?: boolean;
    "nullHandling"?: OrderNullHandlingEnum;
    "property"?: string;
}

export type OrderDirectionEnum = "ASC" | "DESC";
export type OrderNullHandlingEnum = "NATIVE" | "NULLS_FIRST" | "NULLS_LAST";
export interface PageResourceAchievementDefinitionResource {
    "content"?: Array<AchievementDefinitionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateCountResource {
    "content"?: Array<AggregateCountResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceAggregateInvoiceReportResource {
    "content"?: Array<AggregateInvoiceReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArticleResource {
    "content"?: Array<ArticleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceArtistResource {
    "content"?: Array<ArtistResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareActivityResource {
    "content"?: Array<BareActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBareChallengeActivityResource {
    "content"?: Array<BareChallengeActivityResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBillingReport {
    "content"?: Array<BillingReport>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreCategoryResource {
    "content"?: Array<BreCategoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreEventLog {
    "content"?: Array<BreEventLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreGlobalResource {
    "content"?: Array<BreGlobalResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreRule {
    "content"?: Array<BreRule>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceBreTriggerResource {
    "content"?: Array<BreTriggerResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCampaignResource {
    "content"?: Array<CampaignResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCartSummary {
    "content"?: Array<CartSummary>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCatalogSale {
    "content"?: Array<CatalogSale>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCategoryResource {
    "content"?: Array<CategoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventParticipantResource {
    "content"?: Array<ChallengeEventParticipantResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeEventResource {
    "content"?: Array<ChallengeEventResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceChallengeResource {
    "content"?: Array<ChallengeResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceClientResource {
    "content"?: Array<ClientResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCommentResource {
    "content"?: Array<CommentResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceConfig {
    "content"?: Array<Config>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCountryTaxResource {
    "content"?: Array<CountryTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceCurrencyResource {
    "content"?: Array<CurrencyResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDeviceResource {
    "content"?: Array<DeviceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceDispositionResource {
    "content"?: Array<DispositionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceEntitlementItem {
    "content"?: Array<EntitlementItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFlagReportResource {
    "content"?: Array<FlagReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceForwardLog {
    "content"?: Array<ForwardLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceFulfillmentType {
    "content"?: Array<FulfillmentType>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupMemberResource {
    "content"?: Array<GroupMemberResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceGroupResource {
    "content"?: Array<GroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceImportJobResource {
    "content"?: Array<ImportJobResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceLogEntry {
    "content"?: Array<InvoiceLogEntry>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceInvoiceResource {
    "content"?: Array<InvoiceResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceItemTemplateResource {
    "content"?: Array<ItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLevelingResource {
    "content"?: Array<LevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceLocationLogResource {
    "content"?: Array<LocationLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceMapstringobject {
    "content"?: Array<Mapstringobject>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceOauthAccessTokenResource {
    "content"?: Array<OauthAccessTokenResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePermissionResource {
    "content"?: Array<PermissionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcePollResource {
    "content"?: Array<PollResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionResource {
    "content"?: Array<QuestionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceQuestionTemplateResource {
    "content"?: Array<QuestionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueCountryReportResource {
    "content"?: Array<RevenueCountryReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRevenueProductReportResource {
    "content"?: Array<RevenueProductReportResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRewardSetResource {
    "content"?: Array<RewardSetResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceRoleResource {
    "content"?: Array<RoleResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSavedAddressResource {
    "content"?: Array<SavedAddressResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleReferenceResourceobject {
    "content"?: Array<SimpleReferenceResourceobject>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleUserResource {
    "content"?: Array<SimpleUserResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSimpleWallet {
    "content"?: Array<SimpleWallet>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStateTaxResource {
    "content"?: Array<StateTaxResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItem {
    "content"?: Array<StoreItem>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceStoreItemTemplateResource {
    "content"?: Array<StoreItemTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionResource {
    "content"?: Array<SubscriptionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceSubscriptionTemplateResource {
    "content"?: Array<SubscriptionTemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTemplateResource {
    "content"?: Array<TemplateResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceTransactionResource {
    "content"?: Array<TransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUsageInfo {
    "content"?: Array<UsageInfo>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserAchievementGroupResource {
    "content"?: Array<UserAchievementGroupResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserActionLog {
    "content"?: Array<UserActionLog>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserBaseResource {
    "content"?: Array<UserBaseResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserInventoryResource {
    "content"?: Array<UserInventoryResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserItemLogResource {
    "content"?: Array<UserItemLogResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserLevelingResource {
    "content"?: Array<UserLevelingResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceUserRelationshipResource {
    "content"?: Array<UserRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVendorResource {
    "content"?: Array<VendorResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoRelationshipResource {
    "content"?: Array<VideoRelationshipResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceVideoResource {
    "content"?: Array<VideoResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTotalResponse {
    "content"?: Array<WalletTotalResponse>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourceWalletTransactionResource {
    "content"?: Array<WalletTransactionResource>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface PageResourcestring {
    "content"?: Array<string>;
    "first"?: boolean;
    "last"?: boolean;
    "number"?: number;
    "numberOfElements"?: number;
    "size"?: number;
    "sort"?: Array<Order>;
    "totalElements"?: number;
    "totalPages"?: number;
}

export interface ParameterResource {
    "of"?: string;
    "type"?: string;
    "value"?: any;
}

/**
 * A request to reset a user's password by using a known user property
 */
export interface PasswordResetRequest {
    /**
     * The user's email address
     */
    "email"?: string;
    /**
     * The user's mobile phone number
     */
    "mobileNumber"?: string;
    /**
     * The user's username
     */
    "username"?: string;
}

export interface PayBySavedMethodRequest {
    /**
     * The id of the payment method to use. Must belong to the caller, be public or have PAYMENTS_ADMIN permission
     */
    "paymentMethod": number;
}

export interface PaymentAuthorizationResource {
    /**
     * Whether this authorization has been captured
     */
    "captured"?: boolean;
    /**
     * The date this authorization was received, unix timestamp in seconds
     */
    "created"?: number;
    /**
     * The details for this authorization. Format dependent on payment provider
     */
    "details"?: any;
    /**
     * The id of the authorization
     */
    "id"?: number;
    /**
     * The invoice this authorization is intended to pay
     */
    "invoice"?: number;
    /**
     * The payment type (which provider) this payment is through
     */
    "paymentType": SimpleReferenceResourceint;
}

export interface PaymentMethodDetails {
    "default"?: boolean;
    /**
     * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
     */
    "expirationDate"?: number;
    /**
     * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
     */
    "expirationMonth"?: number;
    /**
     * The expiration year for the payment method. Typically used for credit card payment methods
     */
    "expirationYear"?: number;
    /**
     * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
     */
    "last4"?: string;
    /**
     * The sort value for the payment method
     */
    "sort"?: number;
    /**
     * An optional unique identifier
     */
    "uniqueKey"?: string;
    "verified"?: boolean;
}

export interface PaymentMethodResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    "default"?: boolean;
    /**
     * Whether this payment method is disabled or not
     */
    "disabled"?: boolean;
    /**
     * The expiration date for the payment method, expressed as seconds since epoch. Typically used for credit card payment methods
     */
    "expirationDate"?: number;
    /**
     * The expiration month (1 - 12) for the payment method. Typically used for credit card payment methods
     */
    "expirationMonth"?: number;
    /**
     * The expiration year for the payment method. Typically used for credit card payment methods
     */
    "expirationYear"?: number;
    /**
     * The unique ID of the resource
     */
    "id"?: number;
    /**
     * The last 4 digits of the account number for the payment method. Typically used for credit card payment methods
     */
    "last4"?: string;
    /**
     * The user friendly name of the resource
     */
    "name": string;
    /**
     * The type of payment method. Must be a pre-existing value
     */
    "paymentMethodType": PaymentMethodTypeResource;
    /**
     * The generic payment type. Default is card
     */
    "paymentType"?: PaymentMethodResourcePaymentTypeEnum;
    /**
     * The sort value for the payment method
     */
    "sort"?: number;
    /**
     * The unique token for the payment method
     */
    "token"?: string;
    /**
     * An optional unique identifier
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user's id. If null, indicates a shared payment method that any user can use (i.e., 'wallet')
     */
    "userId"?: number;
    "verified"?: boolean;
}

export type PaymentMethodResourcePaymentTypeEnum = "card" | "bank_account";
export interface PaymentMethodTypeResource {
    /**
     * The id of the payment method type
     */
    "id": number;
    /**
     * The name of the payment method type
     */
    "name": string;
}

export interface PermissionResource {
    /**
     * The date the permission was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The description of the permission
     */
    "description"?: string;
    /**
     * Whether a permission is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the permission used for display purposes
     */
    "name": string;
    /**
     * The name of the parent of the permission
     */
    "parent"?: string;
    /**
     * The keyword that defines the permission
     */
    "permission": string;
    /**
     * The date the permission was updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
}

export interface PollAnswerResource {
    /**
     * The number of users that selected this answer
     */
    "count"?: number;
    /**
     * The key to the answer (for code reference)
     */
    "key": string;
    /**
     * The text of the answer (for user display)
     */
    "text": string;
}

export interface PollResource {
    /**
     * Whether the poll is active
     */
    "active": boolean;
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The answers to the poll
     */
    "answers": Array<PollAnswerResource>;
    /**
     * The category for the poll
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the poll
     */
    "id"?: string;
    /**
     * The tags for the poll
     */
    "tags"?: Array<string>;
    /**
     * A poll template this poll is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The text of the poll
     */
    "text": string;
    /**
     * The media type of the poll
     */
    "type": PollResourceTypeEnum;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export type PollResourceTypeEnum = "TEXT" | "IMAGE" | "VIDEO" | "AUDIO";
export interface PollResponseResource {
    /**
     * The answer to the poll
     */
    "answer": string;
    /**
     * The date the poll was answered, in seconds since unix epoc
     */
    "answeredDate"?: number;
    /**
     * The id of the poll response
     */
    "id"?: string;
    /**
     * The id of the poll
     */
    "pollId": string;
    /**
     * The user
     */
    "user": SimpleUserResource;
}

export interface PredicateOperation {
    "args"?: Array<Expressionobject>;
    "operator"?: Operator;
}

export interface PredicateResource {
    /**
     * The arguments the operator apply to. See notes for details.
     */
    "args": Array<ExpressionResource>;
    /**
     * The operator to be used in this predicate. See notes for details.
     */
    "op": string;
    "type"?: string;
}

export interface Property {
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface PropertyDefinitionResource {
    /**
     * A list of the fields on both the property definition and property of this type
     */
    "fieldList"?: PropertyFieldListResource;
    /**
     * The name of the property
     */
    "name": string;
    /**
     * Whether the property is required
     */
    "required": boolean;
    /**
     * The type of the property. Used for polymorphic type recognition and thus must match an expected type with additional properties.
     */
    "type": string;
}

export interface PropertyFieldListResource {
    /**
     * A list of fields for the property definition.
     */
    "propertyDefinitionFields"?: Array<PropertyFieldResource>;
    /**
     * A list of fields for the property.
     */
    "propertyFields"?: Array<PropertyFieldResource>;
    /**
     * The type for the property this describes.
     */
    "propertyType"?: string;
}

export interface PropertyFieldResource {
    /**
     * A description of the field
     */
    "description"?: string;
    /**
     * The type of values within a 'list' type field
     */
    "innerType"?: PropertyFieldResourceInnerTypeEnum;
    /**
     * A description of fields within objects within a 'list' type field, when inner_type is 'object'
     */
    "innerTypeFields"?: Array<PropertyFieldResource>;
    /**
     * The name of the field
     */
    "name"?: string;
    /**
     * Whether the field is required
     */
    "required"?: boolean;
    /**
     * The type of the field
     */
    "type"?: PropertyFieldResourceTypeEnum;
    /**
     * A list of valid values for 'enum' type fields
     */
    "validValues"?: Array<string>;
}

export type PropertyFieldResourceInnerTypeEnum = "integer" | "number" | "bool" | "string" | "enumeration" | "list" | "object";
export type PropertyFieldResourceTypeEnum = "integer" | "number" | "bool" | "string" | "enumeration" | "list" | "object";
export interface QuestionResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The list of available answers
     */
    "answers"?: Array<AnswerResource>;
    /**
     * The category for the question
     */
    "category": NestedCategory;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The difficulty of the question
     */
    "difficulty": number;
    /**
     * The unique ID for that resource
     */
    "id"?: string;
    /**
     * The id of the import job that created the question, or null if not from an import
     */
    "importId"?: number;
    /**
     * When the question becomes available, null for never, in seconds since epoch
     */
    "publishedDate"?: number;
    /**
     * The question. Different 'type' values indicate different structures as the question may be test, image, etc. See information on additional properties for the list and their structures
     */
    "question": Property;
    /**
     * The first source of the question
     */
    "source1"?: string;
    /**
     * The second source of the question
     */
    "source2"?: string;
    /**
     * The list of tags
     */
    "tags"?: Array<string>;
    /**
     * A question template this question is validated against (private). May be null and no validation of additional_properties will be done
     */
    "template"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The supplier of the question
     */
    "vendor"?: string;
}

export interface QuestionTemplateResource {
    /**
     * A property definition for all answers. If included each answer must match this definition's type and be valid
     */
    "answerProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A property definition for the question itself. If included the answer must match this definition's type and be valid
     */
    "questionProperty"?: PropertyDefinitionResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface QuickBuyRequest {
    /**
     * SKU of item being purchased
     */
    "sku": string;
    /**
     * ID of the user making the purchase. If null, currently logged in user will be used.
     */
    "userId"?: number;
}

export interface RawEmailResource {
    /**
     * The body of the outgoing message.
     */
    "body": string;
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * Whether the body is to be treated as html. Default false.
     */
    "html"?: boolean;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The subject of the outgoing message.
     */
    "subject": string;
}

export interface RawSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The body of the outgoing text message.
     */
    "text": string;
}

export interface ReactivateSubscriptionRequest {
    /**
     * The inventory to reactivate. Only required if using the deprecated subscriptions service
     */
    "inventoryId"?: number;
    /**
     * Whether to add the additional reactivation fee in addition to the recurring fee
     */
    "reactivationFee"?: boolean;
}

export interface RefundRequest {
    /**
     * The amount to refund. If left off, will refund the remaining balance of the transaction or specific item balance (if SKU provided), whichever is less.
     */
    "amount"?: number;
    /**
     * The SKU of a bundle item from the invoice that the target item is within.
     */
    "bundleSku"?: string;
    /**
     * Notes about or reason for the refund
     */
    "notes": string;
    /**
     * The SKU of a specific item from the invoice to refund. Affects the maximum refund amount (not to exceed the price of this item times quantity on invoice). Transaction must be tied to an invoice if used.
     */
    "sku"?: string;
}

export interface RefundResource {
    /**
     * The amount refunded
     */
    "amount"?: number;
    /**
     * The id of the refund transaction
     */
    "refundTransactionId"?: number;
    /**
     * The id of the original transaction
     */
    "transactionId"?: number;
}

export interface Result {
    /**
     * The JSAPI error code
     */
    "code"?: number;
    /**
     * The id used for debugging lookup
     */
    "requestId"?: string;
    /**
     * The error object
     */
    "result"?: Array<ErrorResource>;
}

export interface RevenueCountryReportResource {
    "country"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueProductReportResource {
    "itemId"?: number;
    "itemName"?: string;
    "revenue"?: number;
    "volume"?: number;
}

export interface RevenueReportResource {
    "customerCount"?: number;
    "saleCount"?: number;
    "salesAverage"?: number;
    "salesTotal"?: number;
}

export interface RewardCurrencyResource {
    /**
     * The code of the currency type to give
     */
    "currencyCode": string;
    /**
     * The name of the currency reward to give.  Set by currency_code)
     */
    "currencyName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * True if the value is actually a percentage of the intake
     */
    "percent": boolean;
    /**
     * The amount of currency to give. For percentage values, 0.5 is 50%
     */
    "value": number;
}

export interface RewardItemResource {
    /**
     * The id of the item to reward
     */
    "itemId": number;
    /**
     * The name of the item to reward (read only, set by id)
     */
    "itemName"?: string;
    /**
     * The highest number (worst) rank to give the reward to. Must be greater than or equal to minRank
     */
    "maxRank": number;
    /**
     * The lowest number (best) rank to give the reward to. Must be greater than zero
     */
    "minRank": number;
    /**
     * How many copies to give
     */
    "quantity": number;
}

export interface RewardSetResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The currency to give as rewards
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * The assigned unique ID for this reward set
     */
    "id"?: number;
    /**
     * The items to give as rewards
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * A longer describe the reward set, usually included in details
     */
    "longDescription"?: string;
    /**
     * The maximum placing that will receive a reward
     */
    "maxPlacing"?: number;
    /**
     * The user friendly name for this reward set
     */
    "name": string;
    /**
     * A short paragraph to describe the reward set, usually included in listings.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A provided unique key for this reward set
     */
    "uniqueKey"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface RoleResource {
    /**
     * The number of clients this role is assigned to
     */
    "clientCount"?: number;
    /**
     * The date the role was added. Unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * Whether a role is locked from being deleted
     */
    "locked"?: boolean;
    /**
     * The name of the role used for display purposes
     */
    "name": string;
    /**
     * The keyword that defines the role
     */
    "role": string;
    /**
     * The list of permissions this role has
     */
    "rolePermission"?: Array<PermissionResource>;
    /**
     * The number of users this role is assigned to
     */
    "userCount"?: number;
}

export interface S3Config {
    "bucketName"?: string;
    "cdnUrl"?: string;
    "region"?: string;
    "uploadPrefix"?: string;
}

export interface SampleCountriesResponse {
    "vendorId1"?: Array<Country>;
    "vendorId2"?: Array<Country>;
}

export interface SavedAddressResource {
    /**
     * The first line of the address
     */
    "address1": string;
    /**
     * A second line of the address
     */
    "address2"?: string;
    /**
     * The city
     */
    "city": string;
    /**
     * The iso3 code for the country
     */
    "countryCode": string;
    "default"?: boolean;
    /**
     * The first name of the user
     */
    "firstName": string;
    /**
     * The id of the address
     */
    "id"?: number;
    /**
     * The last name of the user
     */
    "lastName": string;
    /**
     * The name of the address
     */
    "name": string;
    /**
     * The first phone number of the user
     */
    "phone1"?: string;
    /**
     * The second phone number of the user
     */
    "phone2"?: string;
    /**
     * The postal code
     */
    "postalCode"?: string;
    /**
     * The code for the state. Required if the country has states/provinces/equivalent
     */
    "stateCode"?: string;
}

export interface Schedule {
    /**
     * The duration of the repeatable events
     */
    "duration": number;
    /**
     * The unit of time for the duration field
     */
    "durationUnit": ScheduleDurationUnitEnum;
    /**
     * How often the event is scheduled
     */
    "repeat": ScheduleRepeatEnum;
}

export type ScheduleDurationUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type ScheduleRepeatEnum = "DAILY" | "WEEKLY";
export interface SearchReferenceMapping {
    /**
     * Unique identifier for the mapping to protect against duplicates
     */
    "id": string;
    /**
     * The field within the type that contains the id from the refType
     */
    "refIdField": string;
    /**
     * The index type that the mapping pulls data from
     */
    "refType": string;
    /**
     * A map whose keys are the field names in the refType and values are the field name in the type
     */
    "sourceFieldToDestinationField": { [key: string]: string; };
    /**
     * The index type that the mapping is for
     */
    "type": string;
}

export interface SelectedSettingResource {
    /**
     * The unique ID for the setting
     */
    "key": string;
    /**
     * The textual name of the setting
     */
    "keyName": string;
    /**
     * The unique ID for the option. Must match one of the options from this setting in the activity, if not part of a challenge
     */
    "value": string;
    /**
     * The textual name of the option
     */
    "valueName": string;
}

export interface SettingOption {
    /**
     * The textual name of the option: Ex: Hard (level 10)
     */
    "name": string;
    /**
     * The unique ID for the option. Ex: 10
     */
    "value"?: string;
}

export interface SimpleReferenceResourceint {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcelong {
    /**
     * The id of the referenced object
     */
    "id": number;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourceobject {
    /**
     * The id of the referenced object
     */
    "id": any;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleReferenceResourcestring {
    /**
     * The id of the referenced object
     */
    "id": string;
    /**
     * The name of the referenced object
     */
    "name"?: string;
}

export interface SimpleUserResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface SimpleWallet {
    /**
     * The current balance of the wallet
     */
    "balance"?: number;
    /**
     * The ISO currency code for the wallet
     */
    "code"?: string;
    /**
     * The name of the currency stored in the wallet
     */
    "currencyName"?: string;
    /**
     * The unique ID of the wallet
     */
    "id"?: number;
    /**
     * The ID of the user to whom the wallet belongs
     */
    "userId"?: number;
}

export interface Sku {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The currency code for the SKU, a three letter string (ISO3)
     */
    "currencyCode": string;
    /**
     * The friendly name of the SKU as it will appear on invoices and reports. Typically represents the option name like red, large, etc
     */
    "description": string;
    /**
     * The number of SKUs currently in stock
     */
    "inventory"?: number;
    /**
     * Alerts vendor when SKU inventory drops below this value
     */
    "minInventoryThreshold"?: number;
    /**
     * The base price before any sale
     */
    "originalPrice": number;
    /**
     * The current price of the SKU with sales, if any. Set original_price for the base
     */
    "price"?: number;
    /**
     * Whether or not the SKU is currently published
     */
    "published"?: boolean;
    /**
     * The id of a sale affecting the price, if any
     */
    "saleId"?: number;
    /**
     * The name of a sale affecting the price, if any
     */
    "saleName"?: string;
    /**
     * The stock keeping unit (SKU), a unique identifier for a given product.  Max 40 characters
     */
    "sku": string;
    /**
     * The date the sku becomes available, unix timestamp in seconds.  If set to null, sku will become available immediately
     */
    "startDate"?: number;
    /**
     * The date the sku becomes unavailable, unix timestamp in seconds.  If set to null, sku is always available
     */
    "stopDate"?: number;
}

export interface SkuRequest {
    /**
     * SKU code of the item
     */
    "sku": string;
}

export interface SqlDatabaseConfig {
    "connectionPoolSize"?: number;
    "dbName"?: string;
    "hostname"?: string;
    "password"?: string;
    "port"?: number;
    "username"?: string;
}

export interface StateResource {
    /**
     * The code of the state
     */
    "code"?: string;
    /**
     * The iso3 of the country this state is in
     */
    "countryCodeIso3"?: string;
    /**
     * The unique ID for the state
     */
    "id"?: number;
    /**
     * The name of the state
     */
    "name"?: string;
}

export interface StateTaxResource {
    /**
     * The iso3 code of the country, cannot be changed
     */
    "countryIso3": string;
    /**
     * Whether the state is exempt from paying the country tax
     */
    "federallyExempt": boolean;
    /**
     * The name of the tax
     */
    "name": string;
    /**
     * The tax rate as a percentage to a maximum of two decimal places (1.5 means 1.5%)
     */
    "rate": number;
    /**
     * The code of the state, cannot be changed
     */
    "stateCode": string;
    /**
     * Whether the tax applies to shipping costs
     */
    "taxShipping": boolean;
}

export interface StoreItemTemplateResource {
    /**
     * The customized behaviors that are required or default for this type of item
     */
    "behaviors"?: Array<ItemBehaviorDefinitionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * A template to apply to all skus on an item using this template
     */
    "skuTemplate"?: TemplateResource;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface StringOperationResource {
    "args"?: Array<ExpressionResource>;
    "op"?: string;
    "type"?: string;
}

export interface StringWrapper {
    "value"?: string;
}

export interface StripeCreatePaymentMethod {
    /**
     * Additional optional details to store on the payment method. If included, all fields in the details will override any defaults
     */
    "details"?: PaymentMethodDetails;
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
    /**
     * The id of the user, if null the logged in user is used. Admin privilege need to specify other users
     */
    "userId"?: number;
}

export interface StripePaymentRequest {
    /**
     * The id of the invoice to pay
     */
    "invoiceId": number;
    /**
     * A token from Stripe to identify payment info to be tied to the customer
     */
    "token": string;
}

export interface SubscriptionCreditResource {
    /**
     * The amount of the credit, negative for debt
     */
    "amount": number;
    /**
     * The date this credit was added, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * The id of the credit record
     */
    "id"?: number;
    /**
     * The id of the subscription inventory entry
     */
    "inventoryId"?: number;
    /**
     * The reason for the subscription credit
     */
    "reason": string;
}

export interface SubscriptionPlan {
    "additionalProperties"?: { [key: string]: Property; };
    "availability"?: SubscriptionPlanAvailabilityEnum;
    "billGraceDays"?: number;
    "consolidated"?: boolean;
    "firstBill"?: number;
    "firstBillUnitOfTime"?: SubscriptionPlanFirstBillUnitOfTimeEnum;
    "id"?: string;
    "latePaymentSku"?: string;
    "locked"?: boolean;
    "maxAutoRenew"?: number;
    "maxBillAttempts"?: number;
    "migrationPlan"?: string;
    "minimumTerm"?: number;
    "name"?: string;
    "primarySku"?: string;
    "reactivationSku"?: string;
    "recurringSku"?: string;
    "renewPeriod"?: number;
    "renewPeriodUnitOfTime"?: SubscriptionPlanRenewPeriodUnitOfTimeEnum;
    "subscriptionId"?: number;
}

export type SubscriptionPlanAvailabilityEnum = "all" | "new_subscribers";
export type SubscriptionPlanFirstBillUnitOfTimeEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type SubscriptionPlanRenewPeriodUnitOfTimeEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export interface SubscriptionPlanResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this subscription
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The length of the billing cycle in number of billing cycle unit
     */
    "billingCycleLength": number;
    /**
     * The time period unit to apply to the length of billing cycles
     */
    "billingCycleUnit": SubscriptionPlanResourceBillingCycleUnitEnum;
    /**
     * Whether this plan will be renewed on the consolidated billing cycle
     */
    "consolidated": boolean;
    /**
     * The ISO3 currency code to use for the fees
     */
    "currencyCode": string;
    /**
     * Used to schedule plan availability end date
     */
    "endDate"?: number;
    /**
     * Optional override for the length of the first billing cycle before the first recurring billing
     */
    "firstBillingCycleLength"?: number;
    /**
     * The time period unit to apply to the length of the first billing cycle. Required when first_billing_cycle_length is specified
     */
    "firstBillingCycleUnit"?: SubscriptionPlanResourceFirstBillingCycleUnitEnum;
    /**
     * The number of late payment days before a subscription is canceled
     */
    "gracePeriod": number;
    /**
     * The id of the plan used to generate the SKUs
     */
    "id"?: string;
    /**
     * The fee charged when the subscription is purchased
     */
    "initialFee": number;
    /**
     * The SKU to be used when purchasing the subscription through the cart
     */
    "initialSku"?: string;
    /**
     * The fee to add to the bill when an invoice has gone unpaid passed the grace period
     */
    "latePaymentFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is delinquent
     */
    "latePaymentSku"?: string;
    /**
     * Whether this plan is locked because it has been purchased by at least one user.  When locked, a number of properties can no longer be changed
     */
    "locked"?: boolean;
    /**
     * The number of charge attempts before the subscription becomes delinquent
     */
    "maxBillAttempts": number;
    /**
     * Maximum number of renewals. If a migration plan is provided, the subscription will automatically switch to it when this limit is reached
     */
    "maxCycles"?: number;
    /**
     * Automatically migrate to the specified plan when the subscription is first renewed
     */
    "migrateToPlan"?: string;
    /**
     * The minimum number of renewals to charge for
     */
    "minCycles"?: number;
    /**
     * The name of the plan used to generate the SKUs
     */
    "name": string;
    /**
     * Whether this plan is currently available
     */
    "published": boolean;
    /**
     * The fee to charge when a suspended subscription is to be re-activated
     */
    "reactivationFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is re-activated after a suspension
     */
    "reactivationSku"?: string;
    /**
     * The recurring fee to charge for each renewal
     */
    "recurringFee": number;
    /**
     * The SKU that will show on the invoice when the subscription is activated
     */
    "recurringSku"?: string;
    /**
     * Used to schedule plan availability start date
     */
    "startDate"?: number;
}

export type SubscriptionPlanResourceBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export type SubscriptionPlanResourceFirstBillingCycleUnitEnum = "millisecond" | "second" | "minute" | "hour" | "day" | "week" | "month" | "year";
export interface SubscriptionPriceOverrideRequest {
    /**
     * The recurring price that has been set to override the base price. Null if not overriding
     */
    "newPrice"?: number;
    /**
     * An explanation for the reason the price is being overridden
     */
    "reason"?: string;
}

export interface SubscriptionResource {
    /**
     * A map of item additional properties, keyed on the property name. Must match the names and types defined in the template for this item type.
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * Who can purchase this subscription
     */
    "availability"?: SubscriptionResourceAvailabilityEnum;
    /**
     * The behaviors linked to the item, describing various options and interactions. May not be included in item lists
     */
    "behaviors"?: Array<Behavior>;
    /**
     * A category for filtering items
     */
    "category"?: string;
    /**
     * The day of the month 1..31 this subscription will renew
     */
    "consolidationDayOfMonth"?: number;
    /**
     * The date the item was created, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A list of country iso3 codes to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: SubscriptionResourceGeoPolicyTypeEnum;
    /**
     * The id of the item
     */
    "id"?: number;
    /**
     * A long description of the subscription
     */
    "longDescription"?: string;
    /**
     * The name of the item
     */
    "name": string;
    /**
     * The billing options for this subscription
     */
    "plans"?: Array<SubscriptionPlanResource>;
    /**
     * A short description of the subscription.  Max 255 characters
     */
    "shortDescription"?: string;
    /**
     * A number to use in sorting items.  Default 500
     */
    "sort"?: number;
    /**
     * Used to schedule removal from store.  Null means the subscription will never be removed
     */
    "storeEnd"?: number;
    /**
     * Used to schedule appearance in store.  Null means the subscription will appear now
     */
    "storeStart"?: number;
    /**
     * List of tags used for filtering items
     */
    "tags"?: Array<string>;
    /**
     * An item template this item is validated against. May be null and no validation of additional properties will be done.
     */
    "template"?: string;
    /**
     * The unique key for the item
     */
    "uniqueKey"?: string;
    /**
     * The date the item was last updated
     */
    "updatedDate"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type SubscriptionResourceAvailabilityEnum = "all" | "new_subscribers";
export type SubscriptionResourceGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface SubscriptionTemplateResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * A template to apply to all plans on a subscription using this template
     */
    "planTemplate"?: TemplateResource;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateEmailResource {
    /**
     * Address to attribute the outgoing message to. Optional if the config email.out_address is set.
     */
    "from"?: string;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The key for the template
     */
    "templateKey": string;
    /**
     * A list of variables to fill in the template
     */
    "templateVars"?: Array<KeyValuePairstringstring>;
}

export interface TemplateResource {
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The id of the template
     */
    "id"?: string;
    /**
     * The name of the template
     */
    "name": string;
    /**
     * The customized properties that are present
     */
    "properties"?: Array<PropertyDefinitionResource>;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface TemplateSMSResource {
    /**
     * The phone number to attribute the outgoing message to. Optional if the config text.out_number is set.
     */
    "from"?: string;
    "localizer"?: Localizer;
    /**
     * A list of user ids to send the message to.
     */
    "recipients": Array<number>;
    /**
     * The key for the template.
     */
    "templateKey": string;
    /**
     * A list of values to fill in the template. Order matters.
     */
    "templateVars"?: Array<string>;
}

export interface TierResource {
    /**
     * A map of additional properties, keyed on the property name.  Must match the names and types defined in the template for this item type
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The name of the tier
     */
    "name"?: string;
    /**
     * The required progress for the tier
     */
    "requiredProgress": number;
    /**
     * The name of the triggered event
     */
    "triggerEventName"?: string;
}

export interface TokenDetailsResource {
    "clientId"?: string;
    "roles"?: Array<string>;
    "userId"?: number;
}

export interface TransactionResource {
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: TransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
}

export type TransactionResourceSourceEnum = "digital" | "physical";
export interface TypeHintLookupResource {
    "lookupKey"?: ExpressionResource;
    "type"?: string;
    "valueType"?: string;
}

export interface UsageInfo {
    /**
     * The number of requests within the range
     */
    "count"?: number;
    /**
     * The date at the start of the range (see granularity)
     */
    "date"?: number;
    /**
     * The http method
     */
    "method"?: string;
    /**
     * The url path
     */
    "url"?: string;
}

export interface UserAchievementGroupResource {
    /**
     * The list of achievements associated with the group
     */
    "achievements": Array<UserAchievementResource>;
    /**
     * The name of the group.  If used by Leveling, this will represent the level name
     */
    "groupName": string;
    /**
     * The id of the achievement progress
     */
    "id"?: string;
    /**
     * The current progress of the user on the group
     */
    "progress": number;
    /**
     * The id of the user whose progress is being tracked
     */
    "userId": number;
}

export interface UserAchievementResource {
    /**
     * Flag indicating whether the user has earned the achievement
     */
    "achieved"?: boolean;
    /**
     * The achievement being tracked.  If used for Leveling, this represents the tier name
     */
    "achievementName": string;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The date/time the achievement was earned as a unix timestamp in seconds
     */
    "earnedDate"?: number;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
}

export interface UserActionLog {
    /**
     * A description of the action taken
     */
    "actionDescription": string;
    /**
     * The name of the action taken
     */
    "actionName": string;
    /**
     * The date of the action, unix timestamp in seconds
     */
    "createdDate"?: number;
    /**
     * A map of additional details such as the target of the action
     */
    "details"?: { [key: string]: string; };
    /**
     * The id of the log entry
     */
    "id"?: string;
    /**
     * The id of the api request that spawned the action, if generated internally
     */
    "requestId"?: string;
    /**
     * The id of the user that took the action, if any. Read-only if not posting with LOGS_ADMIN
     */
    "userId"?: number;
}

export interface UserActivityResults {
    /**
     * Any currency rewarded to this user
     */
    "currencyRewards"?: Array<RewardCurrencyResource>;
    /**
     * Any items rewarded to this user
     */
    "itemRewards"?: Array<RewardItemResource>;
    /**
     * The position of the user in the leaderboard. Null means non-compete or disqualification
     */
    "rank"?: number;
    /**
     * The raw score in this leaderboard. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The number of users tied at this rank, including this user. 1 means no tie
     */
    "ties"?: number;
    /**
     * The date this score was recorded or updated. Unix timestamp in seconds
     */
    "updatedDate"?: number;
    /**
     * The player for this entry
     */
    "user": SimpleUserResource;
}

export interface UserActivityResultsResource {
    /**
     * The raw score. Null means non-compete or disqualification
     */
    "score"?: number;
    /**
     * Any tags for the metric. Each unique tag will translate into a unique leaderboard. Maximum 5 tags and 50 characters each
     */
    "tags"?: Array<string>;
    /**
     * The id of the player
     */
    "userId": number;
}

export interface UserBaseResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The date the user last interacted with the API (private)
     */
    "lastActivity"?: number;
    /**
     * The date the user's info was last updated as a unix timestamp
     */
    "lastUpdated"?: number;
    /**
     * The user's date of registration as a unix timestamp
     */
    "memberSince"?: number;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

export interface UserInventoryAddRequest {
    /**
     * A note to be passed to the invoice or transaction
     */
    "note": string;
    /**
     * A list of behaviors to ignore explicitely.  Ex: 'limited_gettable'
     */
    "overrides"?: Array<string>;
    /**
     * If set to true will cause the endpoint to skip creation of cart and invoice to track the inventory change
     */
    "skipInvoice": boolean;
    /**
     * The specific SKU of the item to be added to the inventory
     */
    "sku": string;
}

export interface UserInventoryResource {
    /**
     * A map of data for behaviors
     */
    "behaviorData"?: any;
    /**
     * The date/time this resource was created in seconds since epoch
     */
    "createdDate"?: number;
    /**
     * The date/time this resource exires in seconds since epoch. Null for no expiration. For subscriptions, this is the end of the 'grace period' if left unpaid
     */
    "expires"?: number;
    /**
     * The id of the inventory
     */
    "id"?: number;
    /**
     * The id of the invoice that resulted in this inventory, if any
     */
    "invoiceId"?: number;
    /**
     * The id of the item
     */
    "itemId"?: number;
    /**
     * The name of the item
     */
    "itemName"?: string;
    /**
     * The type hint of the item
     */
    "itemTypeHint"?: string;
    /**
     * The status of the inventory. Pending inventory is not yet ready for use. Inactive inventory has expired or been used up
     */
    "status"?: UserInventoryResourceStatusEnum;
    /**
     * The date/time this resource was last updated in seconds since epoch
     */
    "updatedDate"?: number;
    /**
     * The id of the user this inventory belongs to
     */
    "user"?: SimpleUserResource;
}

export type UserInventoryResourceStatusEnum = "pending" | "active" | "inactive";
export interface UserItemLogResource {
    /**
     * The log entry id
     */
    "id"?: number;
    /**
     * Additional information defined by the type
     */
    "info"?: string;
    /**
     * The item interacted with
     */
    "item"?: SimpleReferenceResourceint;
    /**
     * The date/time this event occurred in seconds since epoch
     */
    "logDate"?: number;
    /**
     * The type of event
     */
    "type"?: string;
    /**
     * The user making the interaction
     */
    "user"?: SimpleUserResource;
    /**
     * The id of the inventory entry this event is related to, if any
     */
    "userInventory"?: number;
}

export interface UserLevelingResource {
    /**
     * The name of the last tier the user has qualified for
     */
    "lastTierName": string;
    /**
     * The progress level of the last tier the user has qualified for
     */
    "lastTierProgress": number;
    /**
     * The name of the level schema
     */
    "levelName": string;
    /**
     * The name of the next tier the user can qualify for
     */
    "nextTierName": string;
    /**
     * The progress needed to qualify for the next tier
     */
    "nextTierProgress": number;
    /**
     * The amount of progress the user has
     */
    "progress": number;
    /**
     * The names of the tiers the user has qualified for
     */
    "tierNames": Array<string>;
    /**
     * The ID of the user
     */
    "userId": number;
}

export interface UserRelationshipReferenceResource {
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * The context of the relationship
     */
    "context"?: string;
    /**
     * The public username of the user
     */
    "displayName"?: string;
    /**
     * The id of the user
     */
    "id": number;
    /**
     * The id of the relationship
     */
    "relationshipId"?: number;
    /**
     * The username of the user
     */
    "username"?: string;
}

export interface UserRelationshipResource {
    /**
     * The child in the relationship
     */
    "child": SimpleUserResource;
    /**
     * Context about the relationship or its type
     */
    "context"?: string;
    /**
     * A generated unique id. Read-Only
     */
    "id"?: number;
    /**
     * The parent in the relationship
     */
    "parent": SimpleUserResource;
}

export interface UserResource {
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The first line of the user's address (private)
     */
    "address"?: string;
    /**
     * The second line of user's address (private)
     */
    "address2"?: string;
    /**
     * The url of the user's avatar image
     */
    "avatarUrl"?: string;
    /**
     * Relationships where this user is the parent. Read-Only, manage through separate endpoints
     */
    "children"?: Array<UserRelationshipReferenceResource>;
    /**
     * The user's city (private)
     */
    "city"?: string;
    /**
     * The ISO3 code for the country from the user's address (private). Will be filled in based on GeoIP country at registration if not provided.
     */
    "countryCode"?: string;
    /**
     * The code for the user's real money currency (private)
     */
    "currencyCode"?: string;
    /**
     * The user's date of birth (private) as a unix timestamp
     */
    "dateOfBirth"?: number;
    /**
     * The user's self description (private)
     */
    "description"?: string;
    /**
     * The chosen display name of the user, defaults to username if not present
     */
    "displayName"?: string;
    /**
     * The user's email address (private). May be required and/or unique depending on system configuration (both on by default). Must match standard email requirements if provided (RFC 2822)
     */
    "email": string;
    /**
     * The user's first name (private)
     */
    "firstName"?: string;
    /**
     * The user's full name (private)
     */
    "fullname"?: string;
    /**
     * The user's gender (private)
     */
    "gender"?: string;
    /**
     * The id of the user
     */
    "id"?: number;
    /**
     * The ISO3 code for the user's currency (private)
     */
    "languageCode"?: string;
    /**
     * The date the user last interacted with the API (private)
     */
    "lastActivity"?: number;
    /**
     * The user's last name (private)
     */
    "lastName"?: string;
    /**
     * The date the user's info was last updated as a unix timestamp
     */
    "lastUpdated"?: number;
    /**
     * The user's date of registration as a unix timestamp
     */
    "memberSince"?: number;
    /**
     * The user's mobile phone number (private)
     */
    "mobileNumber"?: string;
    /**
     * Relationships where this user is the child. Read-Only, manage through separate endpoints
     */
    "parents"?: Array<UserRelationshipReferenceResource>;
    /**
     * The plain text password for the new user account. Required for registration; ignored on profile update.  Use password specific endpoints for editing
     */
    "password"?: string;
    /**
     * The user's postal code (private)
     */
    "postalCode"?: string;
    /**
     * The user's state (private)
     */
    "state"?: string;
    /**
     * Tags on the user. Can only be set by admin. Max length per tag is 64 characters
     */
    "tags"?: Array<string>;
    /**
     * A user template this user is validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The code for the user's timezone (private)
     */
    "timezoneCode"?: string;
    /**
     * The login username for the user (private). May be set to match email if system does not require usernames separately.
     */
    "username": string;
}

export interface UsernameLookupResource {
    "lookupKey"?: ExpressionResource;
    "type"?: string;
    "valueType"?: string;
}

export interface VariableTypeResource {
    /**
     * The base class of the type
     */
    "base": VariableTypeResourceBaseEnum;
    /**
     * Whether the type comes from a set of valid values that the system can provided (such as users)
     */
    "enumerable"?: boolean;
    /**
     * The name of the variable type. Used as the unique id
     */
    "name": string;
}

export type VariableTypeResourceBaseEnum = "NUMBER" | "INTEGER" | "STRING" | "DATE" | "BOOLEAN";
export interface VendorEmailLookupResource {
    "lookupKey"?: ExpressionResource;
    "type"?: string;
    "valueType"?: string;
}

export interface VendorResource {
    /**
     * Whether the vendor is active.  Default = true
     */
    "active"?: boolean;
    /**
     * A map of additional properties, keyed on the property name (private). Must match the names and types defined in the template for this user type, or be an extra not from the template
     */
    "additionalProperties"?: { [key: string]: Property; };
    /**
     * The date the vendor was added. Unix timestamp in seconds
     */
    "createDate"?: number;
    /**
     * A description of the vendor
     */
    "description"?: string;
    /**
     * The id of the vendor
     */
    "id"?: number;
    /**
     * The url of an image for the vendor
     */
    "imageUrl"?: string;
    /**
     * Whether the vendor needs to manually approve invoices before they are paid.  A separate checkout flow is required in this case.  Default: false
     */
    "manualApproval"?: boolean;
    /**
     * The name of the vendor
     */
    "name": string;
    /**
     * The primary email address for the vendor
     */
    "primaryContactEmail"?: string;
    /**
     * The name of the primary contact for the vendor
     */
    "primaryContactName"?: string;
    /**
     * The primary phone number for the vendor
     */
    "primaryContactPhone"?: string;
    /**
     * The email address for sale inquiries for the vendor
     */
    "salesEmail"?: string;
    /**
     * The email address for support inquiries for the vendor
     */
    "supportEmail"?: string;
    /**
     * A user template this user is validated against (private). May be null and no validation of properties will be done
     */
    "template"?: string;
    /**
     * The date the vendor was last updated. Unix timestamp in seconds
     */
    "updateDate"?: number;
    /**
     * The url for the vendor's site
     */
    "url"?: string;
}

export interface Version {
    "version"?: string;
}

export interface VideoRelationshipResource {
    /**
     * The owner of the relationship
     */
    "from"?: SimpleReferenceResourcelong;
    /**
     * The id of the relationship
     */
    "id"?: number;
    /**
     * Details about the relationship such as type or other information. Max length 10 characters
     */
    "relationshipDetails": string;
    /**
     * The target of the relationship.
     */
    "to": SimpleReferenceResourcelong;
}

export interface VideoResource {
    /**
     * Whether the video is available, based on various factors
     */
    "active"?: boolean;
    /**
     * The original artist of the media
     */
    "author"?: SimpleReferenceResourcelong;
    /**
     * The date the media was created as a unix timestamp in seconds
     */
    "authored"?: number;
    /**
     * Whether the video has been banned or not
     */
    "banned"?: boolean;
    /**
     * The category of the video
     */
    "category": SimpleReferenceResourcestring;
    /**
     * The comments of the video
     */
    "comments"?: Array<CommentResource>;
    /**
     * Artists that contributed to the creation. See separate endpoint to add to list
     */
    "contributors"?: Array<ContributionResource>;
    /**
     * The date/time this resource was created in seconds since unix epoch
     */
    "createdDate"?: number;
    /**
     * The country of an embedable version
     */
    "embed"?: string;
    /**
     * The file extension of the media file. 1-5 characters
     */
    "extension": string;
    /**
     * The height of the video in px
     */
    "height": number;
    /**
     * The unique ID for that resource
     */
    "id"?: number;
    /**
     * The length of the video in seconds
     */
    "length": number;
    /**
     * The country of the media. Typically a url. Cannot be blank
     */
    "location": string;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "longDescription"?: string;
    /**
     * The mime-type of the media
     */
    "mimeType"?: string;
    /**
     * The user friendly name of that resource
     */
    "name": string;
    /**
     * The sort order of the video. default: 100
     */
    "priority"?: number;
    /**
     * The privacy setting. default: private
     */
    "privacy"?: VideoResourcePrivacyEnum;
    /**
     * Whether the video has been made public. Default true
     */
    "published"?: boolean;
    /**
     * The user friendly name of that resource. Defaults to blank string
     */
    "shortDescription"?: string;
    /**
     * The size of the media. Minimum 0 if supplied
     */
    "size"?: number;
    /**
     * The tags for the video
     */
    "tags"?: Array<string>;
    /**
     * The country of a thumbnail version. Typically a url
     */
    "thumbnail"?: string;
    /**
     * The date/time this resource was last updated in seconds since unix epoch
     */
    "updatedDate"?: number;
    /**
     * The user the media was uploaded by. May be null for system uploaded media. May only be set to a user other than the current caller if VIDEOS_ADMIN permission. Null will mean the caller is the uploader unless the caller has VIDEOS_ADMIN permission, in which case it will be set to null
     */
    "uploader"?: SimpleUserResource;
    /**
     * The view count of the video
     */
    "views"?: number;
    /**
     * The width of the video in px
     */
    "width": number;
}

export type VideoResourcePrivacyEnum = "private" | "friends" | "public";
export interface WalletAlterRequest {
    /**
     * The amount of currency to add/remove. positive to add, negative to remove
     */
    "delta": number;
    /**
     * The id of an invoice to attribute the transaction to
     */
    "invoiceId"?: number;
    /**
     * The admin entered or system generated reason
     */
    "reason": string;
    /**
     * The transaction type to allow for search/etc
     */
    "type"?: string;
}

export interface WalletTotalResponse {
    /**
     * The currency code
     */
    "currencyCode"?: string;
    /**
     * The sum of all wallets in the system for this currency
     */
    "total"?: number;
}

export interface WalletTransactionResource {
    /**
     * The new balance of the wallet after the transaction
     */
    "balance"?: number;
    /**
     * The unix timestamp in seconds of the transaction
     */
    "createDate"?: number;
    /**
     * The code of the currency for the transaction
     */
    "currencyCode"?: string;
    /**
     * The specific details of the transaction, such as a message from the admin that created it
     */
    "details"?: string;
    /**
     * The id of the transaction
     */
    "id"?: number;
    /**
     * The id of the invoice that spawned the transaction, if any
     */
    "invoiceId"?: number;
    /**
     * Whether the transaction has been refunded
     */
    "isRefunded"?: boolean;
    /**
     * The response
     */
    "response"?: string;
    /**
     * The root source of the transaction
     */
    "source"?: WalletTransactionResourceSourceEnum;
    /**
     * If the transaction was successful
     */
    "successful"?: boolean;
    /**
     * The payment gateway (external) transaction ID
     */
    "transactionId"?: string;
    /**
     * The general type of the transaction
     */
    "type"?: string;
    /**
     * The table name of the subclass
     */
    "typeHint"?: string;
    /**
     * The owner of the wallet
     */
    "user"?: SimpleUserResource;
    /**
     * The amount of the transaction, positive if a gain, negative if an expenditure
     */
    "value"?: number;
    /**
     * The id of the wallet this transaction affected
     */
    "walletId"?: number;
}

export type WalletTransactionResourceSourceEnum = "digital" | "physical";
export interface XsollaPaymentRequest {
    /**
     * The id of an invoice to pay
     */
    "invoiceId": number;
    /**
     * The endpoint URL xsolla should forward the user to after they pay
     */
    "returnUrl": string;
}

export interface AudioPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum length of the audio
     */
    "maxLength"?: number;
    /**
     * If provided, the minimum length of the audio
     */
    "minLength"?: number;
}

export interface BooleanProperty extends Property {
    /**
     * The value
     */
    "value"?: boolean;
}

export interface BooleanPropertyDefinitionResource extends PropertyDefinitionResource {
}

export interface CacheClearEvent extends BroadcastableEvent {
    "customerSetup"?: boolean;
    "customerTeardown"?: boolean;
}

export interface Consumable extends Behavior {
    /**
     * The maximum number of times an item can be used
     */
    "maxUse"?: number;
}

export interface DateProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface DatePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface DoubleProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface DoublePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface EntitlementItem extends Item {
}

export interface Expirable extends Behavior {
    /**
     * The length of time
     */
    "timeLength"?: number;
    /**
     * The unit of time
     */
    "unitOfTime"?: string;
}

export interface FileGroupProperty extends Property {
    /**
     * The list of files
     */
    "files"?: Array<FileProperty>;
}

export interface FileGroupPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum number of files in the group
     */
    "maxCount"?: number;
    /**
     * If provided, the maximum allowed size per file in bytes
     */
    "maxFileSize"?: number;
    /**
     * If provided, the minimum number of files in the group
     */
    "minCount"?: number;
}

export interface FileProperty extends Property {
    /**
     * A crc value for file integrity verification
     */
    "crc"?: string;
    /**
     * A description of the file
     */
    "description"?: string;
    /**
     * The type of file such as txt, mp3, mov or csv
     */
    "fileType"?: string;
    /**
     * The url of the file
     */
    "url"?: string;
}

export interface FilePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum allowed file size in bytes
     */
    "maxFileSize"?: number;
}

export interface FormattedTextProperty extends Property {
    /**
     * The value
     */
    "value"?: string;
}

export interface FormattedTextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum length of the text
     */
    "maxLength"?: number;
}

export interface Fulfillable extends Behavior {
    /**
     * The name of the fulfillment type that describes how the item should be fulfilled.  Examples: inventory, wallet, amazon
     */
    "typeName": string;
}

export interface GuestPlayable extends Behavior {
    /**
     * Whether guests are allowed to use items
     */
    "allowed"?: boolean;
    /**
     * Whether guests are allowed on the leaderboard
     */
    "leaderboard"?: boolean;
}

export interface ImagePropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that the property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum height of the image
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum width of the image
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of the image
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum width of the image
     */
    "minWidth"?: number;
}

export interface IntegerProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface IntegerPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface LimitedGettable extends Behavior {
    "group"?: LimitedGettableGroup;
}

export interface LogLevelEvent extends BroadcastableEvent {
    "level"?: string;
    "name"?: string;
}

export interface LongProperty extends Property {
    /**
     * The value
     */
    "value"?: number;
}

export interface LongPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum value
     */
    "max"?: number;
    /**
     * If provided, the minimum value
     */
    "min"?: number;
}

export interface NewCustomerEvent extends BroadcastableEvent {
    "customerConfig"?: CustomerConfig;
}

export interface PreReqEntitlement extends Behavior {
    /**
     * The item ids that must already be in the user's inventory
     */
    "itemIds": Array<number>;
}

export interface PriceOverridable extends Behavior {
    /**
     * The maximum price allowed
     */
    "maxPrice"?: number;
    /**
     * The minimum price allowed
     */
    "minPrice"?: number;
}

export interface RemoveCustomerEvent extends BroadcastableEvent {
    "customerConfig"?: CustomerConfig;
}

export interface Spendable extends Behavior {
    /**
     * The code of the currency
     */
    "currencyCode"?: string;
    /**
     * The spendable value
     */
    "value"?: number;
}

export interface StoreItem extends Item {
    /**
     * Whether or not the item is currently displayable.  Default = true
     */
    "displayable"?: boolean;
    /**
     * A list of country ID to include in the blacklist/whitelist geo policy
     */
    "geoCountryList"?: Array<string>;
    /**
     * Whether to use the geo_country_list as a black list or white list for item geographical availability
     */
    "geoPolicyType"?: StoreItemGeoPolicyTypeEnum;
    /**
     * Provides the abstract shipping needs if this item is physical and can be shipped.  A value of zero means no shipping needed.  Default = 0
     */
    "shippingTier"?: number;
    /**
     * The skus for the item. Each defines a unique configuration for the item to be purchased (Large-Blue, Small-Green, etc). These are what is ultimately selected in the store and added to the cart
     */
    "skus": Array<Sku>;
    /**
     * The date the item will leave the store, unix timestamp in seconds.  If set to null, item will never leave the store
     */
    "storeEnd"?: number;
    /**
     * The date the item will appear in the store, unix timestamp in seconds.  If set to null, item will appear in store immediately
     */
    "storeStart"?: number;
    /**
     * The vendor who provides the item
     */
    "vendorId": number;
}

export type StoreItemGeoPolicyTypeEnum = "whitelist" | "blacklist";
export interface TextProperty extends Property {
    /**
     * The value
     */
    "value"?: string;
}

export interface TextPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, the maximum length of the text
     */
    "maxLength"?: number;
}

export interface TimePeriodGettable extends Behavior {
    /**
     * The time period limit
     */
    "getLimit": number;
    /**
     * The name of a group of items. Multiple items with the same group name will be limited together, leave null to be assigned a random unique name. It is typical that the other properties here will be the same for all, but this is not enforced and the item being recieved will use its settings.
     */
    "groupName"?: string;
    /**
     * The length of time
     */
    "timeLength": number;
    /**
     * The unit of time
     */
    "unitOfTime": string;
}

export interface TimePeriodUsable extends Behavior {
    /**
     * The amount of times it can be used
     */
    "maxUse"?: number;
    /**
     * The length of time
     */
    "timeLength"?: number;
    /**
     * The unit of time
     */
    "unitOfTime"?: string;
}

export interface VideoPropertyDefinitionResource extends PropertyDefinitionResource {
    /**
     * If provided, a file type that teh property must match
     */
    "fileType"?: string;
    /**
     * If provided, the maximum height of the video
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum length of the video
     */
    "maxLength"?: number;
    /**
     * If provided, the maximum width of the video
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of the video
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum length of the video
     */
    "minLength"?: number;
    /**
     * If provided, the minimum width of the video
     */
    "minWidth"?: number;
}

export interface AudioGroupProperty extends FileGroupProperty {
}

export interface AudioGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum length of the audio
     */
    "maxLength"?: number;
    /**
     * If provided, the minimum length of the audio
     */
    "minLength"?: number;
}

export interface AudioProperty extends FileProperty {
}

export interface BundleItem extends StoreItem {
    /**
     * The skus of items to be included in this bundle, and how they influence the bundle total price.  Must have at least one SKU
     */
    "bundledSkus": Array<BundledSku>;
}

export interface CouponItem extends StoreItem {
    /**
     * The type of coupon
     */
    "couponTypeHint": CouponItemCouponTypeHintEnum;
    /**
     * The amount this coupon is maxed out at.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMax"?: number;
    /**
     * The minimium amount needed in the cart for the coupon to apply.  Applies if coupon_type_hint is coupon_cart
     */
    "discountMinCartValue"?: number;
    /**
     * The type of discount in terms of how it deducts price. Value based discount not available for coupon_cart type coupons
     */
    "discountType": CouponItemDiscountTypeEnum;
    /**
     * The amount the coupon will discount the item. If discount_type is 'value' this will be a flat amount of currency. If discount type is 'percentage' this will be a fraction (0.2 for 20% off) multiplied by the price of the matching item or items.
     */
    "discountValue": number;
    /**
     * Whether this coupon is exclusive or not (true means cannot be in same cart as another).  Default = false
     */
    "exclusive"?: boolean;
    /**
     * The id of the item the coupon is applied to.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "itemId"?: number;
    /**
     * The maximum quantity of items the coupon can apply to, null if no limit and minimum 1 otherwise.  Applies if coupon_type_hint is coupon_single_item or coupon_voucher
     */
    "maxQuantity"?: number;
    /**
     * Whether this coupon is exclusive to itself or not (true means cannot add two of this same coupon to the same cart).  Default = false
     */
    "selfExclusive"?: boolean;
    /**
     * A list of tags for a coupon.  The coupon can only apply to an item that has at least one of these tags.  Applies if coupon_type_hint is coupon_tag
     */
    "validForTags"?: Array<string>;
}

export type CouponItemCouponTypeHintEnum = "coupon_cart" | "coupon_single_item" | "coupon_voucher" | "coupon_vendor" | "coupon_tag";
export type CouponItemDiscountTypeEnum = "value" | "percentage";
export interface ImageGroupProperty extends FileGroupProperty {
}

export interface ImageGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum height of each image
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum width of each image
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of each image
     */
    "minHeight"?: number;
    /**
     * If provided, the minumum width of each image
     */
    "minWidth"?: number;
}

export interface ImageProperty extends FileProperty {
}

export interface ShippingItem extends StoreItem {
    /**
     * A unique list of country iso3 codes that allow the shipping option
     */
    "countries"?: Array<string>;
    /**
     * An abstract max value that the values of item's shipping_tier work against to decide whether an order can be fulfilled
     */
    "maxTierTotal": number;
    /**
     * Whether tax should be applied to the shipping price.  Default = false
     */
    "taxable"?: boolean;
}

export interface Subscription extends StoreItem {
    "availability"?: SubscriptionAvailabilityEnum;
    "consolidationDayOfMonth"?: number;
    "subscriptionPlans"?: Array<SubscriptionPlan>;
}

export type SubscriptionAvailabilityEnum = "all" | "new_subscribers";
export interface VideoGroupProperty extends FileGroupProperty {
}

export interface VideoGroupPropertyDefinitionResource extends FileGroupPropertyDefinitionResource {
    /**
     * If provided, the maximum height of each video
     */
    "maxHeight"?: number;
    /**
     * If provided, the maximum length of each video
     */
    "maxLength"?: number;
    /**
     * If provided, the maximum width of each video
     */
    "maxWidth"?: number;
    /**
     * If provided, the minimum height of each video
     */
    "minHeight"?: number;
    /**
     * If provided, the minimum length of each video
     */
    "minLength"?: number;
    /**
     * If provided, the minimum width of each video
     */
    "minWidth"?: number;
}

export interface VideoProperty extends FileProperty {
}



/**
 * AccessTokenApi - fetch parameter creator
 */
export const AccessTokenApiFetchParamCreator = {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client.  Used only with a grant_type of password
     * @param password The password of the client.  Used only with a grant_type of password
     */
    getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "grantType" is set
        if (params["grantType"] == null) {
            throw new Error("Missing required parameter grantType when calling getOAuthToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling getOAuthToken");
        }
        const baseUrl = `/oauth/token`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "grant_type": params["grantType"],
            "client_id": params["clientId"],
            "client_secret": params["clientSecret"],
            "username": params["username"],
            "password": params["password"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccessTokenApi - functional programming interface
 */
export const AccessTokenApiFp = {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client.  Used only with a grant_type of password
     * @param password The password of the client.  Used only with a grant_type of password
     */
    getOAuthToken(params: { grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OAuth2Resource> {
        const fetchArgs = AccessTokenApiFetchParamCreator.getOAuthToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccessTokenApi - object-oriented interface
 */
export class AccessTokenApi extends BaseAPI {
    /**
     * 
     * @summary Get access token
     * @param grantType Grant type
     * @param clientId The id of the client
     * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
     * @param username The username of the client.  Used only with a grant_type of password
     * @param password The password of the client.  Used only with a grant_type of password
     */
    getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; }, options: any = {}) {
        return AccessTokenApiFp.getOAuthToken(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccessTokenApi - factory interface
 */
export const AccessTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get access token
         * @param grantType Grant type
         * @param clientId The id of the client
         * @param clientSecret The secret key of the client.  Used only with a grant_type of client_credentials
         * @param username The username of the client.  Used only with a grant_type of password
         * @param password The password of the client.  Used only with a grant_type of password
         */
        getOAuthToken(params: {  grantType: string; clientId: string; clientSecret?: string; username?: string; password?: string; }, options: any = {}) {
            return AccessTokenApiFp.getOAuthToken(params, options)(fetch, basePath);
        },
    };
};


/**
 * ActivitiesApi - fetch parameter creator
 */
export const ActivitiesApiFetchParamCreator = {
    /**
     * 
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  activityResource?: ActivityResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Has to enforce extra rules if not used as an admin
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: ActivityOccurrenceResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/activity-occurrences`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["test"] !== undefined) {
            urlObj.query["test"] = params["test"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResource"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Activity Templates define a type of activity and the properties they have
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["activityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/activities`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterId"] !== undefined) {
            urlObj.query["filter_id"] = params["filterId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling setActivityOccurrenceResults");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/results`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityOccurrenceResults"]) {
            fetchOptions.body = JSON.stringify(params["activityOccurrenceResults"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  id: number; activityResource?: ActivityResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateActivity");
        }
        const baseUrl = `/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityResource"]) {
            fetchOptions.body = JSON.stringify(params["activityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If setting to 'FINISHED' you must POST to /results instead to record the metrics and get synchronous reward results
     * @summary Updated the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: {  activityOccurrenceId: number; activityCccurrenceStatus?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "activityOccurrenceId" is set
        if (params["activityOccurrenceId"] == null) {
            throw new Error("Missing required parameter activityOccurrenceId when calling updateActivityOccurrence");
        }
        const baseUrl = `/activity-occurrences/{activity_occurrence_id}/status`
            .replace(`{${"activity_occurrence_id"}}`, `${ params["activityOccurrenceId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityCccurrenceStatus"]) {
            fetchOptions.body = JSON.stringify(params["activityCccurrenceStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateActivityTemplate");
        }
        const baseUrl = `/activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["activityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["activityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ActivitiesApi - functional programming interface
 */
export const ActivitiesApiFp = {
    /**
     * 
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: { activityResource?: ActivityResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Has to enforce extra rules if not used as an admin
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: { test?: boolean; activityOccurrenceResource?: ActivityOccurrenceResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivityOccurrence(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Activity Templates define a type of activity and the properties they have
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: { activityTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.createActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.deleteActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.deleteActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: { filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBareActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivities(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.getActivityTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: { activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityOccurrenceResults> {
        const fetchArgs = ActivitiesApiFetchParamCreator.setActivityOccurrenceResults(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: { id: number; activityResource?: ActivityResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ActivityResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If setting to 'FINISHED' you must POST to /results instead to record the metrics and get synchronous reward results
     * @summary Updated the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: { activityOccurrenceId: number; activityCccurrenceStatus?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivityOccurrence(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: { id: string; activityTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ActivitiesApiFetchParamCreator.updateActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ActivitiesApi - object-oriented interface
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * 
     * @summary Create an activity
     * @param activityResource The activity resource object
     */
    createActivity(params: {  activityResource?: ActivityResource; }, options: any = {}) {
        return ActivitiesApiFp.createActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * Has to enforce extra rules if not used as an admin
     * @summary Create a new activity occurrence. Ex: start a game
     * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
     * @param activityOccurrenceResource The activity occurrence object
     */
    createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: ActivityOccurrenceResource; }, options: any = {}) {
        return ActivitiesApiFp.createActivityOccurrence(params, options)(this.fetch, this.basePath);
    }
    /**
     * Activity Templates define a type of activity and the properties they have
     * @summary Create a activity template
     * @param activityTemplateResource The activity template resource object
     */
    createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, options: any = {}) {
        return ActivitiesApiFp.createActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an activity
     * @param id The id of the activity
     */
    deleteActivity(params: {  id: number; }, options: any = {}) {
        return ActivitiesApiFp.deleteActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return ActivitiesApiFp.deleteActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List activity definitions
     * @param filterTemplate Filter for activities that are templates, or specifically not if false
     * @param filterName Filter for activities that have a name starting with specified string
     * @param filterId Filter for activities with an id in the given comma separated list of ids
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivities(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single activity
     * @param id The id of the activity
     */
    getActivity(params: {  id: number; }, options: any = {}) {
        return ActivitiesApiFp.getActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single activity template
     * @param id The id of the template
     */
    getActivityTemplate(params: {  id: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ActivitiesApiFp.getActivityTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityOccurrenceResults The activity occurrence object
     */
    setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, options: any = {}) {
        return ActivitiesApiFp.setActivityOccurrenceResults(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an activity
     * @param id The id of the activity
     * @param activityResource The activity resource object
     */
    updateActivity(params: {  id: number; activityResource?: ActivityResource; }, options: any = {}) {
        return ActivitiesApiFp.updateActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * If setting to 'FINISHED' you must POST to /results instead to record the metrics and get synchronous reward results
     * @summary Updated the status of an activity occurrence
     * @param activityOccurrenceId The id of the activity occurrence
     * @param activityCccurrenceStatus The activity occurrence status object
     */
    updateActivityOccurrence(params: {  activityOccurrenceId: number; activityCccurrenceStatus?: string; }, options: any = {}) {
        return ActivitiesApiFp.updateActivityOccurrence(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an activity template
     * @param id The id of the template
     * @param activityTemplateResource The activity template resource object
     */
    updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, options: any = {}) {
        return ActivitiesApiFp.updateActivityTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ActivitiesApi - factory interface
 */
export const ActivitiesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create an activity
         * @param activityResource The activity resource object
         */
        createActivity(params: {  activityResource?: ActivityResource; }, options: any = {}) {
            return ActivitiesApiFp.createActivity(params, options)(fetch, basePath);
        },
        /**
         * Has to enforce extra rules if not used as an admin
         * @summary Create a new activity occurrence. Ex: start a game
         * @param test if true, indicates that the occurrence should NOT be created. This can be used to test for eligibility and valid settings
         * @param activityOccurrenceResource The activity occurrence object
         */
        createActivityOccurrence(params: {  test?: boolean; activityOccurrenceResource?: ActivityOccurrenceResource; }, options: any = {}) {
            return ActivitiesApiFp.createActivityOccurrence(params, options)(fetch, basePath);
        },
        /**
         * Activity Templates define a type of activity and the properties they have
         * @summary Create a activity template
         * @param activityTemplateResource The activity template resource object
         */
        createActivityTemplate(params: {  activityTemplateResource?: TemplateResource; }, options: any = {}) {
            return ActivitiesApiFp.createActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an activity
         * @param id The id of the activity
         */
        deleteActivity(params: {  id: number; }, options: any = {}) {
            return ActivitiesApiFp.deleteActivity(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a activity template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return ActivitiesApiFp.deleteActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List activity definitions
         * @param filterTemplate Filter for activities that are templates, or specifically not if false
         * @param filterName Filter for activities that have a name starting with specified string
         * @param filterId Filter for activities with an id in the given comma separated list of ids
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getActivities(params: {  filterTemplate?: boolean; filterName?: string; filterId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ActivitiesApiFp.getActivities(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single activity
         * @param id The id of the activity
         */
        getActivity(params: {  id: number; }, options: any = {}) {
            return ActivitiesApiFp.getActivity(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single activity template
         * @param id The id of the template
         */
        getActivityTemplate(params: {  id: string; }, options: any = {}) {
            return ActivitiesApiFp.getActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search activity templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return ActivitiesApiFp.getActivityTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sets the status of an activity occurrence to FINISHED and logs metrics
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityOccurrenceResults The activity occurrence object
         */
        setActivityOccurrenceResults(params: {  activityOccurrenceId: number; activityOccurrenceResults?: ActivityOccurrenceResultsResource; }, options: any = {}) {
            return ActivitiesApiFp.setActivityOccurrenceResults(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an activity
         * @param id The id of the activity
         * @param activityResource The activity resource object
         */
        updateActivity(params: {  id: number; activityResource?: ActivityResource; }, options: any = {}) {
            return ActivitiesApiFp.updateActivity(params, options)(fetch, basePath);
        },
        /**
         * If setting to 'FINISHED' you must POST to /results instead to record the metrics and get synchronous reward results
         * @summary Updated the status of an activity occurrence
         * @param activityOccurrenceId The id of the activity occurrence
         * @param activityCccurrenceStatus The activity occurrence status object
         */
        updateActivityOccurrence(params: {  activityOccurrenceId: number; activityCccurrenceStatus?: string; }, options: any = {}) {
            return ActivitiesApiFp.updateActivityOccurrence(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an activity template
         * @param id The id of the template
         * @param activityTemplateResource The activity template resource object
         */
        updateActivityTemplate(params: {  id: string; activityTemplateResource?: TemplateResource; }, options: any = {}) {
            return ActivitiesApiFp.updateActivityTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * AmazonWebServicesS3Api - fetch parameter creator
 */
export const AmazonWebServicesS3ApiFetchParamCreator = {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details.
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/amazon/s3/downloadurl`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["bucket"] !== undefined) {
            urlObj.query["bucket"] = params["bucket"];
        }
        if (params["path"] !== undefined) {
            urlObj.query["path"] = params["path"];
        }
        if (params["expiration"] !== undefined) {
            urlObj.query["expiration"] = params["expiration"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after.
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  filename?: string; contentType?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/amazon/s3/signedposturl`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filename"] !== undefined) {
            urlObj.query["filename"] = params["filename"];
        }
        if (params["contentType"] !== undefined) {
            urlObj.query["content_type"] = params["contentType"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AmazonWebServicesS3Api - functional programming interface
 */
export const AmazonWebServicesS3ApiFp = {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details.
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: { bucket?: string; path?: string; expiration?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = AmazonWebServicesS3ApiFetchParamCreator.getDownloadURL(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after.
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: { filename?: string; contentType?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AmazonS3Activity> {
        const fetchArgs = AmazonWebServicesS3ApiFetchParamCreator.getSignedS3URL(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AmazonWebServicesS3Api - object-oriented interface
 */
export class AmazonWebServicesS3Api extends BaseAPI {
    /**
     * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details.
     * @summary Get a temporary signed S3 URL for download
     * @param bucket S3 bucket name
     * @param path The path to the file relative the bucket (the s3 object key)
     * @param expiration The number of seconds this URL will be valid. Default to 60
     */
    getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, options: any = {}) {
        return AmazonWebServicesS3ApiFp.getDownloadURL(params, options)(this.fetch, this.basePath);
    }
    /**
     * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after.
     * @summary Get a signed S3 URL for upload
     * @param filename The file name
     * @param contentType The content type
     */
    getSignedS3URL(params: {  filename?: string; contentType?: string; }, options: any = {}) {
        return AmazonWebServicesS3ApiFp.getSignedS3URL(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AmazonWebServicesS3Api - factory interface
 */
export const AmazonWebServicesS3ApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * To give access to files in your own S3 account, you will need to grant KnetikcCloud access to the file by adjusting your bucket policy accordingly. See S3 documentation for details.
         * @summary Get a temporary signed S3 URL for download
         * @param bucket S3 bucket name
         * @param path The path to the file relative the bucket (the s3 object key)
         * @param expiration The number of seconds this URL will be valid. Default to 60
         */
        getDownloadURL(params: {  bucket?: string; path?: string; expiration?: number; }, options: any = {}) {
            return AmazonWebServicesS3ApiFp.getDownloadURL(params, options)(fetch, basePath);
        },
        /**
         * Requires the file name and file content type (i.e., 'video/mpeg'). Make a PUT to the resulting url to upload the file and use the cdn_url to retrieve it after.
         * @summary Get a signed S3 URL for upload
         * @param filename The file name
         * @param contentType The content type
         */
        getSignedS3URL(params: {  filename?: string; contentType?: string; }, options: any = {}) {
            return AmazonWebServicesS3ApiFp.getSignedS3URL(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthClientsApi - fetch parameter creator
 */
export const AuthClientsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  clientResource?: ClientResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  clientKey: string; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling deleteClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  clientKey: string; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List available client grant types
     */
    getClientGrantTypes(options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients/grant-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/clients`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientGrantTypes");
        }
        const baseUrl = `/auth/clients/{client_key}/grant-types`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantList"]) {
            fetchOptions.body = JSON.stringify(params["grantList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRedirectUris");
        }
        const baseUrl = `/auth/clients/{client_key}/redirect-uris`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["redirectList"]) {
            fetchOptions.body = JSON.stringify(params["redirectList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling updateClient");
        }
        const baseUrl = `/auth/clients/{client_key}`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["clientResource"]) {
            fetchOptions.body = JSON.stringify(params["clientResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthClientsApi - functional programming interface
 */
export const AuthClientsApiFp = {
    /**
     * 
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: { clientResource?: ClientResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.createClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: { clientKey: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.deleteClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: { clientKey: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List available client grant types
     */
    getClientGrantTypes(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<GrantTypeResource>> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClientGrantTypes(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.getClients(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: { clientKey: string; grantList?: Array<string>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.setClientGrantTypes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: { clientKey: string; redirectList?: Array<string>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthClientsApiFetchParamCreator.setClientRedirectUris(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: { clientKey: string; clientResource?: ClientResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthClientsApiFetchParamCreator.updateClient(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthClientsApi - object-oriented interface
 */
export class AuthClientsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new client
     * @param clientResource The client resource object
     */
    createClient(params: {  clientResource?: ClientResource; }, options: any = {}) {
        return AuthClientsApiFp.createClient(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a client
     * @param clientKey The key of the client
     */
    deleteClient(params: {  clientKey: string; }, options: any = {}) {
        return AuthClientsApiFp.deleteClient(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single client
     * @param clientKey The key of the client
     */
    getClient(params: {  clientKey: string; }, options: any = {}) {
        return AuthClientsApiFp.getClient(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List available client grant types
     */
    getClientGrantTypes(options: any = {}) {
        return AuthClientsApiFp.getClientGrantTypes(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search clients
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getClients(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return AuthClientsApiFp.getClients(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set grant types for a client
     * @param clientKey The key of the client
     * @param grantList A list of unique grant types
     */
    setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, options: any = {}) {
        return AuthClientsApiFp.setClientGrantTypes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set redirect uris for a client
     * @param clientKey The key of the client
     * @param redirectList A list of unique redirect uris
     */
    setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, options: any = {}) {
        return AuthClientsApiFp.setClientRedirectUris(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a client
     * @param clientKey The key of the client
     * @param clientResource The client resource object
     */
    updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, options: any = {}) {
        return AuthClientsApiFp.updateClient(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthClientsApi - factory interface
 */
export const AuthClientsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new client
         * @param clientResource The client resource object
         */
        createClient(params: {  clientResource?: ClientResource; }, options: any = {}) {
            return AuthClientsApiFp.createClient(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a client
         * @param clientKey The key of the client
         */
        deleteClient(params: {  clientKey: string; }, options: any = {}) {
            return AuthClientsApiFp.deleteClient(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single client
         * @param clientKey The key of the client
         */
        getClient(params: {  clientKey: string; }, options: any = {}) {
            return AuthClientsApiFp.getClient(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available client grant types
         */
        getClientGrantTypes(options: any = {}) {
            return AuthClientsApiFp.getClientGrantTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search clients
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getClients(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return AuthClientsApiFp.getClients(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set grant types for a client
         * @param clientKey The key of the client
         * @param grantList A list of unique grant types
         */
        setClientGrantTypes(params: {  clientKey: string; grantList?: Array<string>; }, options: any = {}) {
            return AuthClientsApiFp.setClientGrantTypes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set redirect uris for a client
         * @param clientKey The key of the client
         * @param redirectList A list of unique redirect uris
         */
        setClientRedirectUris(params: {  clientKey: string; redirectList?: Array<string>; }, options: any = {}) {
            return AuthClientsApiFp.setClientRedirectUris(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a client
         * @param clientKey The key of the client
         * @param clientResource The client resource object
         */
        updateClient(params: {  clientKey: string; clientResource?: ClientResource; }, options: any = {}) {
            return AuthClientsApiFp.updateClient(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthPermissionsApi - fetch parameter creator
 */
export const AuthPermissionsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  permissionResource?: PermissionResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  permission: string; force?: boolean; }, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling deletePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["force"] !== undefined) {
            urlObj.query["force"] = params["force"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  permission: string; }, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling getPermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/permissions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "permission" is set
        if (params["permission"] == null) {
            throw new Error("Missing required parameter permission when calling updatePermission");
        }
        const baseUrl = `/auth/permissions/{permission}`
            .replace(`{${"permission"}}`, `${ params["permission"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionResource"]) {
            fetchOptions.body = JSON.stringify(params["permissionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthPermissionsApi - functional programming interface
 */
export const AuthPermissionsApiFp = {
    /**
     * 
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: { permissionResource?: PermissionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.createPermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: { permission: string; force?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.deletePermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: { permission: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.getPermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcePermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.getPermissions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: { permission: string; permissionResource?: PermissionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PermissionResource> {
        const fetchArgs = AuthPermissionsApiFetchParamCreator.updatePermission(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthPermissionsApi - object-oriented interface
 */
export class AuthPermissionsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new permission
     * @param permissionResource The permission resource object
     */
    createPermission(params: {  permissionResource?: PermissionResource; }, options: any = {}) {
        return AuthPermissionsApiFp.createPermission(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a permission
     * @param permission The permission value
     * @param force If true, removes permission assigned to roles
     */
    deletePermission(params: {  permission: string; force?: boolean; }, options: any = {}) {
        return AuthPermissionsApiFp.deletePermission(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single permission
     * @param permission The permission value
     */
    getPermission(params: {  permission: string; }, options: any = {}) {
        return AuthPermissionsApiFp.getPermission(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search permissions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPermissions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return AuthPermissionsApiFp.getPermissions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a permission
     * @param permission The permission value
     * @param permissionResource The permission resource object
     */
    updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, options: any = {}) {
        return AuthPermissionsApiFp.updatePermission(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthPermissionsApi - factory interface
 */
export const AuthPermissionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new permission
         * @param permissionResource The permission resource object
         */
        createPermission(params: {  permissionResource?: PermissionResource; }, options: any = {}) {
            return AuthPermissionsApiFp.createPermission(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a permission
         * @param permission The permission value
         * @param force If true, removes permission assigned to roles
         */
        deletePermission(params: {  permission: string; force?: boolean; }, options: any = {}) {
            return AuthPermissionsApiFp.deletePermission(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single permission
         * @param permission The permission value
         */
        getPermission(params: {  permission: string; }, options: any = {}) {
            return AuthPermissionsApiFp.getPermission(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search permissions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPermissions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return AuthPermissionsApiFp.getPermissions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a permission
         * @param permission The permission value
         * @param permissionResource The permission resource object
         */
        updatePermission(params: {  permission: string; permissionResource?: PermissionResource; }, options: any = {}) {
            return AuthPermissionsApiFp.updatePermission(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthRolesApi - fetch parameter creator
 */
export const AuthRolesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  roleResource?: RoleResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  role: string; force?: boolean; }, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling deleteRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["force"] !== undefined) {
            urlObj.query["force"] = params["force"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  clientKey: string; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling getClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: {  role: string; }, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling getRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/roles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterRole"] !== undefined) {
            urlObj.query["filter_role"] = params["filterRole"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, options: any = {}): FetchArgs {
        // verify required parameter "clientKey" is set
        if (params["clientKey"] == null) {
            throw new Error("Missing required parameter clientKey when calling setClientRoles");
        }
        const baseUrl = `/auth/clients/{client_key}/roles`
            .replace(`{${"client_key"}}`, `${ params["clientKey"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling setPermissionsForRole");
        }
        const baseUrl = `/auth/roles/{role}/permissions`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["permissionsList"]) {
            fetchOptions.body = JSON.stringify(params["permissionsList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserRoles");
        }
        const baseUrl = `/auth/users/{user_id}/roles`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rolesList"]) {
            fetchOptions.body = JSON.stringify(params["rolesList"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  role: string; roleResource?: RoleResource; }, options: any = {}): FetchArgs {
        // verify required parameter "role" is set
        if (params["role"] == null) {
            throw new Error("Missing required parameter role when calling updateRole");
        }
        const baseUrl = `/auth/roles/{role}`
            .replace(`{${"role"}}`, `${ params["role"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["roleResource"]) {
            fetchOptions.body = JSON.stringify(params["roleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthRolesApi - functional programming interface
 */
export const AuthRolesApiFp = {
    /**
     * 
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: { roleResource?: RoleResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.createRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: { role: string; force?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthRolesApiFetchParamCreator.deleteRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: { clientKey: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getClientRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: { role: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: { filterName?: string; filterRole?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: { userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<RoleResource>> {
        const fetchArgs = AuthRolesApiFetchParamCreator.getUserRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: { clientKey: string; rolesList?: Array<string>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ClientResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setClientRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: { role: string; permissionsList?: Array<string>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setPermissionsForRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: { userId: number; rolesList?: Array<string>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.setUserRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: { role: string; roleResource?: RoleResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RoleResource> {
        const fetchArgs = AuthRolesApiFetchParamCreator.updateRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthRolesApi - object-oriented interface
 */
export class AuthRolesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new role
     * @param roleResource The role resource object
     */
    createRole(params: {  roleResource?: RoleResource; }, options: any = {}) {
        return AuthRolesApiFp.createRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a role
     * @param role The role value
     * @param force If true, removes role from users/clients
     */
    deleteRole(params: {  role: string; force?: boolean; }, options: any = {}) {
        return AuthRolesApiFp.deleteRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get roles for a client
     * @param clientKey The client key
     */
    getClientRoles(params: {  clientKey: string; }, options: any = {}) {
        return AuthRolesApiFp.getClientRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single role
     * @param role The role value
     */
    getRole(params: {  role: string; }, options: any = {}) {
        return AuthRolesApiFp.getRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search roles
     * @param filterName Filter for roles that have a name starting with specified string
     * @param filterRole Filter for roles that have a role starting with specified string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return AuthRolesApiFp.getRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get roles for a user
     * @param userId The user&#39;s id
     */
    getUserRoles(params: {  userId: number; }, options: any = {}) {
        return AuthRolesApiFp.getUserRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set roles for a client
     * @param clientKey The client key
     * @param rolesList The list of unique roles
     */
    setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, options: any = {}) {
        return AuthRolesApiFp.setClientRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set permissions for a role
     * @param role The role value
     * @param permissionsList The list of unique permissions
     */
    setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, options: any = {}) {
        return AuthRolesApiFp.setPermissionsForRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set roles for a user
     * @param userId The user&#39;s id
     * @param rolesList The list of unique roles
     */
    setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, options: any = {}) {
        return AuthRolesApiFp.setUserRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a role
     * @param role The role value
     * @param roleResource The role resource object
     */
    updateRole(params: {  role: string; roleResource?: RoleResource; }, options: any = {}) {
        return AuthRolesApiFp.updateRole(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthRolesApi - factory interface
 */
export const AuthRolesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new role
         * @param roleResource The role resource object
         */
        createRole(params: {  roleResource?: RoleResource; }, options: any = {}) {
            return AuthRolesApiFp.createRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a role
         * @param role The role value
         * @param force If true, removes role from users/clients
         */
        deleteRole(params: {  role: string; force?: boolean; }, options: any = {}) {
            return AuthRolesApiFp.deleteRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get roles for a client
         * @param clientKey The client key
         */
        getClientRoles(params: {  clientKey: string; }, options: any = {}) {
            return AuthRolesApiFp.getClientRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single role
         * @param role The role value
         */
        getRole(params: {  role: string; }, options: any = {}) {
            return AuthRolesApiFp.getRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search roles
         * @param filterName Filter for roles that have a name starting with specified string
         * @param filterRole Filter for roles that have a role starting with specified string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRoles(params: {  filterName?: string; filterRole?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return AuthRolesApiFp.getRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get roles for a user
         * @param userId The user&#39;s id
         */
        getUserRoles(params: {  userId: number; }, options: any = {}) {
            return AuthRolesApiFp.getUserRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set roles for a client
         * @param clientKey The client key
         * @param rolesList The list of unique roles
         */
        setClientRoles(params: {  clientKey: string; rolesList?: Array<string>; }, options: any = {}) {
            return AuthRolesApiFp.setClientRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set permissions for a role
         * @param role The role value
         * @param permissionsList The list of unique permissions
         */
        setPermissionsForRole(params: {  role: string; permissionsList?: Array<string>; }, options: any = {}) {
            return AuthRolesApiFp.setPermissionsForRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set roles for a user
         * @param userId The user&#39;s id
         * @param rolesList The list of unique roles
         */
        setUserRoles(params: {  userId: number; rolesList?: Array<string>; }, options: any = {}) {
            return AuthRolesApiFp.setUserRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a role
         * @param role The role value
         * @param roleResource The role resource object
         */
        updateRole(params: {  role: string; roleResource?: RoleResource; }, options: any = {}) {
            return AuthRolesApiFp.updateRole(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthTokensApi - fetch parameter creator
 */
export const AuthTokensApiFetchParamCreator = {
    /**
     * 
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: {  username?: string; clientId?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/tokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["username"] !== undefined) {
            urlObj.query["username"] = params["username"];
        }
        if (params["clientId"] !== undefined) {
            urlObj.query["client_id"] = params["clientId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  username: string; clientId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling getToken");
        }
        // verify required parameter "clientId" is set
        if (params["clientId"] == null) {
            throw new Error("Missing required parameter clientId when calling getToken");
        }
        const baseUrl = `/auth/tokens/{username}/{client_id}`
            .replace(`{${"username"}}`, `${ params["username"] }`)
            .replace(`{${"client_id"}}`, `${ params["clientId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Token value not shown
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/auth/tokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterClientId"] !== undefined) {
            urlObj.query["filter_client_id"] = params["filterClientId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthTokensApi - functional programming interface
 */
export const AuthTokensApiFp = {
    /**
     * 
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: { username?: string; clientId?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AuthTokensApiFetchParamCreator.deleteTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: { username: string; clientId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<OauthAccessTokenResource> {
        const fetchArgs = AuthTokensApiFetchParamCreator.getToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Token value not shown
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: { filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceOauthAccessTokenResource> {
        const fetchArgs = AuthTokensApiFetchParamCreator.getTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthTokensApi - object-oriented interface
 */
export class AuthTokensApi extends BaseAPI {
    /**
     * 
     * @summary Delete tokens by username, client id, or both
     * @param username The username of the user
     * @param clientId The id of the client
     */
    deleteTokens(params: {  username?: string; clientId?: string; }, options: any = {}) {
        return AuthTokensApiFp.deleteTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single token by username and client id
     * @param username The username of the user
     * @param clientId The id of the client
     */
    getToken(params: {  username: string; clientId: string; }, options: any = {}) {
        return AuthTokensApiFp.getToken(params, options)(this.fetch, this.basePath);
    }
    /**
     * Token value not shown
     * @summary List usernames and client ids
     * @param filterClientId Filters for token whose client id matches provided string
     * @param filterUsername Filters for token whose username matches provided string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return AuthTokensApiFp.getTokens(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthTokensApi - factory interface
 */
export const AuthTokensApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete tokens by username, client id, or both
         * @param username The username of the user
         * @param clientId The id of the client
         */
        deleteTokens(params: {  username?: string; clientId?: string; }, options: any = {}) {
            return AuthTokensApiFp.deleteTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single token by username and client id
         * @param username The username of the user
         * @param clientId The id of the client
         */
        getToken(params: {  username: string; clientId: string; }, options: any = {}) {
            return AuthTokensApiFp.getToken(params, options)(fetch, basePath);
        },
        /**
         * Token value not shown
         * @summary List usernames and client ids
         * @param filterClientId Filters for token whose client id matches provided string
         * @param filterUsername Filters for token whose username matches provided string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTokens(params: {  filterClientId?: string; filterUsername?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return AuthTokensApiFp.getTokens(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineActionsApi - fetch parameter creator
 */
export const BRERuleEngineActionsApiFetchParamCreator = {
    /**
     * 
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/actions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterTags"] !== undefined) {
            urlObj.query["filter_tags"] = params["filterTags"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineActionsApi - functional programming interface
 */
export const BRERuleEngineActionsApiFp = {
    /**
     * 
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: { filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<ActionResource>> {
        const fetchArgs = BRERuleEngineActionsApiFetchParamCreator.getBREActions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineActionsApi - object-oriented interface
 */
export class BRERuleEngineActionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of available actions
     * @param filterCategory Filter for actions that are within a specific category
     * @param filterName Filter for actions that have names containing the given string
     * @param filterTags Filter for actions that have all of the given tags (comma separated list)
     * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
     */
    getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, options: any = {}) {
        return BRERuleEngineActionsApiFp.getBREActions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineActionsApi - factory interface
 */
export const BRERuleEngineActionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a list of available actions
         * @param filterCategory Filter for actions that are within a specific category
         * @param filterName Filter for actions that have names containing the given string
         * @param filterTags Filter for actions that have all of the given tags (comma separated list)
         * @param filterSearch Filter for actions containing the given words somewhere within name, description and tags
         */
        getBREActions(params: {  filterCategory?: string; filterName?: string; filterTags?: string; filterSearch?: string; }, options: any = {}) {
            return BRERuleEngineActionsApiFp.getBREActions(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineCategoriesApi - fetch parameter creator
 */
export const BRERuleEngineCategoriesApiFetchParamCreator = {
    /**
     * Templates define a type of BRE category and the properties they have
     * @summary Create a BRE category template
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a BRE category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: {  size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single category
     * @param name The category name
     */
    getBRECategory(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getBRECategory");
        }
        const baseUrl = `/bre/categories/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: {  name: string; category?: BreCategoryResource; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateBRECategory");
        }
        const baseUrl = `/bre/categories/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBRECategoryTemplate");
        }
        const baseUrl = `/bre/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineCategoriesApi - functional programming interface
 */
export const BRERuleEngineCategoriesApiFp = {
    /**
     * Templates define a type of BRE category and the properties they have
     * @summary Create a BRE category template
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: { template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.createBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a BRE category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.deleteBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: { size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreCategoryResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single category
     * @param name The category name
     */
    getBRECategory(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreCategoryResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.getBRECategoryTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: { name: string; category?: BreCategoryResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreCategoryResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.updateBRECategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: { id: string; template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = BRERuleEngineCategoriesApiFetchParamCreator.updateBRECategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineCategoriesApi - object-oriented interface
 */
export class BRERuleEngineCategoriesApi extends BaseAPI {
    /**
     * Templates define a type of BRE category and the properties they have
     * @summary Create a BRE category template
     * @param template The category template to create
     */
    createBRECategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.createBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a BRE category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteBRECategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.deleteBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List categories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRECategories(params: {  size?: number; page?: number; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.getBRECategories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single category
     * @param name The category name
     */
    getBRECategory(params: {  name: string; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.getBRECategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single BRE category template
     * @param id The id of the template
     */
    getBRECategoryTemplate(params: {  id: string; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.getBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search BRE category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBRECategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.getBRECategoryTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a category
     * @param name The category name
     * @param category The updated BRE category information
     */
    updateBRECategory(params: {  name: string; category?: BreCategoryResource; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.updateBRECategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a BRE category template
     * @param id The id of the template
     * @param template The updated category template definition
     */
    updateBRECategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
        return BRERuleEngineCategoriesApiFp.updateBRECategoryTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineCategoriesApi - factory interface
 */
export const BRERuleEngineCategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Templates define a type of BRE category and the properties they have
         * @summary Create a BRE category template
         * @param template The category template to create
         */
        createBRECategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.createBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a BRE category template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteBRECategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.deleteBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List categories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRECategories(params: {  size?: number; page?: number; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.getBRECategories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single category
         * @param name The category name
         */
        getBRECategory(params: {  name: string; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.getBRECategory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single BRE category template
         * @param id The id of the template
         */
        getBRECategoryTemplate(params: {  id: string; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.getBRECategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search BRE category templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBRECategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.getBRECategoryTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a category
         * @param name The category name
         * @param category The updated BRE category information
         */
        updateBRECategory(params: {  name: string; category?: BreCategoryResource; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.updateBRECategory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a BRE category template
         * @param id The id of the template
         * @param template The updated category template definition
         */
        updateBRECategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
            return BRERuleEngineCategoriesApiFp.updateBRECategoryTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineEventsApi - fetch parameter creator
 */
export const BRERuleEngineEventsApiFetchParamCreator = {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  breEvent?: BreEvent; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/events`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breEvent"]) {
            fetchOptions.body = JSON.stringify(params["breEvent"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineEventsApi - functional programming interface
 */
export const BRERuleEngineEventsApiFp = {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: { breEvent?: BreEvent;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BRERuleEngineEventsApiFetchParamCreator.sendBREEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineEventsApi - object-oriented interface
 */
export class BRERuleEngineEventsApi extends BaseAPI {
    /**
     * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id
     * @summary Fire a new event, based on an existing trigger
     * @param breEvent The BRE event object
     */
    sendBREEvent(params: {  breEvent?: BreEvent; }, options: any = {}) {
        return BRERuleEngineEventsApiFp.sendBREEvent(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineEventsApi - factory interface
 */
export const BRERuleEngineEventsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Parameters within the event must match names and types from the trigger. Actual rule execution is asynchornous.  Returns request id, which will be used as the event id
         * @summary Fire a new event, based on an existing trigger
         * @param breEvent The BRE event object
         */
        sendBREEvent(params: {  breEvent?: BreEvent; }, options: any = {}) {
            return BRERuleEngineEventsApiFp.sendBREEvent(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineExpressionsApi - fetch parameter creator
 */
export const BRERuleEngineExpressionsApiFetchParamCreator = {
    /**
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     * @summary Get a list of 'lookup' type expressions
     */
    getBREExpressions(options: any = {}): FetchArgs {
        const baseUrl = `/bre/expressions/lookup`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineExpressionsApi - functional programming interface
 */
export const BRERuleEngineExpressionsApiFp = {
    /**
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     * @summary Get a list of 'lookup' type expressions
     */
    getBREExpressions(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<LookupTypeResource>> {
        const fetchArgs = BRERuleEngineExpressionsApiFetchParamCreator.getBREExpressions(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineExpressionsApi - object-oriented interface
 */
export class BRERuleEngineExpressionsApi extends BaseAPI {
    /**
     * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
     * @summary Get a list of 'lookup' type expressions
     */
    getBREExpressions(options: any = {}) {
        return BRERuleEngineExpressionsApiFp.getBREExpressions(options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineExpressionsApi - factory interface
 */
export const BRERuleEngineExpressionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * These are expression types that take a second expression as input and produce a value. These can be used in addition to the standard types, like parameter, global and constant (see BRE documentation for details).
         * @summary Get a list of 'lookup' type expressions
         */
        getBREExpressions(options: any = {}) {
            return BRERuleEngineExpressionsApiFp.getBREExpressions(options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineGlobalsApi - fetch parameter creator
 */
export const BRERuleEngineGlobalsApiFetchParamCreator = {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core globals
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/globals/definitions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBREGlobal");
        }
        const baseUrl = `/bre/globals/definitions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breGlobalResource"]) {
            fetchOptions.body = JSON.stringify(params["breGlobalResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineGlobalsApi - functional programming interface
 */
export const BRERuleEngineGlobalsApiFp = {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: { breGlobalResource?: BreGlobalResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.createBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core globals
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.deleteBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.getBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: { filterSystem?: boolean; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.getBREGlobals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: { id: string; breGlobalResource?: BreGlobalResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreGlobalResource> {
        const fetchArgs = BRERuleEngineGlobalsApiFetchParamCreator.updateBREGlobal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineGlobalsApi - object-oriented interface
 */
export class BRERuleEngineGlobalsApi extends BaseAPI {
    /**
     * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
     * @summary Create a global definition
     * @param breGlobalResource The BRE global resource object
     */
    createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, options: any = {}) {
        return BRERuleEngineGlobalsApiFp.createBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core globals
     * @summary Delete a global
     * @param id The id of the global definition
     */
    deleteBREGlobal(params: {  id: string; }, options: any = {}) {
        return BRERuleEngineGlobalsApiFp.deleteBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single global definition
     * @param id The id of the global definition
     */
    getBREGlobal(params: {  id: string; }, options: any = {}) {
        return BRERuleEngineGlobalsApiFp.getBREGlobal(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List global definitions
     * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, options: any = {}) {
        return BRERuleEngineGlobalsApiFp.getBREGlobals(params, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
     * @summary Update a global definition
     * @param id The id of the global definition
     * @param breGlobalResource The BRE global resource object
     */
    updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, options: any = {}) {
        return BRERuleEngineGlobalsApiFp.updateBREGlobal(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineGlobalsApi - factory interface
 */
export const BRERuleEngineGlobalsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Once created you can then use in a custom rule. Note that global definitions cannot be modified or deleted if in use.
         * @summary Create a global definition
         * @param breGlobalResource The BRE global resource object
         */
        createBREGlobal(params: {  breGlobalResource?: BreGlobalResource; }, options: any = {}) {
            return BRERuleEngineGlobalsApiFp.createBREGlobal(params, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core globals
         * @summary Delete a global
         * @param id The id of the global definition
         */
        deleteBREGlobal(params: {  id: string; }, options: any = {}) {
            return BRERuleEngineGlobalsApiFp.deleteBREGlobal(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single global definition
         * @param id The id of the global definition
         */
        getBREGlobal(params: {  id: string; }, options: any = {}) {
            return BRERuleEngineGlobalsApiFp.getBREGlobal(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List global definitions
         * @param filterSystem Filter for globals that are system globals when true, or not when false. Leave off for both mixed
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBREGlobals(params: {  filterSystem?: boolean; size?: number; page?: number; }, options: any = {}) {
            return BRERuleEngineGlobalsApiFp.getBREGlobals(params, options)(fetch, basePath);
        },
        /**
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core globals
         * @summary Update a global definition
         * @param id The id of the global definition
         * @param breGlobalResource The BRE global resource object
         */
        updateBREGlobal(params: {  id: string; breGlobalResource?: BreGlobalResource; }, options: any = {}) {
            return BRERuleEngineGlobalsApiFp.updateBREGlobal(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineRulesApi - fetch parameter creator
 */
export const BRERuleEngineRulesApiFetchParamCreator = {
    /**
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...<h1>Boolean Operators</h1><br /><br />1 arg:<br />======<br /><br /><ul> <li>IS_NULL</li> <li>IS_NOT_NULL</li> <li>STRING_IS_EMPTY</li> <li>NOT </li> <li>MAP_IS_EMPTY</li></ul><br />2 args:<br />=======<br /><br /><ul> <li>EQ</li> <li>NE (Not Equals)</li> <li>GT (Greater Than)</li> <li>GOE (Greater Or Equals)</li> <li>LT (Lesser Than)</li> <li>LOE (Lesser Or Equals)</li> <li>OR</li> <li>AND</li> <li>XNOR</li> <li>XOR</li> <li>CONTAINS_KEY (for maps only)</li> <li>CONTAINS_VALUE (for maps only)</li> <li>MATCHES (regex)</li> <li>MATCHES_IC (regex ignore case)</li> <li>STARTS_WITH</li> <li>STARTS_WITH_IC</li> <li>EQ_IGNORE_CASE</li> <li>ENDS_WITH</li> <li>ENDS_WITH_IC</li> <li>STRING_CONTAINS</li> <li>STRING_CONTAINS_IC</li> <li>LIKE (SQL like)</li></ul><br />3 args exceptions:<br />=================<br /><br /><ul> <li>BETWEEN</li></ul><br />n args:<br />=======<br /><br /><ul> <li>IN</li> <li>NOT_INT</li></ul><h1>Math Operators</h1>1 arg:<br />=====<br /><br /><ul> <li>NEGATE</li> <li>MAP_SIZE</li> <li>STRING_LENGTH</li> <li>CEIL</li> <li>ABS</li> <li>FLOOR</li> <li>ROUND</li> <li>RANDOM (no arg)</li> <li>RANDOM2 (seed arg)</li> <li>NUMCAST</li> <li>HOUR</li> <li>MINUTE</li> <li>SECOND</li> <li>MILLISECOND</li> <li>YEAR</li> <li>WEEK</li> <li>YEAR_MONTH</li> <li>YEAR_WEEK</li> <li>DAY_OF_WEEK</li> <li>DAY_OF_MONTH</li> <li>DAY_OF_YEAR</li> <li>WEEK</li> <li>WEEK</li> <li>WEEK</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>ADD</li> <li>DIV</li> <li>MULT</li> <li>SUB</li> <li>POWER</li> <li>MOD</li> <li>LOCATE (index of (string, char))</li> <li>DIFF_YEARS</li> <li>DIFF_MONTHS</li> <li>DIFF_WEEKS</li> <li>DIFF_DAYS</li> <li>DIFF_HOURS</li> <li>DIFF_MINUTES</li> <li>DIFF_SECONDS</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>MIN</li> <li>MAX</li></ul><h1>String Operators</h1>0 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li></ul><br /><br />1 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li> <li>LOWER</li> <li>UPPER</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />2 args:<br />=====<br /><br /><ul> <li>CHAR_AT</li> <li>SUBSTR_1ARG (substr(string, start))</li> <li>CONCAT</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />3 args:<br />=====<br /><br /><ul> <li>SUBSTR_2ARGS (substr(string, start, length))</li></ul>
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  breRule?: BreRule; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core rules
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  expression?: Expressionobject; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules/expression-as-string`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["expression"]) {
            fetchOptions.body = JSON.stringify(params["expression"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/rules`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterEnabled"] !== undefined) {
            urlObj.query["filter_enabled"] = params["filterEnabled"];
        }
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["filterTrigger"] !== undefined) {
            urlObj.query["filter_trigger"] = params["filterTrigger"];
        }
        if (params["filterAction"] !== undefined) {
            urlObj.query["filter_action"] = params["filterAction"];
        }
        if (params["filterCondition"] !== undefined) {
            urlObj.query["filter_condition"] = params["filterCondition"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  id: string; enabled?: BooleanResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setBRERule");
        }
        const baseUrl = `/bre/rules/{id}/enabled`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["enabled"]) {
            fetchOptions.body = JSON.stringify(params["enabled"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Cannot update system rules
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  id: string; breRule?: BreRule; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBRERule");
        }
        const baseUrl = `/bre/rules/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breRule"]) {
            fetchOptions.body = JSON.stringify(params["breRule"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineRulesApi - functional programming interface
 */
export const BRERuleEngineRulesApiFp = {
    /**
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...<h1>Boolean Operators</h1><br /><br />1 arg:<br />======<br /><br /><ul> <li>IS_NULL</li> <li>IS_NOT_NULL</li> <li>STRING_IS_EMPTY</li> <li>NOT </li> <li>MAP_IS_EMPTY</li></ul><br />2 args:<br />=======<br /><br /><ul> <li>EQ</li> <li>NE (Not Equals)</li> <li>GT (Greater Than)</li> <li>GOE (Greater Or Equals)</li> <li>LT (Lesser Than)</li> <li>LOE (Lesser Or Equals)</li> <li>OR</li> <li>AND</li> <li>XNOR</li> <li>XOR</li> <li>CONTAINS_KEY (for maps only)</li> <li>CONTAINS_VALUE (for maps only)</li> <li>MATCHES (regex)</li> <li>MATCHES_IC (regex ignore case)</li> <li>STARTS_WITH</li> <li>STARTS_WITH_IC</li> <li>EQ_IGNORE_CASE</li> <li>ENDS_WITH</li> <li>ENDS_WITH_IC</li> <li>STRING_CONTAINS</li> <li>STRING_CONTAINS_IC</li> <li>LIKE (SQL like)</li></ul><br />3 args exceptions:<br />=================<br /><br /><ul> <li>BETWEEN</li></ul><br />n args:<br />=======<br /><br /><ul> <li>IN</li> <li>NOT_INT</li></ul><h1>Math Operators</h1>1 arg:<br />=====<br /><br /><ul> <li>NEGATE</li> <li>MAP_SIZE</li> <li>STRING_LENGTH</li> <li>CEIL</li> <li>ABS</li> <li>FLOOR</li> <li>ROUND</li> <li>RANDOM (no arg)</li> <li>RANDOM2 (seed arg)</li> <li>NUMCAST</li> <li>HOUR</li> <li>MINUTE</li> <li>SECOND</li> <li>MILLISECOND</li> <li>YEAR</li> <li>WEEK</li> <li>YEAR_MONTH</li> <li>YEAR_WEEK</li> <li>DAY_OF_WEEK</li> <li>DAY_OF_MONTH</li> <li>DAY_OF_YEAR</li> <li>WEEK</li> <li>WEEK</li> <li>WEEK</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>ADD</li> <li>DIV</li> <li>MULT</li> <li>SUB</li> <li>POWER</li> <li>MOD</li> <li>LOCATE (index of (string, char))</li> <li>DIFF_YEARS</li> <li>DIFF_MONTHS</li> <li>DIFF_WEEKS</li> <li>DIFF_DAYS</li> <li>DIFF_HOURS</li> <li>DIFF_MINUTES</li> <li>DIFF_SECONDS</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>MIN</li> <li>MAX</li></ul><h1>String Operators</h1>0 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li></ul><br /><br />1 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li> <li>LOWER</li> <li>UPPER</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />2 args:<br />=====<br /><br /><ul> <li>CHAR_AT</li> <li>SUBSTR_1ARG (substr(string, start))</li> <li>CONCAT</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />3 args:<br />=====<br /><br /><ul> <li>SUBSTR_2ARGS (substr(string, start, length))</li></ul>
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: { breRule?: BreRule;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.createBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core rules
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.deleteBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: { expression?: Expressionobject;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBREExpressionAsString(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: { filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.getBRERules(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: { id: string; enabled?: BooleanResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.setBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Cannot update system rules
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: { id: string; breRule?: BreRule;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreRule> {
        const fetchArgs = BRERuleEngineRulesApiFetchParamCreator.updateBRERule(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineRulesApi - object-oriented interface
 */
export class BRERuleEngineRulesApi extends BaseAPI {
    /**
     * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...<h1>Boolean Operators</h1><br /><br />1 arg:<br />======<br /><br /><ul> <li>IS_NULL</li> <li>IS_NOT_NULL</li> <li>STRING_IS_EMPTY</li> <li>NOT </li> <li>MAP_IS_EMPTY</li></ul><br />2 args:<br />=======<br /><br /><ul> <li>EQ</li> <li>NE (Not Equals)</li> <li>GT (Greater Than)</li> <li>GOE (Greater Or Equals)</li> <li>LT (Lesser Than)</li> <li>LOE (Lesser Or Equals)</li> <li>OR</li> <li>AND</li> <li>XNOR</li> <li>XOR</li> <li>CONTAINS_KEY (for maps only)</li> <li>CONTAINS_VALUE (for maps only)</li> <li>MATCHES (regex)</li> <li>MATCHES_IC (regex ignore case)</li> <li>STARTS_WITH</li> <li>STARTS_WITH_IC</li> <li>EQ_IGNORE_CASE</li> <li>ENDS_WITH</li> <li>ENDS_WITH_IC</li> <li>STRING_CONTAINS</li> <li>STRING_CONTAINS_IC</li> <li>LIKE (SQL like)</li></ul><br />3 args exceptions:<br />=================<br /><br /><ul> <li>BETWEEN</li></ul><br />n args:<br />=======<br /><br /><ul> <li>IN</li> <li>NOT_INT</li></ul><h1>Math Operators</h1>1 arg:<br />=====<br /><br /><ul> <li>NEGATE</li> <li>MAP_SIZE</li> <li>STRING_LENGTH</li> <li>CEIL</li> <li>ABS</li> <li>FLOOR</li> <li>ROUND</li> <li>RANDOM (no arg)</li> <li>RANDOM2 (seed arg)</li> <li>NUMCAST</li> <li>HOUR</li> <li>MINUTE</li> <li>SECOND</li> <li>MILLISECOND</li> <li>YEAR</li> <li>WEEK</li> <li>YEAR_MONTH</li> <li>YEAR_WEEK</li> <li>DAY_OF_WEEK</li> <li>DAY_OF_MONTH</li> <li>DAY_OF_YEAR</li> <li>WEEK</li> <li>WEEK</li> <li>WEEK</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>ADD</li> <li>DIV</li> <li>MULT</li> <li>SUB</li> <li>POWER</li> <li>MOD</li> <li>LOCATE (index of (string, char))</li> <li>DIFF_YEARS</li> <li>DIFF_MONTHS</li> <li>DIFF_WEEKS</li> <li>DIFF_DAYS</li> <li>DIFF_HOURS</li> <li>DIFF_MINUTES</li> <li>DIFF_SECONDS</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>MIN</li> <li>MAX</li></ul><h1>String Operators</h1>0 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li></ul><br /><br />1 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li> <li>LOWER</li> <li>UPPER</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />2 args:<br />=====<br /><br /><ul> <li>CHAR_AT</li> <li>SUBSTR_1ARG (substr(string, start))</li> <li>CONCAT</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />3 args:<br />=====<br /><br /><ul> <li>SUBSTR_2ARGS (substr(string, start, length))</li></ul>
     * @summary Create a rule
     * @param breRule The BRE rule object
     */
    createBRERule(params: {  breRule?: BreRule; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.createBRERule(params, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core rules
     * @summary Delete a rule
     * @param id The id of the rule
     */
    deleteBRERule(params: {  id: string; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.deleteBRERule(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a string representation of the provided expression
     * @param expression The expression
     */
    getBREExpressionAsString(params: {  expression?: Expressionobject; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.getBREExpressionAsString(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single rule
     * @param id The id of the rule
     */
    getBRERule(params: {  id: string; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.getBRERule(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List rules
     * @param filterName Filter for rules containing the given name
     * @param filterEnabled Filter for rules by active status, null for both
     * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
     * @param filterTrigger Filter for rules that are for the trigger with the given name
     * @param filterAction Filter for rules that use the action with the given name
     * @param filterCondition Filter for rules that have a condition containing the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.getBRERules(params, options)(this.fetch, this.basePath);
    }
    /**
     * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
     * @summary Enable or disable a rule
     * @param id The id of the rule
     * @param enabled The boolean value
     */
    setBRERule(params: {  id: string; enabled?: BooleanResource; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.setBRERule(params, options)(this.fetch, this.basePath);
    }
    /**
     * Cannot update system rules
     * @summary Update a rule
     * @param id The id of the rule
     * @param breRule The BRE rule object
     */
    updateBRERule(params: {  id: string; breRule?: BreRule; }, options: any = {}) {
        return BRERuleEngineRulesApiFp.updateBRERule(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineRulesApi - factory interface
 */
export const BRERuleEngineRulesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Rules define which actions to run when a given event verifies the specified conditions. Conditions and actions are defined by binding event or context parameters to arguments. Conditions also known as Predicates are logical expressions that result in a boolean. Operators are used to describe rules between arguments to form that condition. There are 3 families of operators: Boolean, Math and String. Math and String operators are functions that transform arguments into numbers or strings...<h1>Boolean Operators</h1><br /><br />1 arg:<br />======<br /><br /><ul> <li>IS_NULL</li> <li>IS_NOT_NULL</li> <li>STRING_IS_EMPTY</li> <li>NOT </li> <li>MAP_IS_EMPTY</li></ul><br />2 args:<br />=======<br /><br /><ul> <li>EQ</li> <li>NE (Not Equals)</li> <li>GT (Greater Than)</li> <li>GOE (Greater Or Equals)</li> <li>LT (Lesser Than)</li> <li>LOE (Lesser Or Equals)</li> <li>OR</li> <li>AND</li> <li>XNOR</li> <li>XOR</li> <li>CONTAINS_KEY (for maps only)</li> <li>CONTAINS_VALUE (for maps only)</li> <li>MATCHES (regex)</li> <li>MATCHES_IC (regex ignore case)</li> <li>STARTS_WITH</li> <li>STARTS_WITH_IC</li> <li>EQ_IGNORE_CASE</li> <li>ENDS_WITH</li> <li>ENDS_WITH_IC</li> <li>STRING_CONTAINS</li> <li>STRING_CONTAINS_IC</li> <li>LIKE (SQL like)</li></ul><br />3 args exceptions:<br />=================<br /><br /><ul> <li>BETWEEN</li></ul><br />n args:<br />=======<br /><br /><ul> <li>IN</li> <li>NOT_INT</li></ul><h1>Math Operators</h1>1 arg:<br />=====<br /><br /><ul> <li>NEGATE</li> <li>MAP_SIZE</li> <li>STRING_LENGTH</li> <li>CEIL</li> <li>ABS</li> <li>FLOOR</li> <li>ROUND</li> <li>RANDOM (no arg)</li> <li>RANDOM2 (seed arg)</li> <li>NUMCAST</li> <li>HOUR</li> <li>MINUTE</li> <li>SECOND</li> <li>MILLISECOND</li> <li>YEAR</li> <li>WEEK</li> <li>YEAR_MONTH</li> <li>YEAR_WEEK</li> <li>DAY_OF_WEEK</li> <li>DAY_OF_MONTH</li> <li>DAY_OF_YEAR</li> <li>WEEK</li> <li>WEEK</li> <li>WEEK</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>ADD</li> <li>DIV</li> <li>MULT</li> <li>SUB</li> <li>POWER</li> <li>MOD</li> <li>LOCATE (index of (string, char))</li> <li>DIFF_YEARS</li> <li>DIFF_MONTHS</li> <li>DIFF_WEEKS</li> <li>DIFF_DAYS</li> <li>DIFF_HOURS</li> <li>DIFF_MINUTES</li> <li>DIFF_SECONDS</li></ul><br /><br />2 args:<br />======<br /><br /><ul> <li>MIN</li> <li>MAX</li></ul><h1>String Operators</h1>0 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li></ul><br /><br />1 arg:<br />=====<br /><br /><ul> <li>CURRENT_TIME</li> <li>LOWER</li> <li>UPPER</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />2 args:<br />=====<br /><br /><ul> <li>CHAR_AT</li> <li>SUBSTR_1ARG (substr(string, start))</li> <li>CONCAT</li> <li>TRIM</li> <li>STRING_CAST</li></ul><br /><br />3 args:<br />=====<br /><br /><ul> <li>SUBSTR_2ARGS (substr(string, start, length))</li></ul>
         * @summary Create a rule
         * @param breRule The BRE rule object
         */
        createBRERule(params: {  breRule?: BreRule; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.createBRERule(params, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core rules
         * @summary Delete a rule
         * @param id The id of the rule
         */
        deleteBRERule(params: {  id: string; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.deleteBRERule(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a string representation of the provided expression
         * @param expression The expression
         */
        getBREExpressionAsString(params: {  expression?: Expressionobject; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.getBREExpressionAsString(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single rule
         * @param id The id of the rule
         */
        getBRERule(params: {  id: string; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.getBRERule(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List rules
         * @param filterName Filter for rules containing the given name
         * @param filterEnabled Filter for rules by active status, null for both
         * @param filterSystem Filter for rules that are system rules when true, or not when false. Leave off for both mixed
         * @param filterTrigger Filter for rules that are for the trigger with the given name
         * @param filterAction Filter for rules that use the action with the given name
         * @param filterCondition Filter for rules that have a condition containing the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRERules(params: {  filterName?: string; filterEnabled?: boolean; filterSystem?: boolean; filterTrigger?: string; filterAction?: string; filterCondition?: string; size?: number; page?: number; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.getBRERules(params, options)(fetch, basePath);
        },
        /**
         * This is helpful for turning off systems rules which cannot be deleted or modified otherwise
         * @summary Enable or disable a rule
         * @param id The id of the rule
         * @param enabled The boolean value
         */
        setBRERule(params: {  id: string; enabled?: BooleanResource; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.setBRERule(params, options)(fetch, basePath);
        },
        /**
         * Cannot update system rules
         * @summary Update a rule
         * @param id The id of the rule
         * @param breRule The BRE rule object
         */
        updateBRERule(params: {  id: string; breRule?: BreRule; }, options: any = {}) {
            return BRERuleEngineRulesApiFp.updateBRERule(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineTriggersApi - fetch parameter creator
 */
export const BRERuleEngineTriggersApiFetchParamCreator = {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  eventName: string; }, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling deleteBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  eventName: string; }, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling getBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/triggers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSystem"] !== undefined) {
            urlObj.query["filter_system"] = params["filterSystem"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTags"] !== undefined) {
            urlObj.query["filter_tags"] = params["filterTags"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, options: any = {}): FetchArgs {
        // verify required parameter "eventName" is set
        if (params["eventName"] == null) {
            throw new Error("Missing required parameter eventName when calling updateBRETrigger");
        }
        const baseUrl = `/bre/triggers/{event_name}`
            .replace(`{${"event_name"}}`, `${ params["eventName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["breTriggerResource"]) {
            fetchOptions.body = JSON.stringify(params["breTriggerResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineTriggersApi - functional programming interface
 */
export const BRERuleEngineTriggersApiFp = {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: { breTriggerResource?: BreTriggerResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.createBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: { eventName: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.deleteBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: { eventName: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.getBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: { filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.getBRETriggers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: { eventName: string; breTriggerResource?: BreTriggerResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreTriggerResource> {
        const fetchArgs = BRERuleEngineTriggersApiFetchParamCreator.updateBRETrigger(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineTriggersApi - object-oriented interface
 */
export class BRERuleEngineTriggersApi extends BaseAPI {
    /**
     * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
     * @summary Create a trigger
     * @param breTriggerResource The BRE trigger resource object
     */
    createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, options: any = {}) {
        return BRERuleEngineTriggersApiFp.createBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if there are existing rules against it. Cannot delete core triggers
     * @summary Delete a trigger
     * @param eventName The trigger event name
     */
    deleteBRETrigger(params: {  eventName: string; }, options: any = {}) {
        return BRERuleEngineTriggersApiFp.deleteBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single trigger
     * @param eventName The trigger event name
     */
    getBRETrigger(params: {  eventName: string; }, options: any = {}) {
        return BRERuleEngineTriggersApiFp.getBRETrigger(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List triggers
     * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
     * @param filterCategory Filter for triggers that are within a specific category
     * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
     * @param filterName Filter for triggers that have names containing the given string
     * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, options: any = {}) {
        return BRERuleEngineTriggersApiFp.getBRETriggers(params, options)(this.fetch, this.basePath);
    }
    /**
     * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
     * @summary Update a trigger
     * @param eventName The trigger event name
     * @param breTriggerResource The BRE trigger resource object
     */
    updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, options: any = {}) {
        return BRERuleEngineTriggersApiFp.updateBRETrigger(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineTriggersApi - factory interface
 */
export const BRERuleEngineTriggersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Customer added triggers will not be fired automatically or have rules associated with them by default. Custom rules must be added to get use from the trigger and it must then be fired from the outside. See the Bre Event services
         * @summary Create a trigger
         * @param breTriggerResource The BRE trigger resource object
         */
        createBRETrigger(params: {  breTriggerResource?: BreTriggerResource; }, options: any = {}) {
            return BRERuleEngineTriggersApiFp.createBRETrigger(params, options)(fetch, basePath);
        },
        /**
         * May fail if there are existing rules against it. Cannot delete core triggers
         * @summary Delete a trigger
         * @param eventName The trigger event name
         */
        deleteBRETrigger(params: {  eventName: string; }, options: any = {}) {
            return BRERuleEngineTriggersApiFp.deleteBRETrigger(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single trigger
         * @param eventName The trigger event name
         */
        getBRETrigger(params: {  eventName: string; }, options: any = {}) {
            return BRERuleEngineTriggersApiFp.getBRETrigger(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List triggers
         * @param filterSystem Filter for triggers that are system triggers when true, or not when false. Leave off for both mixed
         * @param filterCategory Filter for triggers that are within a specific category
         * @param filterTags Filter for triggers that have all of the given tags (comma separated list)
         * @param filterName Filter for triggers that have names containing the given string
         * @param filterSearch Filter for triggers containing the given words somewhere within name, description and tags
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBRETriggers(params: {  filterSystem?: boolean; filterCategory?: string; filterTags?: string; filterName?: string; filterSearch?: string; size?: number; page?: number; }, options: any = {}) {
            return BRERuleEngineTriggersApiFp.getBRETriggers(params, options)(fetch, basePath);
        },
        /**
         * May fail if new parameters mismatch requirements of existing rules. Cannot update core triggers
         * @summary Update a trigger
         * @param eventName The trigger event name
         * @param breTriggerResource The BRE trigger resource object
         */
        updateBRETrigger(params: {  eventName: string; breTriggerResource?: BreTriggerResource; }, options: any = {}) {
            return BRERuleEngineTriggersApiFp.updateBRETrigger(params, options)(fetch, basePath);
        },
    };
};


/**
 * BRERuleEngineVariablesApi - fetch parameter creator
 */
export const BRERuleEngineVariablesApiFetchParamCreator = {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(options: any = {}): FetchArgs {
        const baseUrl = `/bre/variable-types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here.
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getBREVariableValues");
        }
        const baseUrl = `/bre/variable-types/{name}/values`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BRERuleEngineVariablesApi - functional programming interface
 */
export const BRERuleEngineVariablesApiFp = {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<VariableTypeResource>> {
        const fetchArgs = BRERuleEngineVariablesApiFetchParamCreator.getBREVariableTypes(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here.
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: { name: string; filterName?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleReferenceResourceobject> {
        const fetchArgs = BRERuleEngineVariablesApiFetchParamCreator.getBREVariableValues(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BRERuleEngineVariablesApi - object-oriented interface
 */
export class BRERuleEngineVariablesApi extends BaseAPI {
    /**
     * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
     * @summary Get a list of variable types available
     */
    getBREVariableTypes(options: any = {}) {
        return BRERuleEngineVariablesApiFp.getBREVariableTypes(options)(this.fetch, this.basePath);
    }
    /**
     * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here.
     * @summary List valid values for a type
     * @param name The name of the type
     * @param filterName Filter results by those with names starting with this string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, options: any = {}) {
        return BRERuleEngineVariablesApiFp.getBREVariableValues(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BRERuleEngineVariablesApi - factory interface
 */
export const BRERuleEngineVariablesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Types include integer, string, user and invoice. These are used to qualify trigger parameters and action variables with strong typing.
         * @summary Get a list of variable types available
         */
        getBREVariableTypes(options: any = {}) {
            return BRERuleEngineVariablesApiFp.getBREVariableTypes(options)(fetch, basePath);
        },
        /**
         * Used to lookup users to fill in a user constant for example. Only types marked as enumerable are suppoorted here.
         * @summary List valid values for a type
         * @param name The name of the type
         * @param filterName Filter results by those with names starting with this string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getBREVariableValues(params: {  name: string; filterName?: string; size?: number; page?: number; }, options: any = {}) {
            return BRERuleEngineVariablesApiFp.getBREVariableValues(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsApi - fetch parameter creator
 */
export const CampaignsApiFetchParamCreator = {
    /**
     * 
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  id: number; challengeId?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addChallengeToCampaign");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeId"]) {
            fetchOptions.body = JSON.stringify(params["challengeId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  campaignResource?: CampaignResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Campaign Templates define a type of campaign and the properties they have
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignChallenges");
        }
        const baseUrl = `/campaigns/{id}/challenges`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/campaigns`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActive"] !== undefined) {
            urlObj.query["filter_active"] = params["filterActive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling removeChallengeFromCampaign");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeChallengeFromCampaign");
        }
        const baseUrl = `/campaigns/{campaign_id}/challenges/{id}`
            .replace(`{${"campaign_id"}}`, `${ params["campaignId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaign");
        }
        const baseUrl = `/campaigns/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCampaignTemplate");
        }
        const baseUrl = `/campaigns/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["campaignTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["campaignTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsApi - functional programming interface
 */
export const CampaignsApiFp = {
    /**
     * 
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: { id: number; challengeId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.addChallengeToCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: { campaignResource?: CampaignResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Campaign Templates define a type of campaign and the properties they have
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: { campaignTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.createCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.deleteCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: { id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignChallenges(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaignTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: { filterActive?: boolean; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.getCampaigns(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: { campaignId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsApiFetchParamCreator.removeChallengeFromCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: { id: number; campaignResource?: CampaignResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CampaignResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaign(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: { id: string; campaignTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsApiFetchParamCreator.updateCampaignTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsApi - object-oriented interface
 */
export class CampaignsApi extends BaseAPI {
    /**
     * 
     * @summary Add a challenge to a campaign
     * @param id The id of the campaign
     * @param challengeId The id of the challenge
     */
    addChallengeToCampaign(params: {  id: number; challengeId?: number; }, options: any = {}) {
        return CampaignsApiFp.addChallengeToCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a campaign
     * @param campaignResource The campaign resource object
     */
    createCampaign(params: {  campaignResource?: CampaignResource; }, options: any = {}) {
        return CampaignsApiFp.createCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * Campaign Templates define a type of campaign and the properties they have
     * @summary Create a campaign template
     * @param campaignTemplateResource The campaign template resource object
     */
    createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsApiFp.createCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a campaign
     * @param id The campaign id
     */
    deleteCampaign(params: {  id: number; }, options: any = {}) {
        return CampaignsApiFp.deleteCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a campaign template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCampaignTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CampaignsApiFp.deleteCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a single campaign
     * @param id The campaign id
     */
    getCampaign(params: {  id: number; }, options: any = {}) {
        return CampaignsApiFp.getCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the challenges associated with a campaign
     * @param id The campaign id
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignChallenges(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single campaign template
     * @param id The id of the template
     */
    getCampaignTemplate(params: {  id: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search campaign templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaignTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search campaigns
     * @param filterActive Filter for campaigns that are active
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsApiFp.getCampaigns(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove a challenge from a campaign
     * @param campaignId The campaign id
     * @param id The challenge id
     */
    removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, options: any = {}) {
        return CampaignsApiFp.removeChallengeFromCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a campaign
     * @param id The campaign id
     * @param campaignResource The campaign resource object
     */
    updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, options: any = {}) {
        return CampaignsApiFp.updateCampaign(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an campaign template
     * @param id The id of the template
     * @param campaignTemplateResource The campaign template resource object
     */
    updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsApiFp.updateCampaignTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsApi - factory interface
 */
export const CampaignsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a challenge to a campaign
         * @param id The id of the campaign
         * @param challengeId The id of the challenge
         */
        addChallengeToCampaign(params: {  id: number; challengeId?: number; }, options: any = {}) {
            return CampaignsApiFp.addChallengeToCampaign(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a campaign
         * @param campaignResource The campaign resource object
         */
        createCampaign(params: {  campaignResource?: CampaignResource; }, options: any = {}) {
            return CampaignsApiFp.createCampaign(params, options)(fetch, basePath);
        },
        /**
         * Campaign Templates define a type of campaign and the properties they have
         * @summary Create a campaign template
         * @param campaignTemplateResource The campaign template resource object
         */
        createCampaignTemplate(params: {  campaignTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsApiFp.createCampaignTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a campaign
         * @param id The campaign id
         */
        deleteCampaign(params: {  id: number; }, options: any = {}) {
            return CampaignsApiFp.deleteCampaign(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a campaign template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCampaignTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return CampaignsApiFp.deleteCampaignTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a single campaign
         * @param id The campaign id
         */
        getCampaign(params: {  id: number; }, options: any = {}) {
            return CampaignsApiFp.getCampaign(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the challenges associated with a campaign
         * @param id The campaign id
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaignChallenges(params: {  id: number; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsApiFp.getCampaignChallenges(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single campaign template
         * @param id The id of the template
         */
        getCampaignTemplate(params: {  id: string; }, options: any = {}) {
            return CampaignsApiFp.getCampaignTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search campaign templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaignTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsApiFp.getCampaignTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search campaigns
         * @param filterActive Filter for campaigns that are active
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCampaigns(params: {  filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsApiFp.getCampaigns(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a challenge from a campaign
         * @param campaignId The campaign id
         * @param id The challenge id
         */
        removeChallengeFromCampaign(params: {  campaignId: number; id: number; }, options: any = {}) {
            return CampaignsApiFp.removeChallengeFromCampaign(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a campaign
         * @param id The campaign id
         * @param campaignResource The campaign resource object
         */
        updateCampaign(params: {  id: number; campaignResource?: CampaignResource; }, options: any = {}) {
            return CampaignsApiFp.updateCampaign(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an campaign template
         * @param id The id of the template
         * @param campaignTemplateResource The campaign template resource object
         */
        updateCampaignTemplate(params: {  id: string; campaignTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsApiFp.updateCampaignTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsChallengesApi - fetch parameter creator
 */
export const CampaignsChallengesApiFetchParamCreator = {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  challengeResource?: ChallengeResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, options: any = {}): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling createChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["validateSettings"] !== undefined) {
            urlObj.query["validateSettings"] = params["validateSettings"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenge-activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Challenge Templates define a type of challenge and the properties they have
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling deleteChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling getChallengeActivities");
        }
        const baseUrl = `/challenges/{challenge_id}/activities`
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling getChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenge-activities/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeEvent");
        }
        const baseUrl = `/challenges/events/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/events`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["filterCampaigns"] !== undefined) {
            urlObj.query["filter_campaigns"] = params["filterCampaigns"];
        }
        if (params["filterChallenge"] !== undefined) {
            urlObj.query["filter_challenge"] = params["filterChallenge"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenges/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: {  filterTemplate?: boolean; filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/challenges`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["filterActiveCampaign"] !== undefined) {
            urlObj.query["filter_active_campaign"] = params["filterActiveCampaign"];
        }
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallenge");
        }
        const baseUrl = `/challenges/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeActivity");
        }
        // verify required parameter "challengeId" is set
        if (params["challengeId"] == null) {
            throw new Error("Missing required parameter challengeId when calling updateChallengeActivity");
        }
        const baseUrl = `/challenges/{challenge_id}/activities/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"challenge_id"}}`, `${ params["challengeId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeActivityTemplate");
        }
        const baseUrl = `/challenge-activities/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeActivityTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeActivityTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateChallengeTemplate");
        }
        const baseUrl = `/challenges/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["challengeTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["challengeTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsChallengesApi - functional programming interface
 */
export const CampaignsChallengesApiFp = {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: { challengeResource?: ChallengeResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: { challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: { challengeActivityTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallengeActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Challenge Templates define a type of challenge and the properties they have
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: { challengeTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.createChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: { id: number; challengeId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.deleteChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: { challengeId: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBareChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivities(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: { id: number; challengeId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeActivityTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeEventResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeEvent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: { filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeEvents(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallengeTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: { filterTemplate?: boolean; filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.getChallenges(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: { id: number; challengeResource?: ChallengeResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallenge(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: { id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ChallengeActivityResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallengeActivity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: { id: string; challengeActivityTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallengeActivityTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: { id: string; challengeTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CampaignsChallengesApiFetchParamCreator.updateChallengeTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsChallengesApi - object-oriented interface
 */
export class CampaignsChallengesApi extends BaseAPI {
    /**
     * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
     * @summary Create a challenge
     * @param challengeResource The challenge resource object
     */
    createChallenge(params: {  challengeResource?: ChallengeResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.createChallenge(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a challenge activity
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
     */
    createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, options: any = {}) {
        return CampaignsChallengesApiFp.createChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * Challenge Activity Templates define a type of challenge activity and the properties they have
     * @summary Create a challenge activity template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.createChallengeActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Challenge Templates define a type of challenge and the properties they have
     * @summary Create a challenge template
     * @param challengeTemplateResource The challenge template resource object
     */
    createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.createChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a challenge
     * @param id The challenge id
     */
    deleteChallenge(params: {  id: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.deleteChallenge(params, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Delete a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    deleteChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.deleteChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge activity template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.deleteChallengeActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a challenge event
     * @param id The challenge event id
     */
    deleteChallengeEvent(params: {  id: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.deleteChallengeEvent(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a challenge template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteChallengeTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.deleteChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a challenge
     * @param id The challenge id
     */
    getChallenge(params: {  id: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallenge(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search challenge activities
     * @param challengeId The challenge id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeActivities(params, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Get a single challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     */
    getChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single challenge activity template
     * @param id The id of the template
     */
    getChallengeActivityTemplate(params: {  id: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search challenge activity templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeActivityTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a single challenge event details
     * @param id The challenge event id
     */
    getChallengeEvent(params: {  id: number; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeEvent(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a list of challenge events
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterCampaigns check only for events from currently running campaigns
     * @param filterChallenge check only for events from the challenge specified by id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeEvents(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single challenge template
     * @param id The id of the template
     */
    getChallengeTemplate(params: {  id: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search challenge templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallengeTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a list of challenges
     * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
     * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallenges(params: {  filterTemplate?: boolean; filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsChallengesApiFp.getChallenges(params, options)(this.fetch, this.basePath);
    }
    /**
     * If the challenge is a copy, changes will propagate to all the related challenges
     * @summary Update a challenge
     * @param id The challenge id
     * @param challengeResource The challenge resource object
     */
    updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.updateChallenge(params, options)(this.fetch, this.basePath);
    }
    /**
     * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
     * @summary Update a challenge activity
     * @param id The challenge_activity id
     * @param challengeId The challenge id
     * @param challengeActivityResource The challenge activity resource object
     */
    updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.updateChallengeActivity(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an challenge activity template
     * @param id The id of the template
     * @param challengeActivityTemplateResource The challengeActivity template resource object
     */
    updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.updateChallengeActivityTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a challenge template
     * @param id The id of the template
     * @param challengeTemplateResource The challenge template resource object
     */
    updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, options: any = {}) {
        return CampaignsChallengesApiFp.updateChallengeTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsChallengesApi - factory interface
 */
export const CampaignsChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Challenges do not run on their own.  They must be added to a campaign before events will spawn.
         * @summary Create a challenge
         * @param challengeResource The challenge resource object
         */
        createChallenge(params: {  challengeResource?: ChallengeResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.createChallenge(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a challenge activity
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         * @param validateSettings Whether to validate the settings being sent against the available settings on the base activity.
         */
        createChallengeActivity(params: {  challengeId: number; challengeActivityResource?: ChallengeActivityResource; validateSettings?: boolean; }, options: any = {}) {
            return CampaignsChallengesApiFp.createChallengeActivity(params, options)(fetch, basePath);
        },
        /**
         * Challenge Activity Templates define a type of challenge activity and the properties they have
         * @summary Create a challenge activity template
         * @param challengeActivityTemplateResource The challengeActivity template resource object
         */
        createChallengeActivityTemplate(params: {  challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.createChallengeActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * Challenge Templates define a type of challenge and the properties they have
         * @summary Create a challenge template
         * @param challengeTemplateResource The challenge template resource object
         */
        createChallengeTemplate(params: {  challengeTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.createChallengeTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a challenge
         * @param id The challenge id
         */
        deleteChallenge(params: {  id: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.deleteChallenge(params, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
         * @summary Delete a challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         */
        deleteChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.deleteChallengeActivity(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a challenge activity template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteChallengeActivityTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.deleteChallengeActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a challenge event
         * @param id The challenge event id
         */
        deleteChallengeEvent(params: {  id: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.deleteChallengeEvent(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a challenge template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteChallengeTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.deleteChallengeTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a challenge
         * @param id The challenge id
         */
        getChallenge(params: {  id: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallenge(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search challenge activities
         * @param challengeId The challenge id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeActivities(params: {  challengeId: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeActivities(params, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
         * @summary Get a single challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         */
        getChallengeActivity(params: {  id: number; challengeId: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeActivity(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single challenge activity template
         * @param id The id of the template
         */
        getChallengeActivityTemplate(params: {  id: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search challenge activity templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeActivityTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeActivityTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a single challenge event details
         * @param id The challenge event id
         */
        getChallengeEvent(params: {  id: number; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeEvent(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a list of challenge events
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the event end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterCampaigns check only for events from currently running campaigns
         * @param filterChallenge check only for events from the challenge specified by id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEvents(params: {  filterStartDate?: string; filterEndDate?: string; filterCampaigns?: boolean; filterChallenge?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeEvents(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single challenge template
         * @param id The id of the template
         */
        getChallengeTemplate(params: {  id: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search challenge templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallengeTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a list of challenges
         * @param filterTemplate Filter for challenges that are not tied to campaigns (templates)
         * @param filterActiveCampaign Filter for challenges that are tied to active campaigns
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the challenge end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallenges(params: {  filterTemplate?: boolean; filterActiveCampaign?: boolean; filterStartDate?: string; filterEndDate?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsChallengesApiFp.getChallenges(params, options)(fetch, basePath);
        },
        /**
         * If the challenge is a copy, changes will propagate to all the related challenges
         * @summary Update a challenge
         * @param id The challenge id
         * @param challengeResource The challenge resource object
         */
        updateChallenge(params: {  id: number; challengeResource?: ChallengeResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.updateChallenge(params, options)(fetch, basePath);
        },
        /**
         * A challenge can have multiple instances of the same activity and thus the id used is of the specific entry within the challenge
         * @summary Update a challenge activity
         * @param id The challenge_activity id
         * @param challengeId The challenge id
         * @param challengeActivityResource The challenge activity resource object
         */
        updateChallengeActivity(params: {  id: number; challengeId: number; challengeActivityResource?: ChallengeActivityResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.updateChallengeActivity(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an challenge activity template
         * @param id The id of the template
         * @param challengeActivityTemplateResource The challengeActivity template resource object
         */
        updateChallengeActivityTemplate(params: {  id: string; challengeActivityTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.updateChallengeActivityTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a challenge template
         * @param id The id of the template
         * @param challengeTemplateResource The challenge template resource object
         */
        updateChallengeTemplate(params: {  id: string; challengeTemplateResource?: TemplateResource; }, options: any = {}) {
            return CampaignsChallengesApiFp.updateChallengeTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignsRewardsApi - fetch parameter creator
 */
export const CampaignsRewardsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/rewards`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateRewardSet");
        }
        const baseUrl = `/rewards/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rewardSetResource"]) {
            fetchOptions.body = JSON.stringify(params["rewardSetResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignsRewardsApi - functional programming interface
 */
export const CampaignsRewardsApiFp = {
    /**
     * 
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: { rewardSetResource?: RewardSetResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.createRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.deleteRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.getRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.getRewardSets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: { id: number; rewardSetResource?: RewardSetResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RewardSetResource> {
        const fetchArgs = CampaignsRewardsApiFetchParamCreator.updateRewardSet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignsRewardsApi - object-oriented interface
 */
export class CampaignsRewardsApi extends BaseAPI {
    /**
     * 
     * @summary Create a reward set
     * @param rewardSetResource The reward set resource object
     */
    createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, options: any = {}) {
        return CampaignsRewardsApiFp.createRewardSet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a reward set
     * @param id The reward id
     */
    deleteRewardSet(params: {  id: number; }, options: any = {}) {
        return CampaignsRewardsApiFp.deleteRewardSet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single reward set
     * @param id The reward id
     */
    getRewardSet(params: {  id: number; }, options: any = {}) {
        return CampaignsRewardsApiFp.getRewardSet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search reward sets
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getRewardSets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CampaignsRewardsApiFp.getRewardSets(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a reward set
     * @param id The reward id
     * @param rewardSetResource The reward set resource object
     */
    updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, options: any = {}) {
        return CampaignsRewardsApiFp.updateRewardSet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignsRewardsApi - factory interface
 */
export const CampaignsRewardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a reward set
         * @param rewardSetResource The reward set resource object
         */
        createRewardSet(params: {  rewardSetResource?: RewardSetResource; }, options: any = {}) {
            return CampaignsRewardsApiFp.createRewardSet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a reward set
         * @param id The reward id
         */
        deleteRewardSet(params: {  id: number; }, options: any = {}) {
            return CampaignsRewardsApiFp.deleteRewardSet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single reward set
         * @param id The reward id
         */
        getRewardSet(params: {  id: number; }, options: any = {}) {
            return CampaignsRewardsApiFp.getRewardSet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search reward sets
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getRewardSets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return CampaignsRewardsApiFp.getRewardSets(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a reward set
         * @param id The reward id
         * @param rewardSetResource The reward set resource object
         */
        updateRewardSet(params: {  id: number; rewardSetResource?: RewardSetResource; }, options: any = {}) {
            return CampaignsRewardsApiFp.updateRewardSet(params, options)(fetch, basePath);
        },
    };
};


/**
 * CategoriesApi - fetch parameter creator
 */
export const CategoriesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: {  category?: CategoryResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Templates define a type of category and the properties they have
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/categories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterActive"] !== undefined) {
            urlObj.query["filter_active"] = params["filterActive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/categories/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  id: string; category?: CategoryResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategory");
        }
        const baseUrl = `/categories/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["category"]) {
            fetchOptions.body = JSON.stringify(params["category"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCategoryTemplate");
        }
        const baseUrl = `/categories/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CategoriesApi - functional programming interface
 */
export const CategoriesApiFp = {
    /**
     * 
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: { category?: CategoryResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Templates define a type of category and the properties they have
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: { template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.createCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoriesApiFetchParamCreator.deleteCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: { filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.getCategoryTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: { size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcestring> {
        const fetchArgs = CategoriesApiFetchParamCreator.getTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: { id: string; category?: CategoryResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CategoryResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: { id: string; template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = CategoriesApiFetchParamCreator.updateCategoryTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CategoriesApi - object-oriented interface
 */
export class CategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new category
     * @param category The category to create
     */
    createCategory(params: {  category?: CategoryResource; }, options: any = {}) {
        return CategoriesApiFp.createCategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * Templates define a type of category and the properties they have
     * @summary Create a category template
     * @param template The template to create
     */
    createCategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
        return CategoriesApiFp.createCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing category
     * @param id The id of the category to be deleted
     */
    deleteCategory(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.deleteCategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a category template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteCategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return CategoriesApiFp.deleteCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search categories with optional filters
     * @param filterSearch Filter for categories whose names begin with provided string
     * @param filterActive Filter for categories that are specifically active or inactive
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CategoriesApiFp.getCategories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single category
     * @param id The id of the category to retrieve
     */
    getCategory(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.getCategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single category template
     * @param id The id of the template
     */
    getCategoryTemplate(params: {  id: string; }, options: any = {}) {
        return CategoriesApiFp.getCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search category templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return CategoriesApiFp.getCategoryTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List all trivia tags in the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getTags(params: {  size?: number; page?: number; }, options: any = {}) {
        return CategoriesApiFp.getTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing category
     * @param id The id of the category
     * @param category The category to update
     */
    updateCategory(params: {  id: string; category?: CategoryResource; }, options: any = {}) {
        return CategoriesApiFp.updateCategory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a category template
     * @param id The id of the template
     * @param template The updated template information
     */
    updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
        return CategoriesApiFp.updateCategoryTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CategoriesApi - factory interface
 */
export const CategoriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new category
         * @param category The category to create
         */
        createCategory(params: {  category?: CategoryResource; }, options: any = {}) {
            return CategoriesApiFp.createCategory(params, options)(fetch, basePath);
        },
        /**
         * Templates define a type of category and the properties they have
         * @summary Create a category template
         * @param template The template to create
         */
        createCategoryTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
            return CategoriesApiFp.createCategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing category
         * @param id The id of the category to be deleted
         */
        deleteCategory(params: {  id: string; }, options: any = {}) {
            return CategoriesApiFp.deleteCategory(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a category template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteCategoryTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return CategoriesApiFp.deleteCategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search categories with optional filters
         * @param filterSearch Filter for categories whose names begin with provided string
         * @param filterActive Filter for categories that are specifically active or inactive
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategories(params: {  filterSearch?: string; filterActive?: boolean; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CategoriesApiFp.getCategories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single category
         * @param id The id of the category to retrieve
         */
        getCategory(params: {  id: string; }, options: any = {}) {
            return CategoriesApiFp.getCategory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single category template
         * @param id The id of the template
         */
        getCategoryTemplate(params: {  id: string; }, options: any = {}) {
            return CategoriesApiFp.getCategoryTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search category templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCategoryTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return CategoriesApiFp.getCategoryTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all trivia tags in the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getTags(params: {  size?: number; page?: number; }, options: any = {}) {
            return CategoriesApiFp.getTags(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing category
         * @param id The id of the category
         * @param category The category to update
         */
        updateCategory(params: {  id: string; category?: CategoryResource; }, options: any = {}) {
            return CategoriesApiFp.updateCategory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a category template
         * @param id The id of the template
         * @param template The updated template information
         */
        updateCategoryTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
            return CategoriesApiFp.updateCategoryTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * ConfigsApi - fetch parameter creator
 */
export const ConfigsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: {  config?: Config; }, options: any = {}): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Only configs that are public readable will be shown without admin access
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/configs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  name: string; config?: Config; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateConfig");
        }
        const baseUrl = `/configs/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["config"]) {
            fetchOptions.body = JSON.stringify(params["config"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ConfigsApi - functional programming interface
 */
export const ConfigsApiFp = {
    /**
     * 
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: { config?: Config;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.createConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.deleteConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Only configs that are public readable will be shown without admin access
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Config> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: { filterSearch?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceConfig> {
        const fetchArgs = ConfigsApiFetchParamCreator.getConfigs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: { name: string; config?: Config;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ConfigsApiFetchParamCreator.updateConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ConfigsApi - object-oriented interface
 */
export class ConfigsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new config
     * @param config The config object
     */
    createConfig(params: {  config?: Config; }, options: any = {}) {
        return ConfigsApiFp.createConfig(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing config
     * @param name The config name
     */
    deleteConfig(params: {  name: string; }, options: any = {}) {
        return ConfigsApiFp.deleteConfig(params, options)(this.fetch, this.basePath);
    }
    /**
     * Only configs that are public readable will be shown without admin access
     * @summary Get a single config
     * @param name The config name
     */
    getConfig(params: {  name: string; }, options: any = {}) {
        return ConfigsApiFp.getConfig(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search configs
     * @param filterSearch Filter for configs whose name contains the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ConfigsApiFp.getConfigs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing config
     * @param name The config name
     * @param config The config object
     */
    updateConfig(params: {  name: string; config?: Config; }, options: any = {}) {
        return ConfigsApiFp.updateConfig(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ConfigsApi - factory interface
 */
export const ConfigsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new config
         * @param config The config object
         */
        createConfig(params: {  config?: Config; }, options: any = {}) {
            return ConfigsApiFp.createConfig(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing config
         * @param name The config name
         */
        deleteConfig(params: {  name: string; }, options: any = {}) {
            return ConfigsApiFp.deleteConfig(params, options)(fetch, basePath);
        },
        /**
         * Only configs that are public readable will be shown without admin access
         * @summary Get a single config
         * @param name The config name
         */
        getConfig(params: {  name: string; }, options: any = {}) {
            return ConfigsApiFp.getConfig(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search configs
         * @param filterSearch Filter for configs whose name contains the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getConfigs(params: {  filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ConfigsApiFp.getConfigs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing config
         * @param name The config name
         * @param config The config object
         */
        updateConfig(params: {  name: string; config?: Config; }, options: any = {}) {
            return ConfigsApiFp.updateConfig(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentArticlesApi - fetch parameter creator
 */
export const ContentArticlesApiFetchParamCreator = {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: {  articleResource?: ArticleResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Article Templates define a type of article and the properties they have
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/content/articles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterActiveOnly"] !== undefined) {
            urlObj.query["filter_active_only"] = params["filterActiveOnly"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterTagIntersection"] !== undefined) {
            urlObj.query["filter_tag_intersection"] = params["filterTagIntersection"];
        }
        if (params["filterTagExclusion"] !== undefined) {
            urlObj.query["filter_tag_exclusion"] = params["filterTagExclusion"];
        }
        if (params["filterTitle"] !== undefined) {
            urlObj.query["filter_title"] = params["filterTitle"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  id: string; articleResource?: ArticleResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticle");
        }
        const baseUrl = `/content/articles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleResource"]) {
            fetchOptions.body = JSON.stringify(params["articleResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArticleTemplate");
        }
        const baseUrl = `/content/articles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["articleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["articleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentArticlesApi - functional programming interface
 */
export const ContentArticlesApiFp = {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: { articleResource?: ArticleResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.createArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Article Templates define a type of article and the properties they have
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: { articleTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.createArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.deleteArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.deleteArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticleTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: { filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.getArticles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: { id: string; articleResource?: ArticleResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArticleResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.updateArticle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: { id: string; articleTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentArticlesApiFetchParamCreator.updateArticleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentArticlesApi - object-oriented interface
 */
export class ContentArticlesApi extends BaseAPI {
    /**
     * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new article
     * @param articleResource The new article
     */
    createArticle(params: {  articleResource?: ArticleResource; }, options: any = {}) {
        return ContentArticlesApiFp.createArticle(params, options)(this.fetch, this.basePath);
    }
    /**
     * Article Templates define a type of article and the properties they have
     * @summary Create an article template
     * @param articleTemplateResource The article template resource object
     */
    createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, options: any = {}) {
        return ContentArticlesApiFp.createArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing article
     * @param id The article id
     */
    deleteArticle(params: {  id: string; }, options: any = {}) {
        return ContentArticlesApiFp.deleteArticle(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an article template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArticleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return ContentArticlesApiFp.deleteArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single article
     * @param id The article id
     */
    getArticle(params: {  id: string; }, options: any = {}) {
        return ContentArticlesApiFp.getArticle(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single article template
     * @param id The id of the template
     */
    getArticleTemplate(params: {  id: string; }, options: any = {}) {
        return ContentArticlesApiFp.getArticleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search article templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ContentArticlesApiFp.getArticleTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search articles
     * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
     * @param filterCategory Filter for articles from a specific category by id
     * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
     * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
     * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
     * @param filterTitle Filter for articles whose title contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ContentArticlesApiFp.getArticles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing article
     * @param id The article id
     * @param articleResource The article object
     */
    updateArticle(params: {  id: string; articleResource?: ArticleResource; }, options: any = {}) {
        return ContentArticlesApiFp.updateArticle(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an article template
     * @param id The id of the template
     * @param articleTemplateResource The article template resource object
     */
    updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, options: any = {}) {
        return ContentArticlesApiFp.updateArticleTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentArticlesApi - factory interface
 */
export const ContentArticlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Articles are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
         * @summary Create a new article
         * @param articleResource The new article
         */
        createArticle(params: {  articleResource?: ArticleResource; }, options: any = {}) {
            return ContentArticlesApiFp.createArticle(params, options)(fetch, basePath);
        },
        /**
         * Article Templates define a type of article and the properties they have
         * @summary Create an article template
         * @param articleTemplateResource The article template resource object
         */
        createArticleTemplate(params: {  articleTemplateResource?: TemplateResource; }, options: any = {}) {
            return ContentArticlesApiFp.createArticleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing article
         * @param id The article id
         */
        deleteArticle(params: {  id: string; }, options: any = {}) {
            return ContentArticlesApiFp.deleteArticle(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete an article template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArticleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return ContentArticlesApiFp.deleteArticleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single article
         * @param id The article id
         */
        getArticle(params: {  id: string; }, options: any = {}) {
            return ContentArticlesApiFp.getArticle(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single article template
         * @param id The id of the template
         */
        getArticleTemplate(params: {  id: string; }, options: any = {}) {
            return ContentArticlesApiFp.getArticleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search article templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return ContentArticlesApiFp.getArticleTemplates(params, options)(fetch, basePath);
        },
        /**
         * Get a list of articles with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single article' to retrieve the full resource with assets for a given item as needed.
         * @summary List and search articles
         * @param filterActiveOnly Filter for articles that are active (true) or inactive (false)
         * @param filterCategory Filter for articles from a specific category by id
         * @param filterTagset Filter for articles with at least one of a specified set of tags (separated by comma)
         * @param filterTagIntersection Filter for articles with all of a specified set of tags (separated by comma)
         * @param filterTagExclusion Filter for articles with none of a specified set of tags (separated by comma)
         * @param filterTitle Filter for articles whose title contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArticles(params: {  filterActiveOnly?: boolean; filterCategory?: string; filterTagset?: string; filterTagIntersection?: string; filterTagExclusion?: string; filterTitle?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ContentArticlesApiFp.getArticles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing article
         * @param id The article id
         * @param articleResource The article object
         */
        updateArticle(params: {  id: string; articleResource?: ArticleResource; }, options: any = {}) {
            return ContentArticlesApiFp.updateArticle(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an article template
         * @param id The id of the template
         * @param articleTemplateResource The article template resource object
         */
        updateArticleTemplate(params: {  id: string; articleTemplateResource?: TemplateResource; }, options: any = {}) {
            return ContentArticlesApiFp.updateArticleTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentCommentsApi - fetch parameter creator
 */
export const ContentCommentsApiFetchParamCreator = {
    /**
     * 
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  commentResource?: CommentResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getComment");
        }
        const baseUrl = `/comments/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "context" is set
        if (params["context"] == null) {
            throw new Error("Missing required parameter context when calling getComments");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getComments");
        }
        const baseUrl = `/comments`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["context"] !== undefined) {
            urlObj.query["context"] = params["context"];
        }
        if (params["contextId"] !== undefined) {
            urlObj.query["context_id"] = params["contextId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The body is an ElasticSearch query json. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html'>documentation</a> for details on the format and search options
     * @summary Search the comment index
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: {  query?: any; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/comments/search`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  id: number; content?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateComment");
        }
        const baseUrl = `/comments/{id}/content`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentCommentsApi - functional programming interface
 */
export const ContentCommentsApiFp = {
    /**
     * 
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: { commentResource?: CommentResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.addComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.deleteComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.getComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: { context: string; contextId: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.getComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The body is an ElasticSearch query json. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html'>documentation</a> for details on the format and search options
     * @summary Search the comment index
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: { query?: any; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentSearch> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.searchComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: { id: number; content?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentCommentsApiFetchParamCreator.updateComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentCommentsApi - object-oriented interface
 */
export class ContentCommentsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new comment
     * @param commentResource The comment to be added
     */
    addComment(params: {  commentResource?: CommentResource; }, options: any = {}) {
        return ContentCommentsApiFp.addComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a comment
     * @param id The comment id
     */
    deleteComment(params: {  id: number; }, options: any = {}) {
        return ContentCommentsApiFp.deleteComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Return a comment
     * @param id The comment id
     */
    getComment(params: {  id: number; }, options: any = {}) {
        return ContentCommentsApiFp.getComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of comments
     * @param context Get comments by context type
     * @param contextId Get comments by context id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, options: any = {}) {
        return ContentCommentsApiFp.getComments(params, options)(this.fetch, this.basePath);
    }
    /**
     * The body is an ElasticSearch query json. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html'>documentation</a> for details on the format and search options
     * @summary Search the comment index
     * @param query The search query
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchComments(params: {  query?: any; size?: number; page?: number; }, options: any = {}) {
        return ContentCommentsApiFp.searchComments(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a comment
     * @param id The comment id
     * @param content The comment content
     */
    updateComment(params: {  id: number; content?: StringWrapper; }, options: any = {}) {
        return ContentCommentsApiFp.updateComment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentCommentsApi - factory interface
 */
export const ContentCommentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new comment
         * @param commentResource The comment to be added
         */
        addComment(params: {  commentResource?: CommentResource; }, options: any = {}) {
            return ContentCommentsApiFp.addComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a comment
         * @param id The comment id
         */
        deleteComment(params: {  id: number; }, options: any = {}) {
            return ContentCommentsApiFp.deleteComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return a comment
         * @param id The comment id
         */
        getComment(params: {  id: number; }, options: any = {}) {
            return ContentCommentsApiFp.getComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of comments
         * @param context Get comments by context type
         * @param contextId Get comments by context id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getComments(params: {  context: string; contextId: number; size?: number; page?: number; }, options: any = {}) {
            return ContentCommentsApiFp.getComments(params, options)(fetch, basePath);
        },
        /**
         * The body is an ElasticSearch query json. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html'>documentation</a> for details on the format and search options
         * @summary Search the comment index
         * @param query The search query
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        searchComments(params: {  query?: any; size?: number; page?: number; }, options: any = {}) {
            return ContentCommentsApiFp.searchComments(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a comment
         * @param id The comment id
         * @param content The comment content
         */
        updateComment(params: {  id: number; content?: StringWrapper; }, options: any = {}) {
            return ContentCommentsApiFp.updateComment(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContentPollsApi - fetch parameter creator
 */
export const ContentPollsApiFetchParamCreator = {
    /**
     * 
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  id: string; answerKey?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling answerPoll");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answerKey"]) {
            fetchOptions.body = JSON.stringify(params["answerKey"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: {  pollResource?: PollResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Poll templates define a type of poll and the properties they have
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollAnswer");
        }
        const baseUrl = `/media/polls/{id}/response`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/polls`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterText"] !== undefined) {
            urlObj.query["filter_text"] = params["filterText"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  id: string; pollResource?: PollResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePoll");
        }
        const baseUrl = `/media/polls/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollResource"]) {
            fetchOptions.body = JSON.stringify(params["pollResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePollTemplate");
        }
        const baseUrl = `/media/polls/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["pollTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["pollTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContentPollsApi - functional programming interface
 */
export const ContentPollsApiFp = {
    /**
     * 
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: { id: string; answerKey?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.answerPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: { pollResource?: PollResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.createPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Poll templates define a type of poll and the properties they have
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: { pollTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.createPollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.deletePoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContentPollsApiFetchParamCreator.deletePollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResponseResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPollTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: { filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourcePollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.getPolls(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: { id: string; pollResource?: PollResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PollResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.updatePoll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: { id: string; pollTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = ContentPollsApiFetchParamCreator.updatePollTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContentPollsApi - object-oriented interface
 */
export class ContentPollsApi extends BaseAPI {
    /**
     * 
     * @summary Add your vote to a poll
     * @param id The poll id
     * @param answerKey The answer key
     */
    answerPoll(params: {  id: string; answerKey?: StringWrapper; }, options: any = {}) {
        return ContentPollsApiFp.answerPoll(params, options)(this.fetch, this.basePath);
    }
    /**
     * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
     * @summary Create a new poll
     * @param pollResource The poll object
     */
    createPoll(params: {  pollResource?: PollResource; }, options: any = {}) {
        return ContentPollsApiFp.createPoll(params, options)(this.fetch, this.basePath);
    }
    /**
     * Poll templates define a type of poll and the properties they have
     * @summary Create a poll template
     * @param pollTemplateResource The poll template resource object
     */
    createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, options: any = {}) {
        return ContentPollsApiFp.createPollTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing poll
     * @param id The poll id
     */
    deletePoll(params: {  id: string; }, options: any = {}) {
        return ContentPollsApiFp.deletePoll(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a poll template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deletePollTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return ContentPollsApiFp.deletePollTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single poll
     * @param id The poll id
     */
    getPoll(params: {  id: string; }, options: any = {}) {
        return ContentPollsApiFp.getPoll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get poll answer
     * @param id The poll id
     */
    getPollAnswer(params: {  id: string; }, options: any = {}) {
        return ContentPollsApiFp.getPollAnswer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single poll template
     * @param id The id of the template
     */
    getPollTemplate(params: {  id: string; }, options: any = {}) {
        return ContentPollsApiFp.getPollTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search poll templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPollTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return ContentPollsApiFp.getPollTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary List and search polls
     * @param filterCategory Filter for polls from a specific category by id
     * @param filterTagset Filter for polls with specified tags (separated by comma)
     * @param filterText Filter for polls whose text contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ContentPollsApiFp.getPolls(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing poll
     * @param id The poll id
     * @param pollResource The poll object
     */
    updatePoll(params: {  id: string; pollResource?: PollResource; }, options: any = {}) {
        return ContentPollsApiFp.updatePoll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a poll template
     * @param id The id of the template
     * @param pollTemplateResource The poll template resource object
     */
    updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, options: any = {}) {
        return ContentPollsApiFp.updatePollTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContentPollsApi - factory interface
 */
export const ContentPollsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add your vote to a poll
         * @param id The poll id
         * @param answerKey The answer key
         */
        answerPoll(params: {  id: string; answerKey?: StringWrapper; }, options: any = {}) {
            return ContentPollsApiFp.answerPoll(params, options)(fetch, basePath);
        },
        /**
         * Polls are blobs of text with titles, a category and assets. Formatting and display of the text is in the hands of the front end.
         * @summary Create a new poll
         * @param pollResource The poll object
         */
        createPoll(params: {  pollResource?: PollResource; }, options: any = {}) {
            return ContentPollsApiFp.createPoll(params, options)(fetch, basePath);
        },
        /**
         * Poll templates define a type of poll and the properties they have
         * @summary Create a poll template
         * @param pollTemplateResource The poll template resource object
         */
        createPollTemplate(params: {  pollTemplateResource?: TemplateResource; }, options: any = {}) {
            return ContentPollsApiFp.createPollTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing poll
         * @param id The poll id
         */
        deletePoll(params: {  id: string; }, options: any = {}) {
            return ContentPollsApiFp.deletePoll(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a poll template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deletePollTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return ContentPollsApiFp.deletePollTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single poll
         * @param id The poll id
         */
        getPoll(params: {  id: string; }, options: any = {}) {
            return ContentPollsApiFp.getPoll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get poll answer
         * @param id The poll id
         */
        getPollAnswer(params: {  id: string; }, options: any = {}) {
            return ContentPollsApiFp.getPollAnswer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single poll template
         * @param id The id of the template
         */
        getPollTemplate(params: {  id: string; }, options: any = {}) {
            return ContentPollsApiFp.getPollTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search poll templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPollTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return ContentPollsApiFp.getPollTemplates(params, options)(fetch, basePath);
        },
        /**
         * Get a list of polls with optional filtering. Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
         * @summary List and search polls
         * @param filterCategory Filter for polls from a specific category by id
         * @param filterTagset Filter for polls with specified tags (separated by comma)
         * @param filterText Filter for polls whose text contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPolls(params: {  filterCategory?: string; filterTagset?: string; filterText?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ContentPollsApiFp.getPolls(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing poll
         * @param id The poll id
         * @param pollResource The poll object
         */
        updatePoll(params: {  id: string; pollResource?: PollResource; }, options: any = {}) {
            return ContentPollsApiFp.updatePoll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a poll template
         * @param id The id of the template
         * @param pollTemplateResource The poll template resource object
         */
        updatePollTemplate(params: {  id: string; pollTemplateResource?: TemplateResource; }, options: any = {}) {
            return ContentPollsApiFp.updatePollTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * CurrenciesApi - fetch parameter creator
 */
export const CurrenciesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  currency?: CurrencyResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  code: string; }, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/currencies`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterEnabledCurrencies"] !== undefined) {
            urlObj.query["filter_enabled_currencies"] = params["filterEnabledCurrencies"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  code: string; }, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  code: string; currency?: CurrencyResource; }, options: any = {}): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCurrency");
        }
        const baseUrl = `/currencies/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currency"]) {
            fetchOptions.body = JSON.stringify(params["currency"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CurrenciesApi - functional programming interface
 */
export const CurrenciesApiFp = {
    /**
     * 
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: { currency?: CurrencyResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.createCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: { code: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.deleteCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: { filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrencies(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: { code: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = CurrenciesApiFetchParamCreator.getCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: { code: string; currency?: CurrencyResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CurrenciesApiFetchParamCreator.updateCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CurrenciesApi - object-oriented interface
 */
export class CurrenciesApi extends BaseAPI {
    /**
     * 
     * @summary Create a currency
     * @param currency The currency object
     */
    createCurrency(params: {  currency?: CurrencyResource; }, options: any = {}) {
        return CurrenciesApiFp.createCurrency(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a currency
     * @param code The currency code
     */
    deleteCurrency(params: {  code: string; }, options: any = {}) {
        return CurrenciesApiFp.deleteCurrency(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search currencies
     * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
     * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCurrencies(params: {  filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return CurrenciesApiFp.getCurrencies(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single currency
     * @param code The currency code
     */
    getCurrency(params: {  code: string; }, options: any = {}) {
        return CurrenciesApiFp.getCurrency(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a currency
     * @param code The currency code
     * @param currency The currency object
     */
    updateCurrency(params: {  code: string; currency?: CurrencyResource; }, options: any = {}) {
        return CurrenciesApiFp.updateCurrency(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CurrenciesApi - factory interface
 */
export const CurrenciesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a currency
         * @param currency The currency object
         */
        createCurrency(params: {  currency?: CurrencyResource; }, options: any = {}) {
            return CurrenciesApiFp.createCurrency(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a currency
         * @param code The currency code
         */
        deleteCurrency(params: {  code: string; }, options: any = {}) {
            return CurrenciesApiFp.deleteCurrency(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search currencies
         * @param filterEnabledCurrencies Filter for alternate currencies setup explicitely in system config
         * @param filterType Filter currencies by type.  Allowable values: (&#39;virtual&#39;, &#39;real&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCurrencies(params: {  filterEnabledCurrencies?: boolean; filterType?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return CurrenciesApiFp.getCurrencies(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single currency
         * @param code The currency code
         */
        getCurrency(params: {  code: string; }, options: any = {}) {
            return CurrenciesApiFp.getCurrency(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a currency
         * @param code The currency code
         * @param currency The currency object
         */
        updateCurrency(params: {  code: string; currency?: CurrencyResource; }, options: any = {}) {
            return CurrenciesApiFp.updateCurrency(params, options)(fetch, basePath);
        },
    };
};


/**
 * DevicesApi - fetch parameter creator
 */
export const DevicesApiFetchParamCreator = {
    /**
     * 
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userResources" is set
        if (params["userResources"] == null) {
            throw new Error("Missing required parameter userResources when calling addDeviceUsers");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addDeviceUsers");
        }
        const baseUrl = `/devices/{id}/users`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResources"]) {
            fetchOptions.body = JSON.stringify(params["userResources"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a device
     * @param device device
     */
    createDevice(params: {  device: DeviceResource; }, options: any = {}): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling createDevice");
        }
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: {  id: number; userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDeviceUser");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deleteDeviceUser");
        }
        const baseUrl = `/devices/{id}/users/{user_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: {  id: number; filterId?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDeviceUsers");
        }
        const baseUrl = `/devices/{id}/users`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterId"] !== undefined) {
            urlObj.query["filter_id"] = params["filterId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of devices with optional filtering
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  filterMake?: string; filterModel?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/devices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterMake"] !== undefined) {
            urlObj.query["filter_make"] = params["filterMake"];
        }
        if (params["filterModel"] !== undefined) {
            urlObj.query["filter_model"] = params["filterModel"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  device: DeviceResource; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "device" is set
        if (params["device"] == null) {
            throw new Error("Missing required parameter device when calling updateDevice");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateDevice");
        }
        const baseUrl = `/devices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["device"]) {
            fetchOptions.body = JSON.stringify(params["device"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DevicesApi - functional programming interface
 */
export const DevicesApiFp = {
    /**
     * 
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: { userResources: Array<SimpleUserResource>; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.addDeviceUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a device
     * @param device device
     */
    createDevice(params: { device: DeviceResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.createDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: { id: number; userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDeviceUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: { id: number; filterId?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DevicesApiFetchParamCreator.deleteDeviceUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of devices with optional filtering
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: { filterMake?: string; filterModel?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.getDevices(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: { device: DeviceResource; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DeviceResource> {
        const fetchArgs = DevicesApiFetchParamCreator.updateDevice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DevicesApi - object-oriented interface
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @summary Add device users
     * @param userResources userResources
     * @param id id
     */
    addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: number; }, options: any = {}) {
        return DevicesApiFp.addDeviceUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a device
     * @param device device
     */
    createDevice(params: {  device: DeviceResource; }, options: any = {}) {
        return DevicesApiFp.createDevice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a device
     * @param id id
     */
    deleteDevice(params: {  id: number; }, options: any = {}) {
        return DevicesApiFp.deleteDevice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a device user
     * @param id The id of the device
     * @param userId The user id of the device user
     */
    deleteDeviceUser(params: {  id: number; userId: number; }, options: any = {}) {
        return DevicesApiFp.deleteDeviceUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete all device users
     * @param id The id of the device
     * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
     */
    deleteDeviceUsers(params: {  id: number; filterId?: string; }, options: any = {}) {
        return DevicesApiFp.deleteDeviceUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single device
     * @param id id
     */
    getDevice(params: {  id: number; }, options: any = {}) {
        return DevicesApiFp.getDevice(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of devices with optional filtering
     * @summary List and search devices
     * @param filterMake Filter for devices with specified make
     * @param filterModel Filter for devices with specified model
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDevices(params: {  filterMake?: string; filterModel?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return DevicesApiFp.getDevices(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a device
     * @param device device
     * @param id id
     */
    updateDevice(params: {  device: DeviceResource; id: number; }, options: any = {}) {
        return DevicesApiFp.updateDevice(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DevicesApi - factory interface
 */
export const DevicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add device users
         * @param userResources userResources
         * @param id id
         */
        addDeviceUsers(params: {  userResources: Array<SimpleUserResource>; id: number; }, options: any = {}) {
            return DevicesApiFp.addDeviceUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a device
         * @param device device
         */
        createDevice(params: {  device: DeviceResource; }, options: any = {}) {
            return DevicesApiFp.createDevice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a device
         * @param id id
         */
        deleteDevice(params: {  id: number; }, options: any = {}) {
            return DevicesApiFp.deleteDevice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a device user
         * @param id The id of the device
         * @param userId The user id of the device user
         */
        deleteDeviceUser(params: {  id: number; userId: number; }, options: any = {}) {
            return DevicesApiFp.deleteDeviceUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete all device users
         * @param id The id of the device
         * @param filterId Filter for device users to delete with a user id in a given comma separated list of ids
         */
        deleteDeviceUsers(params: {  id: number; filterId?: string; }, options: any = {}) {
            return DevicesApiFp.deleteDeviceUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single device
         * @param id id
         */
        getDevice(params: {  id: number; }, options: any = {}) {
            return DevicesApiFp.getDevice(params, options)(fetch, basePath);
        },
        /**
         * Get a list of devices with optional filtering
         * @summary List and search devices
         * @param filterMake Filter for devices with specified make
         * @param filterModel Filter for devices with specified model
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDevices(params: {  filterMake?: string; filterModel?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return DevicesApiFp.getDevices(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a device
         * @param device device
         * @param id id
         */
        updateDevice(params: {  device: DeviceResource; id: number; }, options: any = {}) {
            return DevicesApiFp.updateDevice(params, options)(fetch, basePath);
        },
    };
};


/**
 * DispositionsApi - fetch parameter creator
 */
export const DispositionsApiFetchParamCreator = {
    /**
     * 
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  disposition?: DispositionResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["disposition"]) {
            fetchOptions.body = JSON.stringify(params["disposition"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getDisposition");
        }
        const baseUrl = `/dispositions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterOwner"] !== undefined) {
            urlObj.query["filter_owner"] = params["filterOwner"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/dispositions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["filterOwner"] !== undefined) {
            urlObj.query["filter_owner"] = params["filterOwner"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DispositionsApi - functional programming interface
 */
export const DispositionsApiFp = {
    /**
     * 
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: { disposition?: DispositionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.addDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DispositionsApiFetchParamCreator.deleteDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: { filterContext?: string; filterOwner?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<DispositionCount>> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositionCounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: { filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = DispositionsApiFetchParamCreator.getDispositions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DispositionsApi - object-oriented interface
 */
export class DispositionsApi extends BaseAPI {
    /**
     * 
     * @summary Add a new disposition
     * @param disposition The new disposition record
     */
    addDisposition(params: {  disposition?: DispositionResource; }, options: any = {}) {
        return DispositionsApiFp.addDisposition(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a disposition
     * @param id The id of the disposition record
     */
    deleteDisposition(params: {  id: number; }, options: any = {}) {
        return DispositionsApiFp.deleteDisposition(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a disposition
     * @param id The id of the disposition record
     */
    getDisposition(params: {  id: number; }, options: any = {}) {
        return DispositionsApiFp.getDisposition(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a list of disposition counts
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     */
    getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, options: any = {}) {
        return DispositionsApiFp.getDispositionCounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of dispositions
     * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
     * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return DispositionsApiFp.getDispositions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DispositionsApi - factory interface
 */
export const DispositionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new disposition
         * @param disposition The new disposition record
         */
        addDisposition(params: {  disposition?: DispositionResource; }, options: any = {}) {
            return DispositionsApiFp.addDisposition(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a disposition
         * @param id The id of the disposition record
         */
        deleteDisposition(params: {  id: number; }, options: any = {}) {
            return DispositionsApiFp.deleteDisposition(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a disposition
         * @param id The id of the disposition record
         */
        getDisposition(params: {  id: number; }, options: any = {}) {
            return DispositionsApiFp.getDisposition(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of disposition counts
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         */
        getDispositionCounts(params: {  filterContext?: string; filterOwner?: string; }, options: any = {}) {
            return DispositionsApiFp.getDispositionCounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of dispositions
         * @param filterContext Filter for dispositions within a context type (games, articles, polls, etc). Optionally with a specific id like filter_context&#x3D;video:47
         * @param filterOwner Filter for dispositions from a specific user by id or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getDispositions(params: {  filterContext?: string; filterOwner?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return DispositionsApiFp.getDispositions(params, options)(fetch, basePath);
        },
    };
};


/**
 * FulfillmentApi - fetch parameter creator
 */
export const FulfillmentApiFetchParamCreator = {
    /**
     * 
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  type?: FulfillmentType; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["type"]) {
            fetchOptions.body = JSON.stringify(params["type"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/fulfillment/types`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateFulfillmentType");
        }
        const baseUrl = `/store/fulfillment/types/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["fulfillmentType"]) {
            fetchOptions.body = JSON.stringify(params["fulfillmentType"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FulfillmentApi - functional programming interface
 */
export const FulfillmentApiFp = {
    /**
     * 
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: { type?: FulfillmentType;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.createFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.deleteFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceFulfillmentType> {
        const fetchArgs = FulfillmentApiFetchParamCreator.getFulfillmentTypes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: { id: number; fulfillmentType?: FulfillmentType;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FulfillmentApiFetchParamCreator.updateFulfillmentType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FulfillmentApi - object-oriented interface
 */
export class FulfillmentApi extends BaseAPI {
    /**
     * 
     * @summary Create a fulfillment type
     * @param type The fulfillment type
     */
    createFulfillmentType(params: {  type?: FulfillmentType; }, options: any = {}) {
        return FulfillmentApiFp.createFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a fulfillment type
     * @param id The id
     */
    deleteFulfillmentType(params: {  id: number; }, options: any = {}) {
        return FulfillmentApiFp.deleteFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single fulfillment type
     * @param id The id
     */
    getFulfillmentType(params: {  id: number; }, options: any = {}) {
        return FulfillmentApiFp.getFulfillmentType(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search fulfillment types
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return FulfillmentApiFp.getFulfillmentTypes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a fulfillment type
     * @param id The id
     * @param fulfillmentType The fulfillment type
     */
    updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, options: any = {}) {
        return FulfillmentApiFp.updateFulfillmentType(params, options)(this.fetch, this.basePath);
    }
};

/**
 * FulfillmentApi - factory interface
 */
export const FulfillmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a fulfillment type
         * @param type The fulfillment type
         */
        createFulfillmentType(params: {  type?: FulfillmentType; }, options: any = {}) {
            return FulfillmentApiFp.createFulfillmentType(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a fulfillment type
         * @param id The id
         */
        deleteFulfillmentType(params: {  id: number; }, options: any = {}) {
            return FulfillmentApiFp.deleteFulfillmentType(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single fulfillment type
         * @param id The id
         */
        getFulfillmentType(params: {  id: number; }, options: any = {}) {
            return FulfillmentApiFp.getFulfillmentType(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search fulfillment types
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getFulfillmentTypes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return FulfillmentApiFp.getFulfillmentTypes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a fulfillment type
         * @param id The id
         * @param fulfillmentType The fulfillment type
         */
        updateFulfillmentType(params: {  id: number; fulfillmentType?: FulfillmentType; }, options: any = {}) {
            return FulfillmentApiFp.updateFulfillmentType(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationAchievementsApi - fetch parameter creator
 */
export const GamificationAchievementsApiFetchParamCreator = {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: {  achievement?: AchievementDefinitionResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Achievement templates define a type of achievement and the properties they have
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  template?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will also disable the associated generated rule, if any.
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/achievements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options: any = {}): FetchArgs {
        const baseUrl = `/achievements/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, options: any = {}): FetchArgs {
        const baseUrl = `/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterHidden"] !== undefined) {
            urlObj.query["filter_hidden"] = params["filterHidden"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        if (params["filterDerived"] !== undefined) {
            urlObj.query["filter_derived"] = params["filterDerived"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used by other services that depend on achievements
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getDerivedAchievements");
        }
        const baseUrl = `/achievements/derived/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  userId: number; achievementName: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUserAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserAchievementsProgress");
        }
        const baseUrl = `/users/{user_id}/achievements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling getUsersAchievementProgress");
        }
        const baseUrl = `/users/achievements/{achievement_name}`
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/achievements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterAchievementDerived"] !== undefined) {
            urlObj.query["filter_achievement_derived"] = params["filterAchievementDerived"];
        }
        if (params["filterAchievementTagset"] !== undefined) {
            urlObj.query["filter_achievement_tagset"] = params["filterAchievementTagset"];
        }
        if (params["filterAchievementName"] !== undefined) {
            urlObj.query["filter_achievement_name"] = params["filterAchievementName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling incrementAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling incrementAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setAchievementProgress");
        }
        // verify required parameter "achievementName" is set
        if (params["achievementName"] == null) {
            throw new Error("Missing required parameter achievementName when calling setAchievementProgress");
        }
        const baseUrl = `/users/{user_id}/achievements/{achievement_name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"achievement_name"}}`, `${ params["achievementName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateAchievement");
        }
        const baseUrl = `/achievements/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["achievement"]) {
            fetchOptions.body = JSON.stringify(params["achievement"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAchievementTemplate");
        }
        const baseUrl = `/achievements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationAchievementsApi - functional programming interface
 */
export const GamificationAchievementsApiFp = {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: { achievement?: AchievementDefinitionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.createAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Achievement templates define a type of achievement and the properties they have
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: { template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.createAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will also disable the associated generated rule, if any.
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.deleteAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.deleteAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievementTriggers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: { filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getAchievements(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used by other services that depend on achievements
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<AchievementDefinitionResource>> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getDerivedAchievements(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: { userId: number; achievementName: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUserAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: { userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUserAchievementsProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: { achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUsersAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: { filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.getUsersAchievementsProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: { userId: number; achievementName: string; progress?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.incrementAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: { userId: number; achievementName: string; progress?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserAchievementGroupResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.setAchievementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: { name: string; achievement?: AchievementDefinitionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AchievementDefinitionResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.updateAchievement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: { id: string; template?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = GamificationAchievementsApiFetchParamCreator.updateAchievementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationAchievementsApi - object-oriented interface
 */
export class GamificationAchievementsApi extends BaseAPI {
    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    createAchievement(params: {  achievement?: AchievementDefinitionResource; }, options: any = {}) {
        return GamificationAchievementsApiFp.createAchievement(params, options)(this.fetch, this.basePath);
    }
    /**
     * Achievement templates define a type of achievement and the properties they have
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    createAchievementTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
        return GamificationAchievementsApiFp.createAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Will also disable the associated generated rule, if any.
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    deleteAchievement(params: {  name: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.deleteAchievement(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteAchievementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.deleteAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    getAchievement(params: {  name: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.getAchievement(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    getAchievementTemplate(params: {  id: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.getAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.getAchievementTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    getAchievementTriggers(options: any = {}) {
        return GamificationAchievementsApiFp.getAchievementTriggers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, options: any = {}) {
        return GamificationAchievementsApiFp.getAchievements(params, options)(this.fetch, this.basePath);
    }
    /**
     * Used by other services that depend on achievements
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    getDerivedAchievements(params: {  name: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.getDerivedAchievements(params, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    getUserAchievementProgress(params: {  userId: number; achievementName: string; }, options: any = {}) {
        return GamificationAchievementsApiFp.getUserAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return GamificationAchievementsApiFp.getUserAchievementsProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return GamificationAchievementsApiFp.getUsersAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
        return GamificationAchievementsApiFp.getUsersAchievementsProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
        return GamificationAchievementsApiFp.incrementAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
        return GamificationAchievementsApiFp.setAchievementProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, options: any = {}) {
        return GamificationAchievementsApiFp.updateAchievement(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
        return GamificationAchievementsApiFp.updateAchievementTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationAchievementsApi - factory interface
 */
export const GamificationAchievementsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
         * @summary Create a new achievement definition
         * @param achievement The achievement definition
         */
        createAchievement(params: {  achievement?: AchievementDefinitionResource; }, options: any = {}) {
            return GamificationAchievementsApiFp.createAchievement(params, options)(fetch, basePath);
        },
        /**
         * Achievement templates define a type of achievement and the properties they have
         * @summary Create an achievement template
         * @param template The achievement template to be created
         */
        createAchievementTemplate(params: {  template?: TemplateResource; }, options: any = {}) {
            return GamificationAchievementsApiFp.createAchievementTemplate(params, options)(fetch, basePath);
        },
        /**
         * Will also disable the associated generated rule, if any.
         * @summary Delete an achievement definition
         * @param name The name of the achievement
         */
        deleteAchievement(params: {  name: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.deleteAchievement(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete an achievement template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteAchievementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.deleteAchievementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single achievement definition
         * @param name The name of the achievement
         */
        getAchievement(params: {  name: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.getAchievement(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single achievement template
         * @param id The id of the template
         */
        getAchievementTemplate(params: {  id: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.getAchievementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search achievement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAchievementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.getAchievementTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of triggers that can be used to trigger an achievement progress update
         */
        getAchievementTriggers(options: any = {}) {
            return GamificationAchievementsApiFp.getAchievementTriggers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all achievement definitions in the system
         * @param filterTagset Filter for achievements with specified tags (separated by comma)
         * @param filterName Filter for achievements whose name contains a string
         * @param filterHidden Filter for achievements that are hidden or not
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterDerived Filter for achievements that are derived from other services
         */
        getAchievements(params: {  filterTagset?: string; filterName?: string; filterHidden?: boolean; size?: number; page?: number; order?: string; filterDerived?: boolean; }, options: any = {}) {
            return GamificationAchievementsApiFp.getAchievements(params, options)(fetch, basePath);
        },
        /**
         * Used by other services that depend on achievements
         * @summary Get a list of derived achievements
         * @param name The name of the derived achievement
         */
        getDerivedAchievements(params: {  name: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.getDerivedAchievements(params, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
         * @summary Retrieve progress on a given achievement for a given user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         */
        getUserAchievementProgress(params: {  userId: number; achievementName: string; }, options: any = {}) {
            return GamificationAchievementsApiFp.getUserAchievementProgress(params, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
         * @summary Retrieve progress on achievements for a given user
         * @param userId The user&#39;s id
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserAchievementsProgress(params: {  userId: number; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
            return GamificationAchievementsApiFp.getUserAchievementsProgress(params, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
         * @summary Retrieve progress on a given achievement for all users
         * @param achievementName The achievement&#39;s name
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementProgress(params: {  achievementName: string; filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
            return GamificationAchievementsApiFp.getUsersAchievementProgress(params, options)(fetch, basePath);
        },
        /**
         * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
         * @summary Retrieve progress on achievements for all users
         * @param filterAchievementDerived Filter for achievements that are derived from other services
         * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
         * @param filterAchievementName Filter for achievements whose name contains a string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsersAchievementsProgress(params: {  filterAchievementDerived?: boolean; filterAchievementTagset?: string; filterAchievementName?: string; size?: number; page?: number; }, options: any = {}) {
            return GamificationAchievementsApiFp.getUsersAchievementsProgress(params, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
         * @summary Increment an achievement progress record for a user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         * @param progress The amount to add to the progress value
         */
        incrementAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
            return GamificationAchievementsApiFp.incrementAchievementProgress(params, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
         * @summary Set an achievement progress record for a user
         * @param userId The user&#39;s id
         * @param achievementName The achievement&#39;s name
         * @param progress The new progress value
         */
        setAchievementProgress(params: {  userId: number; achievementName: string; progress?: IntWrapper; }, options: any = {}) {
            return GamificationAchievementsApiFp.setAchievementProgress(params, options)(fetch, basePath);
        },
        /**
         * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
         * @summary Update an achievement definition
         * @param name The name of the achievement
         * @param achievement The achievement definition
         */
        updateAchievement(params: {  name: string; achievement?: AchievementDefinitionResource; }, options: any = {}) {
            return GamificationAchievementsApiFp.updateAchievement(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an achievement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateAchievementTemplate(params: {  id: string; template?: TemplateResource; }, options: any = {}) {
            return GamificationAchievementsApiFp.updateAchievementTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationLeaderboardsApi - fetch parameter creator
 */
export const GamificationLeaderboardsApiFetchParamCreator = {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource.
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboard");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboard");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "contextType" is set
        if (params["contextType"] == null) {
            throw new Error("Missing required parameter contextType when calling getLeaderboardRank");
        }
        // verify required parameter "contextId" is set
        if (params["contextId"] == null) {
            throw new Error("Missing required parameter contextId when calling getLeaderboardRank");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getLeaderboardRank");
        }
        const baseUrl = `/leaderboards/{context_type}/{context_id}/users/{id}/rank`
            .replace(`{${"context_type"}}`, `${ params["contextType"] }`)
            .replace(`{${"context_id"}}`, `${ params["contextId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options: any = {}): FetchArgs {
        const baseUrl = `/leaderboards/strategies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationLeaderboardsApi - functional programming interface
 */
export const GamificationLeaderboardsApiFp = {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource.
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: { contextType: string; contextId: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LeaderboardResource> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: { contextType: string; contextId: string; id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LeaderboardEntryResource> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboardRank(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = GamificationLeaderboardsApiFetchParamCreator.getLeaderboardStrategies(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationLeaderboardsApi - object-oriented interface
 */
export class GamificationLeaderboardsApi extends BaseAPI {
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource.
     * @summary Retrieves leaderboard details and paginated entries
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationLeaderboardsApiFp.getLeaderboard(params, options)(this.fetch, this.basePath);
    }
    /**
     * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
     * @summary Retrieves a specific user entry with rank
     * @param contextType The context type for the leaderboard
     * @param contextId The context id for the leaderboard
     * @param id The id of a user
     */
    getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, options: any = {}) {
        return GamificationLeaderboardsApiFp.getLeaderboardRank(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a list of available leaderboard strategy names
     */
    getLeaderboardStrategies(options: any = {}) {
        return GamificationLeaderboardsApiFp.getLeaderboardStrategies(options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationLeaderboardsApi - factory interface
 */
export const GamificationLeaderboardsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard. Sorting is based on the fields of LeaderboardEntryResource rather than the returned LeaderboardResource.
         * @summary Retrieves leaderboard details and paginated entries
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getLeaderboard(params: {  contextType: string; contextId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationLeaderboardsApiFp.getLeaderboard(params, options)(fetch, basePath);
        },
        /**
         * The context type identifies the type of entity (i.e., 'activity') being tracked on the leaderboard. The context ID is the unique ID of the actual entity tracked by the leaderboard
         * @summary Retrieves a specific user entry with rank
         * @param contextType The context type for the leaderboard
         * @param contextId The context id for the leaderboard
         * @param id The id of a user
         */
        getLeaderboardRank(params: {  contextType: string; contextId: string; id: string; }, options: any = {}) {
            return GamificationLeaderboardsApiFp.getLeaderboardRank(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of available leaderboard strategy names
         */
        getLeaderboardStrategies(options: any = {}) {
            return GamificationLeaderboardsApiFp.getLeaderboardStrategies(options)(fetch, basePath);
        },
    };
};


/**
 * GamificationLevelingApi - fetch parameter creator
 */
export const GamificationLevelingApiFetchParamCreator = {
    /**
     * 
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  level?: LevelingResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["level"]) {
            fetchOptions.body = JSON.stringify(params["level"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling deleteLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options: any = {}): FetchArgs {
        const baseUrl = `/leveling/triggers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of levels schemas with optional filtering
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/leveling`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: {  userId: number; name: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevel");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getUserLevel");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here.
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: {  userId: number; filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserLevels");
        }
        const baseUrl = `/users/{user_id}/leveling`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling incrementProgress");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling incrementProgress");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setProgress");
        }
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling setProgress");
        }
        const baseUrl = `/users/{user_id}/leveling/{name}/progress`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["progress"]) {
            fetchOptions.body = JSON.stringify(params["progress"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  name: string; newLevel?: LevelingResource; }, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling updateLevel");
        }
        const baseUrl = `/leveling/{name}`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newLevel"]) {
            fetchOptions.body = JSON.stringify(params["newLevel"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationLevelingApi - functional programming interface
 */
export const GamificationLevelingApiFp = {
    /**
     * 
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: { level?: LevelingResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.createLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.deleteLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: { name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BreTriggerResource>> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevelTriggers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of levels schemas with optional filtering
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: { filterName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getLevels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: { userId: number; name: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getUserLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here.
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: { userId: number; filterName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserLevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.getUserLevels(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: { userId: number; name: string; progress?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.incrementProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: { userId: number; name: string; progress?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.setProgress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: { name: string; newLevel?: LevelingResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<LevelingResource> {
        const fetchArgs = GamificationLevelingApiFetchParamCreator.updateLevel(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationLevelingApi - object-oriented interface
 */
export class GamificationLevelingApi extends BaseAPI {
    /**
     * 
     * @summary Create a level schema
     * @param level The level schema definition
     */
    createLevel(params: {  level?: LevelingResource; }, options: any = {}) {
        return GamificationLevelingApiFp.createLevel(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a level
     * @param name The level schema name
     */
    deleteLevel(params: {  name: string; }, options: any = {}) {
        return GamificationLevelingApiFp.deleteLevel(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a level
     * @param name The level schema name
     */
    getLevel(params: {  name: string; }, options: any = {}) {
        return GamificationLevelingApiFp.getLevel(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get the list of triggers that can be used to trigger a leveling progress update
     */
    getLevelTriggers(options: any = {}) {
        return GamificationLevelingApiFp.getLevelTriggers(options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of levels schemas with optional filtering
     * @summary List and search levels
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationLevelingApiFp.getLevels(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a user's progress for a given level schema
     * @param userId The id of the user
     * @param name The level schema name
     */
    getUserLevel(params: {  userId: number; name: string; }, options: any = {}) {
        return GamificationLevelingApiFp.getUserLevel(params, options)(this.fetch, this.basePath);
    }
    /**
     * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here.
     * @summary Get a user's progress for all level schemas
     * @param userId The id of the user
     * @param filterName Filter for level schemas whose name contains a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLevels(params: {  userId: number; filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationLevelingApiFp.getUserLevels(params, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Update or create a leveling progress record for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The amount of progress to add
     */
    incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
        return GamificationLevelingApiFp.incrementProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set leveling progress for a user
     * @param userId The id of the user
     * @param name The level schema name
     * @param progress The new progress amount
     */
    setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
        return GamificationLevelingApiFp.setProgress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a level
     * @param name The level schema name
     * @param newLevel The level schema definition
     */
    updateLevel(params: {  name: string; newLevel?: LevelingResource; }, options: any = {}) {
        return GamificationLevelingApiFp.updateLevel(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationLevelingApi - factory interface
 */
export const GamificationLevelingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a level schema
         * @param level The level schema definition
         */
        createLevel(params: {  level?: LevelingResource; }, options: any = {}) {
            return GamificationLevelingApiFp.createLevel(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a level
         * @param name The level schema name
         */
        deleteLevel(params: {  name: string; }, options: any = {}) {
            return GamificationLevelingApiFp.deleteLevel(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a level
         * @param name The level schema name
         */
        getLevel(params: {  name: string; }, options: any = {}) {
            return GamificationLevelingApiFp.getLevel(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of triggers that can be used to trigger a leveling progress update
         */
        getLevelTriggers(options: any = {}) {
            return GamificationLevelingApiFp.getLevelTriggers(options)(fetch, basePath);
        },
        /**
         * Get a list of levels schemas with optional filtering
         * @summary List and search levels
         * @param filterName Filter for level schemas whose name contains a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getLevels(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationLevelingApiFp.getLevels(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a user's progress for a given level schema
         * @param userId The id of the user
         * @param name The level schema name
         */
        getUserLevel(params: {  userId: number; name: string; }, options: any = {}) {
            return GamificationLevelingApiFp.getUserLevel(params, options)(fetch, basePath);
        },
        /**
         * Filtering and sorting is based on the LevelingResource object, not the UserLevelingResource that is returned here.
         * @summary Get a user's progress for all level schemas
         * @param userId The id of the user
         * @param filterName Filter for level schemas whose name contains a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLevels(params: {  userId: number; filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationLevelingApiFp.getUserLevels(params, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise the provided value will be added to it. May be negative. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
         * @summary Update or create a leveling progress record for a user
         * @param userId The id of the user
         * @param name The level schema name
         * @param progress The amount of progress to add
         */
        incrementProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
            return GamificationLevelingApiFp.incrementProgress(params, options)(fetch, basePath);
        },
        /**
         * If no progress record yet exists for the user, it will be created. Otherwise it will be updated to the provided value. If progress meets or exceeds the level's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
         * @summary Set leveling progress for a user
         * @param userId The id of the user
         * @param name The level schema name
         * @param progress The new progress amount
         */
        setProgress(params: {  userId: number; name: string; progress?: IntWrapper; }, options: any = {}) {
            return GamificationLevelingApiFp.setProgress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a level
         * @param name The level schema name
         * @param newLevel The level schema definition
         */
        updateLevel(params: {  name: string; newLevel?: LevelingResource; }, options: any = {}) {
            return GamificationLevelingApiFp.updateLevel(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationMetricsApi - fetch parameter creator
 */
export const GamificationMetricsApiFetchParamCreator = {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: {  metric?: MetricResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/metrics`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["metric"]) {
            fetchOptions.body = JSON.stringify(params["metric"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationMetricsApi - functional programming interface
 */
export const GamificationMetricsApiFp = {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: { metric?: MetricResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationMetricsApiFetchParamCreator.addMetric(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationMetricsApi - object-oriented interface
 */
export class GamificationMetricsApi extends BaseAPI {
    /**
     * Post a new score/stat for an activity occurrence without ending the occurrence itself
     * @summary Add a metric
     * @param metric The new metric
     */
    addMetric(params: {  metric?: MetricResource; }, options: any = {}) {
        return GamificationMetricsApiFp.addMetric(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationMetricsApi - factory interface
 */
export const GamificationMetricsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Post a new score/stat for an activity occurrence without ending the occurrence itself
         * @summary Add a metric
         * @param metric The new metric
         */
        addMetric(params: {  metric?: MetricResource; }, options: any = {}) {
            return GamificationMetricsApiFp.addMetric(params, options)(fetch, basePath);
        },
    };
};


/**
 * GamificationTriviaApi - fetch parameter creator
 */
export const GamificationTriviaApiFetchParamCreator = {
    /**
     * 
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling addQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  id: string; tag?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: {  request?: ImportJobResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: {  question?: QuestionResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Question templates define a type of question and the properties they have
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Also deletes all questions that were imported by it
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  questionId: string; id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling deleteQuestionAnswers");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/import`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterVendor"] !== undefined) {
            urlObj.query["filter_vendor"] = params["filterVendor"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  questionId: string; id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  questionId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling getQuestionAnswers");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  since?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/delta`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["since"] !== undefined) {
            urlObj.query["since"] = params["since"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTags");
        }
        const baseUrl = `/trivia/questions/{id}/tags`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  id: number; publishNow: boolean; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling processImportJob");
        }
        // verify required parameter "publishNow" is set
        if (params["publishNow"] == null) {
            throw new Error("Missing required parameter publishNow when calling processImportJob");
        }
        const baseUrl = `/trivia/import/{id}/process`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["publishNow"] !== undefined) {
            urlObj.query["publish_now"] = params["publishNow"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  id: string; tag: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeQuestionTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeQuestionTag");
        }
        const baseUrl = `/trivia/questions/{id}/tags/{tag}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeTagToQuestionsBatch");
        }
        const baseUrl = `/trivia/questions/tags/{tag}`
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Changes should be made before process is started for there to be any effect.
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  id: number; request?: ImportJobResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateImportJob");
        }
        const baseUrl = `/trivia/import/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  id: string; question?: QuestionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestion");
        }
        const baseUrl = `/trivia/questions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, options: any = {}): FetchArgs {
        // verify required parameter "questionId" is set
        if (params["questionId"] == null) {
            throw new Error("Missing required parameter questionId when calling updateQuestionAnswer");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionAnswer");
        }
        const baseUrl = `/trivia/questions/{question_id}/answers/{id}`
            .replace(`{${"question_id"}}`, `${ params["questionId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["answer"]) {
            fetchOptions.body = JSON.stringify(params["answer"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateQuestionTemplate");
        }
        const baseUrl = `/trivia/questions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["questionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["questionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/trivia/questions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["filterIdset"] !== undefined) {
            urlObj.query["filter_idset"] = params["filterIdset"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterImportId"] !== undefined) {
            urlObj.query["filter_import_id"] = params["filterImportId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["question"]) {
            fetchOptions.body = JSON.stringify(params["question"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamificationTriviaApi - functional programming interface
 */
export const GamificationTriviaApiFp = {
    /**
     * 
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: { questionId: string; answer?: AnswerResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: { id: string; tag?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addQuestionTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: { tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.addTagToQuestionsBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: { request?: ImportJobResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: { question?: QuestionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Question templates define a type of question and the properties they have
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: { questionTemplateResource?: QuestionTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.createQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Also deletes all questions that were imported by it
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: { questionId: string; id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.deleteQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: { filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getImportJobs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: { questionId: string; id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<AnswerResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: { questionId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<AnswerResource>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionAnswers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: { since?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<DeltaResource>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionDeltas(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceQuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: { size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceQuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: { filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.getQuestionsCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: { id: number; publishNow: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.processImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: { id: string; tag: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.removeQuestionTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: { tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.removeTagToQuestionsBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: { filterSearch?: string; filterCategory?: string; filterImportId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Collectionstring> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.searchQuestionTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Changes should be made before process is started for there to be any effect.
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: { id: number; request?: ImportJobResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ImportJobResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateImportJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: { id: string; question?: QuestionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestion(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: { questionId: string; id: string; answer?: AnswerResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionAnswer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: { id: string; questionTemplateResource?: QuestionTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QuestionTemplateResource> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: { question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = GamificationTriviaApiFetchParamCreator.updateQuestionsInBulk(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamificationTriviaApi - object-oriented interface
 */
export class GamificationTriviaApi extends BaseAPI {
    /**
     * 
     * @summary Add an answer to a question
     * @param questionId The id of the question
     * @param answer The new answer
     */
    addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, options: any = {}) {
        return GamificationTriviaApiFp.addQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a tag to a question
     * @param id The id of the question
     * @param tag The new tag
     */
    addQuestionTag(params: {  id: string; tag?: StringWrapper; }, options: any = {}) {
        return GamificationTriviaApiFp.addQuestionTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @summary Add a tag to a batch of questions
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.addTagToQuestionsBatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @summary Create an import job
     * @param request The new import job
     */
    createImportJob(params: {  request?: ImportJobResource; }, options: any = {}) {
        return GamificationTriviaApiFp.createImportJob(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a question
     * @param question The new question
     */
    createQuestion(params: {  question?: QuestionResource; }, options: any = {}) {
        return GamificationTriviaApiFp.createQuestion(params, options)(this.fetch, this.basePath);
    }
    /**
     * Question templates define a type of question and the properties they have
     * @summary Create a question template
     * @param questionTemplateResource The question template resource object
     */
    createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
        return GamificationTriviaApiFp.createQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Also deletes all questions that were imported by it
     * @summary Delete an import job
     * @param id The id of the job
     */
    deleteImportJob(params: {  id: number; }, options: any = {}) {
        return GamificationTriviaApiFp.deleteImportJob(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a question
     * @param id The id of the question
     */
    deleteQuestion(params: {  id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.deleteQuestion(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove an answer from a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    deleteQuestionAnswers(params: {  questionId: string; id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.deleteQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a question template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteQuestionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return GamificationTriviaApiFp.deleteQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get an import job
     * @param id The id of the job
     */
    getImportJob(params: {  id: number; }, options: any = {}) {
        return GamificationTriviaApiFp.getImportJob(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a list of import job
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getImportJobs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single question
     * @param id The id of the question
     */
    getQuestion(params: {  id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestion(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    getQuestionAnswer(params: {  questionId: string; id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionAnswer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the answers available for a question
     * @param questionId The id of the question
     */
    getQuestionAnswers(params: {  questionId: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionAnswers(params, options)(this.fetch, this.basePath);
    }
    /**
     * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @summary List question deltas in ascending order of updated date
     * @param since Timestamp in seconds
     */
    getQuestionDeltas(params: {  since?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionDeltas(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the tags for a question
     * @param id The id of the question
     */
    getQuestionTags(params: {  id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single question template
     * @param id The id of the template
     */
    getQuestionTemplate(params: {  id: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search question templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search questions
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterTag Filter for questions with specified tag
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestions(params, options)(this.fetch, this.basePath);
    }
    /**
     * This is also provided by the list endpoint so you don't need to call this for pagination purposes
     * @summary Count questions based on filters
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, options: any = {}) {
        return GamificationTriviaApiFp.getQuestionsCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
     * @summary Start processing an import job
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    processImportJob(params: {  id: number; publishNow: boolean; }, options: any = {}) {
        return GamificationTriviaApiFp.processImportJob(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove a tag from a question
     * @param id The id of the question
     * @param tag The tag to remove
     */
    removeQuestionTag(params: {  id: string; tag: string; }, options: any = {}) {
        return GamificationTriviaApiFp.removeQuestionTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @summary Remove a tag from a batch of questions
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.removeTagToQuestionsBatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @summary List and search tags by the beginning of the string
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.searchQuestionTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * Changes should be made before process is started for there to be any effect.
     * @summary Update an import job
     * @param id The id of the job
     * @param request The updated job
     */
    updateImportJob(params: {  id: number; request?: ImportJobResource; }, options: any = {}) {
        return GamificationTriviaApiFp.updateImportJob(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a question
     * @param id The id of the question
     * @param question The updated question
     */
    updateQuestion(params: {  id: string; question?: QuestionResource; }, options: any = {}) {
        return GamificationTriviaApiFp.updateQuestion(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an answer for a question
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, options: any = {}) {
        return GamificationTriviaApiFp.updateQuestionAnswer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a question template
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
        return GamificationTriviaApiFp.updateQuestionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @summary Bulk update questions
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
        return GamificationTriviaApiFp.updateQuestionsInBulk(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamificationTriviaApi - factory interface
 */
export const GamificationTriviaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add an answer to a question
         * @param questionId The id of the question
         * @param answer The new answer
         */
        addQuestionAnswers(params: {  questionId: string; answer?: AnswerResource; }, options: any = {}) {
            return GamificationTriviaApiFp.addQuestionAnswers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a tag to a question
         * @param id The id of the question
         * @param tag The new tag
         */
        addQuestionTag(params: {  id: string; tag?: StringWrapper; }, options: any = {}) {
            return GamificationTriviaApiFp.addQuestionTag(params, options)(fetch, basePath);
        },
        /**
         * All questions that dont't have the tag and match filters will have it added. The returned number is the number of questions updated.
         * @summary Add a tag to a batch of questions
         * @param tag The tag to add
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        addTagToQuestionsBatch(params: {  tag?: StringWrapper; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.addTagToQuestionsBatch(params, options)(fetch, basePath);
        },
        /**
         * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
         * @summary Create an import job
         * @param request The new import job
         */
        createImportJob(params: {  request?: ImportJobResource; }, options: any = {}) {
            return GamificationTriviaApiFp.createImportJob(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a question
         * @param question The new question
         */
        createQuestion(params: {  question?: QuestionResource; }, options: any = {}) {
            return GamificationTriviaApiFp.createQuestion(params, options)(fetch, basePath);
        },
        /**
         * Question templates define a type of question and the properties they have
         * @summary Create a question template
         * @param questionTemplateResource The question template resource object
         */
        createQuestionTemplate(params: {  questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
            return GamificationTriviaApiFp.createQuestionTemplate(params, options)(fetch, basePath);
        },
        /**
         * Also deletes all questions that were imported by it
         * @summary Delete an import job
         * @param id The id of the job
         */
        deleteImportJob(params: {  id: number; }, options: any = {}) {
            return GamificationTriviaApiFp.deleteImportJob(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a question
         * @param id The id of the question
         */
        deleteQuestion(params: {  id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.deleteQuestion(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove an answer from a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        deleteQuestionAnswers(params: {  questionId: string; id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.deleteQuestionAnswers(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a question template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteQuestionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return GamificationTriviaApiFp.deleteQuestionTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an import job
         * @param id The id of the job
         */
        getImportJob(params: {  id: number; }, options: any = {}) {
            return GamificationTriviaApiFp.getImportJob(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of import job
         * @param filterVendor Filter for jobs by vendor id
         * @param filterCategory Filter for jobs by category id
         * @param filterName Filter for jobs which name *STARTS* with the given string
         * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getImportJobs(params: {  filterVendor?: string; filterCategory?: string; filterName?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getImportJobs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single question
         * @param id The id of the question
         */
        getQuestion(params: {  id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestion(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         */
        getQuestionAnswer(params: {  questionId: string; id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionAnswer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the answers available for a question
         * @param questionId The id of the question
         */
        getQuestionAnswers(params: {  questionId: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionAnswers(params, options)(fetch, basePath);
        },
        /**
         * The 'since' parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
         * @summary List question deltas in ascending order of updated date
         * @param since Timestamp in seconds
         */
        getQuestionDeltas(params: {  since?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionDeltas(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the tags for a question
         * @param id The id of the question
         */
        getQuestionTags(params: {  id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionTags(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single question template
         * @param id The id of the template
         */
        getQuestionTemplate(params: {  id: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search question templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getQuestionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search questions
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterTag Filter for questions with specified tag
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        getQuestions(params: {  size?: number; page?: number; order?: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterTag?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestions(params, options)(fetch, basePath);
        },
        /**
         * This is also provided by the list endpoint so you don't need to call this for pagination purposes
         * @summary Count questions based on filters
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         */
        getQuestionsCount(params: {  filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; }, options: any = {}) {
            return GamificationTriviaApiFp.getQuestionsCount(params, options)(fetch, basePath);
        },
        /**
         * Will process the CSV file and add new questions asynchronously. The status of the job must be 'VALID'.
         * @summary Start processing an import job
         * @param id The id of the job
         * @param publishNow Whether the new questions should be published live immediately
         */
        processImportJob(params: {  id: number; publishNow: boolean; }, options: any = {}) {
            return GamificationTriviaApiFp.processImportJob(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a tag from a question
         * @param id The id of the question
         * @param tag The tag to remove
         */
        removeQuestionTag(params: {  id: string; tag: string; }, options: any = {}) {
            return GamificationTriviaApiFp.removeQuestionTag(params, options)(fetch, basePath);
        },
        /**
         * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
         * @summary Remove a tag from a batch of questions
         * @param tag The tag to remove
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTag Filter for questions with specified tag
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        removeTagToQuestionsBatch(params: {  tag: string; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTag?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.removeTagToQuestionsBatch(params, options)(fetch, basePath);
        },
        /**
         * For performance reasons, search & category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
         * @summary List and search tags by the beginning of the string
         * @param filterSearch Filter for tags starting with the given text
         * @param filterCategory Filter for tags on questions from a specific category
         * @param filterImportId Filter for tags on questions from a specific import job
         */
        searchQuestionTags(params: {  filterSearch?: string; filterCategory?: string; filterImportId?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.searchQuestionTags(params, options)(fetch, basePath);
        },
        /**
         * Changes should be made before process is started for there to be any effect.
         * @summary Update an import job
         * @param id The id of the job
         * @param request The updated job
         */
        updateImportJob(params: {  id: number; request?: ImportJobResource; }, options: any = {}) {
            return GamificationTriviaApiFp.updateImportJob(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a question
         * @param id The id of the question
         * @param question The updated question
         */
        updateQuestion(params: {  id: string; question?: QuestionResource; }, options: any = {}) {
            return GamificationTriviaApiFp.updateQuestion(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an answer for a question
         * @param questionId The id of the question
         * @param id The id of the answer
         * @param answer The updated answer
         */
        updateQuestionAnswer(params: {  questionId: string; id: string; answer?: AnswerResource; }, options: any = {}) {
            return GamificationTriviaApiFp.updateQuestionAnswer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a question template
         * @param id The id of the template
         * @param questionTemplateResource The question template resource object
         */
        updateQuestionTemplate(params: {  id: string; questionTemplateResource?: QuestionTemplateResource; }, options: any = {}) {
            return GamificationTriviaApiFp.updateQuestionTemplate(params, options)(fetch, basePath);
        },
        /**
         * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
         * @summary Bulk update questions
         * @param question New values for a set of question fields
         * @param filterSearch Filter for documents whose question, answers or tags contains provided string
         * @param filterIdset Filter for documents whose id is in the comma separated list provided
         * @param filterCategory Filter for questions with specified category, by id
         * @param filterTagset Filter for questions with specified tags (separated by comma)
         * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
         * @param filterPublished Filter for questions currenctly published or not
         * @param filterImportId Filter for questions from a specific import job
         */
        updateQuestionsInBulk(params: {  question?: QuestionResource; filterSearch?: string; filterIdset?: string; filterCategory?: string; filterTagset?: string; filterType?: string; filterPublished?: boolean; filterImportId?: number; }, options: any = {}) {
            return GamificationTriviaApiFp.updateQuestionsInBulk(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoicesApi - fetch parameter creator
 */
export const InvoicesApiFetchParamCreator = {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: {  req?: InvoiceCreateRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["req"]) {
            fetchOptions.body = JSON.stringify(params["req"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options: any = {}): FetchArgs {
        const baseUrl = `/invoices/fulfillment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoice");
        }
        const baseUrl = `/invoices/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getInvoiceLogs");
        }
        const baseUrl = `/invoices/{id}/logs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/invoices`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterUser"] !== undefined) {
            urlObj.query["filter_user"] = params["filterUser"];
        }
        if (params["filterEmail"] !== undefined) {
            urlObj.query["filter_email"] = params["filterEmail"];
        }
        if (params["filterFulfillmentStatus"] !== undefined) {
            urlObj.query["filter_fulfillment_status"] = params["filterFulfillmentStatus"];
        }
        if (params["filterPaymentStatus"] !== undefined) {
            urlObj.query["filter_payment_status"] = params["filterPaymentStatus"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterExternalRef"] !== undefined) {
            urlObj.query["filter_external_ref"] = params["filterExternalRef"];
        }
        if (params["filterCreatedDate"] !== undefined) {
            urlObj.query["filter_created_date"] = params["filterCreatedDate"];
        }
        if (params["filterVendorIds"] !== undefined) {
            urlObj.query["filter_vendor_ids"] = params["filterVendorIds"];
        }
        if (params["filterCurrency"] !== undefined) {
            urlObj.query["filter_currency"] = params["filterCurrency"];
        }
        if (params["filterShippingStateName"] !== undefined) {
            urlObj.query["filter_shipping_state_name"] = params["filterShippingStateName"];
        }
        if (params["filterShippingCountryName"] !== undefined) {
            urlObj.query["filter_shipping_country_name"] = params["filterShippingCountryName"];
        }
        if (params["filterShipping"] !== undefined) {
            urlObj.query["filter_shipping"] = params["filterShipping"];
        }
        if (params["filterVendorName"] !== undefined) {
            urlObj.query["filter_vendor_name"] = params["filterVendorName"];
        }
        if (params["filterSku"] !== undefined) {
            urlObj.query["filter_sku"] = params["filterSku"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(options: any = {}): FetchArgs {
        const baseUrl = `/invoices/payment-statuses`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling payInvoice");
        }
        const baseUrl = `/invoices/{id}/payments`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "bundleSku" is set
        if (params["bundleSku"] == null) {
            throw new Error("Missing required parameter bundleSku when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling setBundledInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setBundledInvoiceItemFulfillmentStatus");
        }
        const baseUrl = `/invoices/{id}/items/{bundleSku}/bundled-skus/{sku}/fulfillment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"bundleSku"}}`, `${ params["bundleSku"] }`)
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setExternalRef");
        }
        const baseUrl = `/invoices/{id}/external-ref`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["externalRef"]) {
            fetchOptions.body = JSON.stringify(params["externalRef"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling setInvoiceItemFulfillmentStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setInvoiceItemFulfillmentStatus");
        }
        const baseUrl = `/invoices/{id}/items/{sku}/fulfillment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setOrderNotes");
        }
        const baseUrl = `/invoices/{id}/order-notes`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["orderNotes"]) {
            fetchOptions.body = JSON.stringify(params["orderNotes"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPaymentStatus");
        }
        const baseUrl = `/invoices/{id}/payment-status`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBillingInfo");
        }
        const baseUrl = `/invoices/{id}/billing-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billingInfoRequest"]) {
            fetchOptions.body = JSON.stringify(params["billingInfoRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoicesApi - functional programming interface
 */
export const InvoicesApiFp = {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: { req?: InvoiceCreateRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<InvoiceResource>> {
        const fetchArgs = InvoicesApiFetchParamCreator.createInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getFulFillmentStatuses(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: { id: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceLogEntry> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoiceLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: { filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceInvoiceResource> {
        const fetchArgs = InvoicesApiFetchParamCreator.getInvoices(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = InvoicesApiFetchParamCreator.getPaymentStatuses(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: { id: number; request?: PayBySavedMethodRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.payInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: { id: number; bundleSku: string; sku: string; status: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setBundledInvoiceItemFulfillmentStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: { id: number; externalRef?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setExternalRef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: { id: number; sku: string; status: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setInvoiceItemFulfillmentStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: { id: number; orderNotes?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setOrderNotes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: { id: number; request?: InvoicePaymentStatusRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.setPaymentStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: { id: number; billingInfoRequest?: AddressResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoicesApiFetchParamCreator.updateBillingInfo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoicesApi - object-oriented interface
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
     * @summary Create an invoice
     * @param req Invoice to be created
     */
    createInvoice(params: {  req?: InvoiceCreateRequest; }, options: any = {}) {
        return InvoicesApiFp.createInvoice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Lists available fulfillment statuses
     */
    getFulFillmentStatuses(options: any = {}) {
        return InvoicesApiFp.getFulFillmentStatuses(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve an invoice
     * @param id The id of the invoice
     */
    getInvoice(params: {  id: number; }, options: any = {}) {
        return InvoicesApiFp.getInvoice(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List invoice logs
     * @param id The id of the invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, options: any = {}) {
        return InvoicesApiFp.getInvoiceLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
     * @summary Retrieve invoices
     * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
     * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
     * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
     * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
     * @param filterItemName Filters invoices by item name containing the given string
     * @param filterExternalRef Filters invoices by external reference.
     * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
     * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
     * @param filterCurrency Filters invoices by currency. ISO3 currency code
     * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
     * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
     * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
     * @param filterVendorName Filters invoices by vendor name starting with given string
     * @param filterSku Filters invoices by item sku
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return InvoicesApiFp.getInvoices(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Lists available payment statuses
     */
    getPaymentStatuses(options: any = {}) {
        return InvoicesApiFp.getPaymentStatuses(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Pay an invoice using a saved payment method
     * @param id The id of the invoice
     * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
     */
    payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, options: any = {}) {
        return InvoicesApiFp.payInvoice(params, options)(this.fetch, this.basePath);
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of a bundled invoice item
     * @param id The id of the invoice
     * @param bundleSku The sku of the bundle in the invoice that contains the given target
     * @param sku The sku of an item in the bundle in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setBundledInvoiceItemFulfillmentStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set the external reference of an invoice
     * @param id The id of the invoice
     * @param externalRef External reference info
     */
    setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setExternalRef(params, options)(this.fetch, this.basePath);
    }
    /**
     * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the fulfillment status of an invoice item
     * @param id The id of the invoice
     * @param sku The sku of an item in the invoice
     * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
     */
    setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set the order notes of an invoice
     * @param id The id of the invoice
     * @param orderNotes Payment status info
     */
    setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, options: any = {}) {
        return InvoicesApiFp.setOrderNotes(params, options)(this.fetch, this.basePath);
    }
    /**
     * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
     * @summary Set the payment status of an invoice
     * @param id The id of the invoice
     * @param request Payment status info
     */
    setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, options: any = {}) {
        return InvoicesApiFp.setPaymentStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set or update billing info
     * @param id The id of the invoice
     * @param billingInfoRequest Address info
     */
    updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, options: any = {}) {
        return InvoicesApiFp.updateBillingInfo(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoicesApi - factory interface
 */
export const InvoicesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an invoice(s) by providing a cart GUID. Note that there may be multiple invoices created, one per vendor.
         * @summary Create an invoice
         * @param req Invoice to be created
         */
        createInvoice(params: {  req?: InvoiceCreateRequest; }, options: any = {}) {
            return InvoicesApiFp.createInvoice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists available fulfillment statuses
         */
        getFulFillmentStatuses(options: any = {}) {
            return InvoicesApiFp.getFulFillmentStatuses(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve an invoice
         * @param id The id of the invoice
         */
        getInvoice(params: {  id: number; }, options: any = {}) {
            return InvoicesApiFp.getInvoice(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List invoice logs
         * @param id The id of the invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getInvoiceLogs(params: {  id: number; size?: number; page?: number; }, options: any = {}) {
            return InvoicesApiFp.getInvoiceLogs(params, options)(fetch, basePath);
        },
        /**
         * Without INVOICES_ADMIN permission the results are automatically filtered for only the logged in user's invoices. It is recomended however that filter_user be added to avoid issues for admin users accidentally getting additional invoices.
         * @summary Retrieve invoices
         * @param filterUser The id of a user to get invoices for. Automtically added if not being called with admin permissions.
         * @param filterEmail Filters invoices by customer&#39;s email. Admins only.
         * @param filterFulfillmentStatus Filters invoices by fulfillment status type. Can be a comma separated list of statuses
         * @param filterPaymentStatus Filters invoices by payment status type. Can be a comma separated list of statuses
         * @param filterItemName Filters invoices by item name containing the given string
         * @param filterExternalRef Filters invoices by external reference.
         * @param filterCreatedDate Filters invoices by creation date. Multiple values possible for range search. Format: filter_created_date&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ) and ts is a unix timestamp in seconds. Ex: filter_created_date&#x3D;GT,1452154258,LT,1554254874
         * @param filterVendorIds Filters invoices for ones from one of the vendors whose id is in the given comma separated list
         * @param filterCurrency Filters invoices by currency. ISO3 currency code
         * @param filterShippingStateName Filters invoices by shipping address: Exact match state name
         * @param filterShippingCountryName Filters invoices by shipping address: Exact match country name
         * @param filterShipping Filters invoices by shipping price. Multiple values possible for range search. Format: filter_shipping&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_shipping&#x3D;GT,14.58,LT,15.54
         * @param filterVendorName Filters invoices by vendor name starting with given string
         * @param filterSku Filters invoices by item sku
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getInvoices(params: {  filterUser?: number; filterEmail?: string; filterFulfillmentStatus?: string; filterPaymentStatus?: string; filterItemName?: string; filterExternalRef?: string; filterCreatedDate?: string; filterVendorIds?: string; filterCurrency?: string; filterShippingStateName?: string; filterShippingCountryName?: string; filterShipping?: string; filterVendorName?: string; filterSku?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return InvoicesApiFp.getInvoices(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists available payment statuses
         */
        getPaymentStatuses(options: any = {}) {
            return InvoicesApiFp.getPaymentStatuses(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pay an invoice using a saved payment method
         * @param id The id of the invoice
         * @param request The payment method details. Will default to the appropriate user&#39;s wallet in the invoice currency if ommited.
         */
        payInvoice(params: {  id: number; request?: PayBySavedMethodRequest; }, options: any = {}) {
            return InvoicesApiFp.payInvoice(params, options)(fetch, basePath);
        },
        /**
         * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
         * @summary Set the fulfillment status of a bundled invoice item
         * @param id The id of the invoice
         * @param bundleSku The sku of the bundle in the invoice that contains the given target
         * @param sku The sku of an item in the bundle in the invoice
         * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
         */
        setBundledInvoiceItemFulfillmentStatus(params: {  id: number; bundleSku: string; sku: string; status: StringWrapper; }, options: any = {}) {
            return InvoicesApiFp.setBundledInvoiceItemFulfillmentStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the external reference of an invoice
         * @param id The id of the invoice
         * @param externalRef External reference info
         */
        setExternalRef(params: {  id: number; externalRef?: StringWrapper; }, options: any = {}) {
            return InvoicesApiFp.setExternalRef(params, options)(fetch, basePath);
        },
        /**
         * This allows external fulfillment systems to report success or failure. Fulfillment status changes are restricted by a specific flow determining which status can lead to which.
         * @summary Set the fulfillment status of an invoice item
         * @param id The id of the invoice
         * @param sku The sku of an item in the invoice
         * @param status The new fulfillment status for the item. Additional options may be available based on configuration.  Allowable values:  &#39;unfulfilled&#39;, &#39;fulfilled&#39;, &#39;not fulfillable&#39;, &#39;failed&#39;, &#39;processing&#39;, &#39;failed_permanent&#39;, &#39;delayed&#39;
         */
        setInvoiceItemFulfillmentStatus(params: {  id: number; sku: string; status: StringWrapper; }, options: any = {}) {
            return InvoicesApiFp.setInvoiceItemFulfillmentStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the order notes of an invoice
         * @param id The id of the invoice
         * @param orderNotes Payment status info
         */
        setOrderNotes(params: {  id: number; orderNotes?: StringWrapper; }, options: any = {}) {
            return InvoicesApiFp.setOrderNotes(params, options)(fetch, basePath);
        },
        /**
         * This may trigger fulfillment if setting the status to 'paid'. This is mainly intended to support external payment systems that cannot be incorporated into the payment method system. Payment status changes are restricted by a specific flow determining which status can lead to which.
         * @summary Set the payment status of an invoice
         * @param id The id of the invoice
         * @param request Payment status info
         */
        setPaymentStatus(params: {  id: number; request?: InvoicePaymentStatusRequest; }, options: any = {}) {
            return InvoicesApiFp.setPaymentStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set or update billing info
         * @param id The id of the invoice
         * @param billingInfoRequest Address info
         */
        updateBillingInfo(params: {  id: number; billingInfoRequest?: AddressResource; }, options: any = {}) {
            return InvoicesApiFp.updateBillingInfo(params, options)(fetch, basePath);
        },
    };
};


/**
 * LocationsApi - fetch parameter creator
 */
export const LocationsApiFetchParamCreator = {
    /**
     * 
     * @summary Get a list of countries
     */
    getCountries(options: any = {}): FetchArgs {
        const baseUrl = `/location/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Determined by geo ip location
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(options: any = {}): FetchArgs {
        const baseUrl = `/location/geolocation/country`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  countryCodeIso3: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryStates");
        }
        const baseUrl = `/location/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(options: any = {}): FetchArgs {
        const baseUrl = `/location/geolocation/currency`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LocationsApi - functional programming interface
 */
export const LocationsApiFp = {
    /**
     * 
     * @summary Get a list of countries
     */
    getCountries(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<CountryResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountries(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Determined by geo ip location
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryByGeoLocation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: { countryCodeIso3: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<StateResource>> {
        const fetchArgs = LocationsApiFetchParamCreator.getCountryStates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CurrencyResource> {
        const fetchArgs = LocationsApiFetchParamCreator.getCurrencyByGeoLocation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LocationsApi - object-oriented interface
 */
export class LocationsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of countries
     */
    getCountries(options: any = {}) {
        return LocationsApiFp.getCountries(options)(this.fetch, this.basePath);
    }
    /**
     * Determined by geo ip location
     * @summary Get the iso3 code of your country
     */
    getCountryByGeoLocation(options: any = {}) {
        return LocationsApiFp.getCountryByGeoLocation(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a list of a country's states
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryStates(params: {  countryCodeIso3: string; }, options: any = {}) {
        return LocationsApiFp.getCountryStates(params, options)(this.fetch, this.basePath);
    }
    /**
     * Determined by geo ip location, currency to country mapping and a fallback setting
     * @summary Get the currency information of your country
     */
    getCurrencyByGeoLocation(options: any = {}) {
        return LocationsApiFp.getCurrencyByGeoLocation(options)(this.fetch, this.basePath);
    }
};

/**
 * LocationsApi - factory interface
 */
export const LocationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a list of countries
         */
        getCountries(options: any = {}) {
            return LocationsApiFp.getCountries(options)(fetch, basePath);
        },
        /**
         * Determined by geo ip location
         * @summary Get the iso3 code of your country
         */
        getCountryByGeoLocation(options: any = {}) {
            return LocationsApiFp.getCountryByGeoLocation(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of a country's states
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryStates(params: {  countryCodeIso3: string; }, options: any = {}) {
            return LocationsApiFp.getCountryStates(params, options)(fetch, basePath);
        },
        /**
         * Determined by geo ip location, currency to country mapping and a fallback setting
         * @summary Get the currency information of your country
         */
        getCurrencyByGeoLocation(options: any = {}) {
            return LocationsApiFp.getCurrencyByGeoLocation(options)(fetch, basePath);
        },
    };
};


/**
 * LogsApi - fetch parameter creator
 */
export const LogsApiFetchParamCreator = {
    /**
     * 
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  logEntry?: UserActionLog; }, options: any = {}): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["logEntry"]) {
            fetchOptions.body = JSON.stringify(params["logEntry"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREEventLog");
        }
        const baseUrl = `/bre/logs/event-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/logs/event-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEventName"] !== undefined) {
            urlObj.query["filter_event_name"] = params["filterEventName"];
        }
        if (params["filterEventId"] !== undefined) {
            urlObj.query["filter_event_id"] = params["filterEventId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBREForwardLog");
        }
        const baseUrl = `/bre/logs/forward-log/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/bre/logs/forward-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterEndDate"] !== undefined) {
            urlObj.query["filter_end_date"] = params["filterEndDate"];
        }
        if (params["filterStatusCode"] !== undefined) {
            urlObj.query["filter_status_code"] = params["filterStatusCode"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserLog");
        }
        const baseUrl = `/audit/logs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/audit/logs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterUser"] !== undefined) {
            urlObj.query["filter_user"] = params["filterUser"];
        }
        if (params["filterActionName"] !== undefined) {
            urlObj.query["filter_action_name"] = params["filterActionName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LogsApi - functional programming interface
 */
export const LogsApiFp = {
    /**
     * 
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: { logEntry?: UserActionLog;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LogsApiFetchParamCreator.addUserLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: { filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBreEventLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREEventLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: { filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceForwardLog> {
        const fetchArgs = LogsApiFetchParamCreator.getBREForwardLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: { filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserActionLog> {
        const fetchArgs = LogsApiFetchParamCreator.getUserLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LogsApi - object-oriented interface
 */
export class LogsApi extends BaseAPI {
    /**
     * 
     * @summary Add a user log entry
     * @param logEntry The user log entry to be added
     */
    addUserLog(params: {  logEntry?: UserActionLog; }, options: any = {}) {
        return LogsApiFp.addUserLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get an existing BRE event log entry by id
     * @param id The BRE event log entry id
     */
    getBREEventLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getBREEventLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a list of BRE event log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEventName Filter event logs by event name
     * @param filterEventId Filter event logs by request id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return LogsApiFp.getBREEventLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get an existing forward log entry by id
     * @param id The forward log entry id
     */
    getBREForwardLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getBREForwardLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a list of forward log entries
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterStatusCode Filter forward logs by http status code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return LogsApiFp.getBREForwardLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a user log entry by id
     * @param id The user log entry id
     */
    getUserLog(params: {  id: string; }, options: any = {}) {
        return LogsApiFp.getUserLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of user logs entries
     * @param filterUser Filter for actions taken by a specific user by id
     * @param filterActionName Filter for actions of a specific name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return LogsApiFp.getUserLogs(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LogsApi - factory interface
 */
export const LogsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a user log entry
         * @param logEntry The user log entry to be added
         */
        addUserLog(params: {  logEntry?: UserActionLog; }, options: any = {}) {
            return LogsApiFp.addUserLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an existing BRE event log entry by id
         * @param id The BRE event log entry id
         */
        getBREEventLog(params: {  id: string; }, options: any = {}) {
            return LogsApiFp.getBREEventLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of BRE event log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the event log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEventName Filter event logs by event name
         * @param filterEventId Filter event logs by request id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBREEventLogs(params: {  filterStartDate?: string; filterEventName?: string; filterEventId?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return LogsApiFp.getBREEventLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an existing forward log entry by id
         * @param id The forward log entry id
         */
        getBREForwardLog(params: {  id: string; }, options: any = {}) {
            return LogsApiFp.getBREForwardLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of forward log entries
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterEndDate A comma separated string without spaces.  First value is the operator to search on, second value is the log end date, a unix timestamp in seconds.  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterStatusCode Filter forward logs by http status code
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBREForwardLogs(params: {  filterStartDate?: string; filterEndDate?: string; filterStatusCode?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return LogsApiFp.getBREForwardLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a user log entry by id
         * @param id The user log entry id
         */
        getUserLog(params: {  id: string; }, options: any = {}) {
            return LogsApiFp.getUserLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of user logs entries
         * @param filterUser Filter for actions taken by a specific user by id
         * @param filterActionName Filter for actions of a specific name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLogs(params: {  filterUser?: number; filterActionName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return LogsApiFp.getUserLogs(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaArtistsApi - fetch parameter creator
 */
export const MediaArtistsApiFetchParamCreator = {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: {  artistResource?: ArtistResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Artist Templates define a type of artist and the properties they have
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  id: number; showContributions?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["showContributions"] !== undefined) {
            urlObj.query["show_contributions"] = params["showContributions"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/artists`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterArtistsByName"] !== undefined) {
            urlObj.query["filter_artists_by_name"] = params["filterArtistsByName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  id: number; artistResource?: ArtistResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtist");
        }
        const baseUrl = `/media/artists/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistResource"]) {
            fetchOptions.body = JSON.stringify(params["artistResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateArtistTemplate");
        }
        const baseUrl = `/media/artists/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["artistTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["artistTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaArtistsApi - functional programming interface
 */
export const MediaArtistsApiFp = {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: { artistResource?: ArtistResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.addArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Artist Templates define a type of artist and the properties they have
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: { artistTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.createArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.deleteArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.deleteArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: { id: number; showContributions?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtistTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: { filterArtistsByName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceArtistResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.getArtists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: { id: number; artistResource?: ArtistResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.updateArtist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: { id: string; artistTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = MediaArtistsApiFetchParamCreator.updateArtistTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaArtistsApi - object-oriented interface
 */
export class MediaArtistsApi extends BaseAPI {
    /**
     * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
     * @summary Adds a new artist in the system
     * @param artistResource The new artist
     */
    addArtist(params: {  artistResource?: ArtistResource; }, options: any = {}) {
        return MediaArtistsApiFp.addArtist(params, options)(this.fetch, this.basePath);
    }
    /**
     * Artist Templates define a type of artist and the properties they have
     * @summary Create an artist template
     * @param artistTemplateResource The artist template resource object
     */
    createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, options: any = {}) {
        return MediaArtistsApiFp.createArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Removes an artist from the system IF no resources are attached to it
     * @param id The artist id
     */
    deleteArtist(params: {  id: number; }, options: any = {}) {
        return MediaArtistsApiFp.deleteArtist(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an artist template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteArtistTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return MediaArtistsApiFp.deleteArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Loads a specific artist details
     * @param id The artist id
     * @param showContributions The number of contributions to show fetch
     */
    getArtist(params: {  id: number; showContributions?: number; }, options: any = {}) {
        return MediaArtistsApiFp.getArtist(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single artist template
     * @param id The id of the template
     */
    getArtistTemplate(params: {  id: string; }, options: any = {}) {
        return MediaArtistsApiFp.getArtistTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search artist templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return MediaArtistsApiFp.getArtistTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Search for artists
     * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return MediaArtistsApiFp.getArtists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Modifies an artist details
     * @param id The artist id
     * @param artistResource The new artist
     */
    updateArtist(params: {  id: number; artistResource?: ArtistResource; }, options: any = {}) {
        return MediaArtistsApiFp.updateArtist(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an artist template
     * @param id The id of the template
     * @param artistTemplateResource The artist template resource object
     */
    updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, options: any = {}) {
        return MediaArtistsApiFp.updateArtistTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaArtistsApi - factory interface
 */
export const MediaArtistsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds a new artist in the system. Use specific media contributions endpoint to add contributions
         * @summary Adds a new artist in the system
         * @param artistResource The new artist
         */
        addArtist(params: {  artistResource?: ArtistResource; }, options: any = {}) {
            return MediaArtistsApiFp.addArtist(params, options)(fetch, basePath);
        },
        /**
         * Artist Templates define a type of artist and the properties they have
         * @summary Create an artist template
         * @param artistTemplateResource The artist template resource object
         */
        createArtistTemplate(params: {  artistTemplateResource?: TemplateResource; }, options: any = {}) {
            return MediaArtistsApiFp.createArtistTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes an artist from the system IF no resources are attached to it
         * @param id The artist id
         */
        deleteArtist(params: {  id: number; }, options: any = {}) {
            return MediaArtistsApiFp.deleteArtist(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete an artist template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteArtistTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return MediaArtistsApiFp.deleteArtistTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loads a specific artist details
         * @param id The artist id
         * @param showContributions The number of contributions to show fetch
         */
        getArtist(params: {  id: number; showContributions?: number; }, options: any = {}) {
            return MediaArtistsApiFp.getArtist(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single artist template
         * @param id The id of the template
         */
        getArtistTemplate(params: {  id: string; }, options: any = {}) {
            return MediaArtistsApiFp.getArtistTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search artist templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtistTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return MediaArtistsApiFp.getArtistTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search for artists
         * @param filterArtistsByName Filter for artists which name *STARTS* with the given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getArtists(params: {  filterArtistsByName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return MediaArtistsApiFp.getArtists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Modifies an artist details
         * @param id The artist id
         * @param artistResource The new artist
         */
        updateArtist(params: {  id: number; artistResource?: ArtistResource; }, options: any = {}) {
            return MediaArtistsApiFp.updateArtist(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an artist template
         * @param id The id of the template
         * @param artistTemplateResource The artist template resource object
         */
        updateArtistTemplate(params: {  id: string; artistTemplateResource?: TemplateResource; }, options: any = {}) {
            return MediaArtistsApiFp.updateArtistTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaModerationApi - fetch parameter creator
 */
export const MediaModerationApiFetchParamCreator = {
    /**
     * 
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Context can be either a free-form string or a pre-defined context name
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/moderation/reports`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeResolved"] !== undefined) {
            urlObj.query["exclude_resolved"] = params["excludeResolved"];
        }
        if (params["filterContext"] !== undefined) {
            urlObj.query["filter_context"] = params["filterContext"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason.
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateModerationReport");
        }
        const baseUrl = `/moderation/reports/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["flagReportResource"]) {
            fetchOptions.body = JSON.stringify(params["flagReportResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaModerationApi - functional programming interface
 */
export const MediaModerationApiFp = {
    /**
     * 
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FlagReportResource> {
        const fetchArgs = MediaModerationApiFetchParamCreator.getModerationReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Context can be either a free-form string or a pre-defined context name
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: { excludeResolved?: boolean; filterContext?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceFlagReportResource> {
        const fetchArgs = MediaModerationApiFetchParamCreator.getModerationReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason.
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: { id: number; flagReportResource?: FlagReportResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaModerationApiFetchParamCreator.updateModerationReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaModerationApi - object-oriented interface
 */
export class MediaModerationApi extends BaseAPI {
    /**
     * 
     * @summary Get a flag report
     * @param id The flag report id
     */
    getModerationReport(params: {  id: number; }, options: any = {}) {
        return MediaModerationApiFp.getModerationReport(params, options)(this.fetch, this.basePath);
    }
    /**
     * Context can be either a free-form string or a pre-defined context name
     * @summary Returns a page of flag reports
     * @param excludeResolved Ignore resolved context
     * @param filterContext Filter by moderation context
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; size?: number; page?: number; }, options: any = {}) {
        return MediaModerationApiFp.getModerationReports(params, options)(this.fetch, this.basePath);
    }
    /**
     * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason.
     * @summary Update a flag report
     * @param id The flag report id
     * @param flagReportResource The new flag report
     */
    updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, options: any = {}) {
        return MediaModerationApiFp.updateModerationReport(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaModerationApi - factory interface
 */
export const MediaModerationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a flag report
         * @param id The flag report id
         */
        getModerationReport(params: {  id: number; }, options: any = {}) {
            return MediaModerationApiFp.getModerationReport(params, options)(fetch, basePath);
        },
        /**
         * Context can be either a free-form string or a pre-defined context name
         * @summary Returns a page of flag reports
         * @param excludeResolved Ignore resolved context
         * @param filterContext Filter by moderation context
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getModerationReports(params: {  excludeResolved?: boolean; filterContext?: string; size?: number; page?: number; }, options: any = {}) {
            return MediaModerationApiFp.getModerationReports(params, options)(fetch, basePath);
        },
        /**
         * Lets you set the resolution of a report. Resolution types is {banned,ignore} in case of 'banned' you will need to pass the reason.
         * @summary Update a flag report
         * @param id The flag report id
         * @param flagReportResource The new flag report
         */
        updateModerationReport(params: {  id: number; flagReportResource?: FlagReportResource; }, options: any = {}) {
            return MediaModerationApiFp.updateModerationReport(params, options)(fetch, basePath);
        },
    };
};


/**
 * MediaVideosApi - fetch parameter creator
 */
export const MediaVideosApiFetchParamCreator = {
    /**
     * Whitelisted users can view video regardless of privacy setting.
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addUserToVideoWhitelist");
        }
        const baseUrl = `/media/videos/{id}/whitelist`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  videoResource?: VideoResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["commentResource"]) {
            fetchOptions.body = JSON.stringify(params["commentResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["contributionResource"]) {
            fetchOptions.body = JSON.stringify(params["contributionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reason"]) {
            fetchOptions.body = JSON.stringify(params["reason"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling addVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoRelationshipResource"]) {
            fetchOptions.body = JSON.stringify(params["videoRelationshipResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling createVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["dispositionResource"]) {
            fetchOptions.body = JSON.stringify(params["dispositionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  videoId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  dispositionId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "dispositionId" is set
        if (params["dispositionId"] == null) {
            throw new Error("Missing required parameter dispositionId when calling deleteVideoDisposition");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions/{disposition_id}`
            .replace(`{${"disposition_id"}}`, `${ params["dispositionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  videoId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoFlag");
        }
        const baseUrl = `/media/videos/{video_id}/moderation`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  videoId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling deleteVideoRelationship");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserVideos");
        }
        const baseUrl = `/users/{user_id}/videos`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeFlagged"] !== undefined) {
            urlObj.query["exclude_flagged"] = params["excludeFlagged"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  videoId: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoComments");
        }
        const baseUrl = `/media/videos/{video_id}/comments`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoDispositions");
        }
        const baseUrl = `/media/videos/{video_id}/dispositions`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling getVideoRelationships");
        }
        const baseUrl = `/media/videos/{video_id}/related`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/media/videos`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["excludeFlagged"] !== undefined) {
            urlObj.query["exclude_flagged"] = params["excludeFlagged"];
        }
        if (params["filterVideosByUploader"] !== undefined) {
            urlObj.query["filter_videos_by_uploader"] = params["filterVideosByUploader"];
        }
        if (params["filterCategory"] !== undefined) {
            urlObj.query["filter_category"] = params["filterCategory"];
        }
        if (params["filterTagset"] !== undefined) {
            urlObj.query["filter_tagset"] = params["filterTagset"];
        }
        if (params["filterVideosByName"] !== undefined) {
            urlObj.query["filter_videos_by_name"] = params["filterVideosByName"];
        }
        if (params["filterVideosByContributor"] !== undefined) {
            urlObj.query["filter_videos_by_contributor"] = params["filterVideosByContributor"];
        }
        if (params["filterVideosByAuthor"] !== undefined) {
            urlObj.query["filter_videos_by_author"] = params["filterVideosByAuthor"];
        }
        if (params["filterHasAuthor"] !== undefined) {
            urlObj.query["filter_has_author"] = params["filterHasAuthor"];
        }
        if (params["filterHasUploader"] !== undefined) {
            urlObj.query["filter_has_uploader"] = params["filterHasUploader"];
        }
        if (params["filterRelatedTo"] !== undefined) {
            urlObj.query["filter_related_to"] = params["filterRelatedTo"];
        }
        if (params["filterFriends"] !== undefined) {
            urlObj.query["filter_friends"] = params["filterFriends"];
        }
        if (params["filterDisposition"] !== undefined) {
            urlObj.query["filter_disposition"] = params["filterDisposition"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeUserFromVideoWhitelist");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeUserFromVideoWhitelist");
        }
        const baseUrl = `/media/videos/{video_id}/whitelist/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  videoId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling removeVideoContributor");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeVideoContributor");
        }
        const baseUrl = `/media/videos/{video_id}/contributors/{id}`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  id: number; videoResource?: VideoResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideo");
        }
        const baseUrl = `/media/videos/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["videoResource"]) {
            fetchOptions.body = JSON.stringify(params["videoResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoComment");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVideoComment");
        }
        const baseUrl = `/media/videos/{video_id}/comments/{id}/content`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "videoId" is set
        if (params["videoId"] == null) {
            throw new Error("Missing required parameter videoId when calling updateVideoRelationship");
        }
        // verify required parameter "relationshipId" is set
        if (params["relationshipId"] == null) {
            throw new Error("Missing required parameter relationshipId when calling updateVideoRelationship");
        }
        const baseUrl = `/media/videos/{video_id}/related/{id}/relationship_details`
            .replace(`{${"video_id"}}`, `${ params["videoId"] }`)
            .replace(`{${"relationship_id"}}`, `${ params["relationshipId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling viewVideo");
        }
        const baseUrl = `/media/videos/{id}/views`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MediaVideosApi - functional programming interface
 */
export const MediaVideosApiFp = {
    /**
     * Whitelisted users can view video regardless of privacy setting.
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: { id: number; userId?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addUserToVideoWhitelist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: { videoResource?: VideoResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: { videoId: number; commentResource?: CommentResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CommentResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: { videoId: number; contributionResource?: ContributionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoContributor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: { videoId: number; reason?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FlagResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoFlag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: { videoId: number; videoRelationshipResource?: VideoRelationshipResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoRelationshipResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.addVideoRelationships(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: { videoId: number; dispositionResource?: DispositionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DispositionResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.createVideoDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: { videoId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: { dispositionId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoDisposition(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: { videoId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoFlag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: { videoId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.deleteVideoRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: { userId: number; excludeFlagged?: boolean; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getUserVideos(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: { videoId: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCommentResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: { videoId: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceDispositionResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoDispositions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: { videoId: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoRelationshipResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideoRelationships(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: { excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVideoResource> {
        const fetchArgs = MediaVideosApiFetchParamCreator.getVideos(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: { videoId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.removeUserFromVideoWhitelist(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: { videoId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.removeVideoContributor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: { id: number; videoResource?: VideoResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: { videoId: number; id: number; content?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideoComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: { videoId: number; relationshipId: number; details?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.updateVideoRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MediaVideosApiFetchParamCreator.viewVideo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MediaVideosApi - object-oriented interface
 */
export class MediaVideosApi extends BaseAPI {
    /**
     * Whitelisted users can view video regardless of privacy setting.
     * @summary Adds a user to a video's whitelist
     * @param id The video id
     * @param userId The user id
     */
    addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, options: any = {}) {
        return MediaVideosApiFp.addUserToVideoWhitelist(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds a new video in the system
     * @param videoResource The video object
     */
    addVideo(params: {  videoResource?: VideoResource; }, options: any = {}) {
        return MediaVideosApiFp.addVideo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a new video comment
     * @param videoId The video id 
     * @param commentResource The comment object
     */
    addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, options: any = {}) {
        return MediaVideosApiFp.addVideoComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds a contributor to a video
     * @param videoId The video id
     * @param contributionResource The contribution object
     */
    addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, options: any = {}) {
        return MediaVideosApiFp.addVideoContributor(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a new flag
     * @param videoId The video id
     * @param reason The flag reason
     */
    addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, options: any = {}) {
        return MediaVideosApiFp.addVideoFlag(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds one or more existing videos as related to this one
     * @param videoId The video id
     * @param videoRelationshipResource The video relationship object 
     */
    addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, options: any = {}) {
        return MediaVideosApiFp.addVideoRelationships(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a video disposition
     * @param videoId The video id
     * @param dispositionResource The disposition object
     */
    createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, options: any = {}) {
        return MediaVideosApiFp.createVideoDisposition(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes a video from the system if no resources are attached to it
     * @param id The video id
     */
    deleteVideo(params: {  id: number; }, options: any = {}) {
        return MediaVideosApiFp.deleteVideo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a video comment
     * @param videoId The video id
     * @param id The comment id
     */
    deleteVideoComment(params: {  videoId: number; id: number; }, options: any = {}) {
        return MediaVideosApiFp.deleteVideoComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a video disposition
     * @param dispositionId The disposition id
     */
    deleteVideoDisposition(params: {  dispositionId: number; }, options: any = {}) {
        return MediaVideosApiFp.deleteVideoDisposition(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a flag
     * @param videoId The video id
     */
    deleteVideoFlag(params: {  videoId: number; }, options: any = {}) {
        return MediaVideosApiFp.deleteVideoFlag(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a video's relationship
     * @param videoId The video id
     * @param id The relationship id
     */
    deleteVideoRelationship(params: {  videoId: number; id: number; }, options: any = {}) {
        return MediaVideosApiFp.deleteVideoRelationship(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get user videos
     * @param userId The user id
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, options: any = {}) {
        return MediaVideosApiFp.getUserVideos(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Loads a specific video details
     * @param id The video id
     */
    getVideo(params: {  id: number; }, options: any = {}) {
        return MediaVideosApiFp.getVideo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of comments for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoComments(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return MediaVideosApiFp.getVideoComments(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of dispositions for a video
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return MediaVideosApiFp.getVideoDispositions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns a page of video relationships
     * @param videoId The video id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
        return MediaVideosApiFp.getVideoRelationships(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Search videos using the documented filters
     * @param excludeFlagged Skip videos that have been flagged by the current user
     * @param filterVideosByUploader Filter for videos by uploader id
     * @param filterCategory Filter for videos from a specific category by id
     * @param filterTagset Filter for videos with specified tags (separated by comma)
     * @param filterVideosByName Filter for videos which name *STARTS* with the given string
     * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
     * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
     * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
     * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
     * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
     * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
     * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return MediaVideosApiFp.getVideos(params, options)(this.fetch, this.basePath);
    }
    /**
     * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
     * @summary Removes a user from a video's whitelist
     * @param videoId The video id
     * @param id The user id
     */
    removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, options: any = {}) {
        return MediaVideosApiFp.removeUserFromVideoWhitelist(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Removes a contributor from a video
     * @param videoId The video id
     * @param id The contributor id
     */
    removeVideoContributor(params: {  videoId: number; id: number; }, options: any = {}) {
        return MediaVideosApiFp.removeVideoContributor(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Modifies a video's details
     * @param id The video id
     * @param videoResource The video object
     */
    updateVideo(params: {  id: number; videoResource?: VideoResource; }, options: any = {}) {
        return MediaVideosApiFp.updateVideo(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a video comment
     * @param videoId The video id
     * @param id The comment id
     * @param content The comment content
     */
    updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, options: any = {}) {
        return MediaVideosApiFp.updateVideoComment(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a video's relationship details
     * @param videoId The video id
     * @param relationshipId The relationship id
     * @param details The video relationship details
     */
    updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, options: any = {}) {
        return MediaVideosApiFp.updateVideoRelationship(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Increment a video's view count
     * @param id The video id
     */
    viewVideo(params: {  id: number; }, options: any = {}) {
        return MediaVideosApiFp.viewVideo(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MediaVideosApi - factory interface
 */
export const MediaVideosApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Whitelisted users can view video regardless of privacy setting.
         * @summary Adds a user to a video's whitelist
         * @param id The video id
         * @param userId The user id
         */
        addUserToVideoWhitelist(params: {  id: number; userId?: IntWrapper; }, options: any = {}) {
            return MediaVideosApiFp.addUserToVideoWhitelist(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new video in the system
         * @param videoResource The video object
         */
        addVideo(params: {  videoResource?: VideoResource; }, options: any = {}) {
            return MediaVideosApiFp.addVideo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a new video comment
         * @param videoId The video id 
         * @param commentResource The comment object
         */
        addVideoComment(params: {  videoId: number; commentResource?: CommentResource; }, options: any = {}) {
            return MediaVideosApiFp.addVideoComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a contributor to a video
         * @param videoId The video id
         * @param contributionResource The contribution object
         */
        addVideoContributor(params: {  videoId: number; contributionResource?: ContributionResource; }, options: any = {}) {
            return MediaVideosApiFp.addVideoContributor(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a new flag
         * @param videoId The video id
         * @param reason The flag reason
         */
        addVideoFlag(params: {  videoId: number; reason?: StringWrapper; }, options: any = {}) {
            return MediaVideosApiFp.addVideoFlag(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds one or more existing videos as related to this one
         * @param videoId The video id
         * @param videoRelationshipResource The video relationship object 
         */
        addVideoRelationships(params: {  videoId: number; videoRelationshipResource?: VideoRelationshipResource; }, options: any = {}) {
            return MediaVideosApiFp.addVideoRelationships(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a video disposition
         * @param videoId The video id
         * @param dispositionResource The disposition object
         */
        createVideoDisposition(params: {  videoId: number; dispositionResource?: DispositionResource; }, options: any = {}) {
            return MediaVideosApiFp.createVideoDisposition(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a video from the system if no resources are attached to it
         * @param id The video id
         */
        deleteVideo(params: {  id: number; }, options: any = {}) {
            return MediaVideosApiFp.deleteVideo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a video comment
         * @param videoId The video id
         * @param id The comment id
         */
        deleteVideoComment(params: {  videoId: number; id: number; }, options: any = {}) {
            return MediaVideosApiFp.deleteVideoComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a video disposition
         * @param dispositionId The disposition id
         */
        deleteVideoDisposition(params: {  dispositionId: number; }, options: any = {}) {
            return MediaVideosApiFp.deleteVideoDisposition(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a flag
         * @param videoId The video id
         */
        deleteVideoFlag(params: {  videoId: number; }, options: any = {}) {
            return MediaVideosApiFp.deleteVideoFlag(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a video's relationship
         * @param videoId The video id
         * @param id The relationship id
         */
        deleteVideoRelationship(params: {  videoId: number; id: number; }, options: any = {}) {
            return MediaVideosApiFp.deleteVideoRelationship(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user videos
         * @param userId The user id
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserVideos(params: {  userId: number; excludeFlagged?: boolean; size?: number; page?: number; }, options: any = {}) {
            return MediaVideosApiFp.getUserVideos(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loads a specific video details
         * @param id The video id
         */
        getVideo(params: {  id: number; }, options: any = {}) {
            return MediaVideosApiFp.getVideo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of comments for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoComments(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
            return MediaVideosApiFp.getVideoComments(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of dispositions for a video
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoDispositions(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
            return MediaVideosApiFp.getVideoDispositions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a page of video relationships
         * @param videoId The video id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getVideoRelationships(params: {  videoId: number; size?: number; page?: number; }, options: any = {}) {
            return MediaVideosApiFp.getVideoRelationships(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Search videos using the documented filters
         * @param excludeFlagged Skip videos that have been flagged by the current user
         * @param filterVideosByUploader Filter for videos by uploader id
         * @param filterCategory Filter for videos from a specific category by id
         * @param filterTagset Filter for videos with specified tags (separated by comma)
         * @param filterVideosByName Filter for videos which name *STARTS* with the given string
         * @param filterVideosByContributor Filter for videos with contribution from the artist specified by ID
         * @param filterVideosByAuthor Filter for videos with an artist as author specified by ID
         * @param filterHasAuthor Filter for videos that have an author set if true, or that have no author if false
         * @param filterHasUploader Filter for videos that have an uploader set if true, or that have no uploader if false
         * @param filterRelatedTo Filter for videos that have designated a particular video as the TO of a relationship. Pattern should match VIDEO_ID or VIDEO_ID:DETAILS to match with a specific details string as well
         * @param filterFriends Filter for videos uploaded by friends. &#39;true&#39; for friends of the caller (requires user token) or a user id for a specific user&#39;s friends (requires VIDEOS_ADMIN permission)
         * @param filterDisposition Filter for videos a given user has a given disposition towards. USER_ID:DISPOSITION where USER_ID is the id of the user who has this disposition or &#39;me&#39; for the caller (requires user token for &#39;me&#39;) and DISPOSITION is the name of the disposition. E.G. filter_disposition&#x3D;123:like or filter_disposition&#x3D;me:favorite
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVideos(params: {  excludeFlagged?: boolean; filterVideosByUploader?: number; filterCategory?: string; filterTagset?: string; filterVideosByName?: string; filterVideosByContributor?: number; filterVideosByAuthor?: number; filterHasAuthor?: boolean; filterHasUploader?: boolean; filterRelatedTo?: string; filterFriends?: boolean; filterDisposition?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return MediaVideosApiFp.getVideos(params, options)(fetch, basePath);
        },
        /**
         * Remove the user with the id given in the path from the whitelist of users that can view this video regardless of privacy setting.
         * @summary Removes a user from a video's whitelist
         * @param videoId The video id
         * @param id The user id
         */
        removeUserFromVideoWhitelist(params: {  videoId: number; id: number; }, options: any = {}) {
            return MediaVideosApiFp.removeUserFromVideoWhitelist(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes a contributor from a video
         * @param videoId The video id
         * @param id The contributor id
         */
        removeVideoContributor(params: {  videoId: number; id: number; }, options: any = {}) {
            return MediaVideosApiFp.removeVideoContributor(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Modifies a video's details
         * @param id The video id
         * @param videoResource The video object
         */
        updateVideo(params: {  id: number; videoResource?: VideoResource; }, options: any = {}) {
            return MediaVideosApiFp.updateVideo(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a video comment
         * @param videoId The video id
         * @param id The comment id
         * @param content The comment content
         */
        updateVideoComment(params: {  videoId: number; id: number; content?: StringWrapper; }, options: any = {}) {
            return MediaVideosApiFp.updateVideoComment(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a video's relationship details
         * @param videoId The video id
         * @param relationshipId The relationship id
         * @param details The video relationship details
         */
        updateVideoRelationship(params: {  videoId: number; relationshipId: number; details?: StringWrapper; }, options: any = {}) {
            return MediaVideosApiFp.updateVideoRelationship(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Increment a video's view count
         * @param id The video id
         */
        viewVideo(params: {  id: number; }, options: any = {}) {
            return MediaVideosApiFp.viewVideo(params, options)(fetch, basePath);
        },
    };
};


/**
 * MessagingApi - fetch parameter creator
 */
export const MessagingApiFetchParamCreator = {
    /**
     * 
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/raw-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawEmailResource"]) {
            fetchOptions.body = JSON.stringify(params["rawEmailResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/raw-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["rawSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["rawSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templated-email`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["messageResource"]) {
            fetchOptions.body = JSON.stringify(params["messageResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/messaging/templated-sms`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["templateSMSResource"]) {
            fetchOptions.body = JSON.stringify(params["templateSMSResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * MessagingApi - functional programming interface
 */
export const MessagingApiFp = {
    /**
     * 
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: { rawEmailResource?: RawEmailResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: { rawSMSResource?: RawSMSResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendRawSMS(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: { messageResource?: TemplateEmailResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: { templateSMSResource?: TemplateSMSResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = MessagingApiFetchParamCreator.sendTemplatedSMS(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * MessagingApi - object-oriented interface
 */
export class MessagingApi extends BaseAPI {
    /**
     * 
     * @summary Send a raw email to one or more users
     * @param rawEmailResource The new raw email to be sent
     */
    sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, options: any = {}) {
        return MessagingApiFp.sendRawEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a raw SMS
     * @param rawSMSResource The new raw SMS to be sent
     */
    sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, options: any = {}) {
        return MessagingApiFp.sendRawSMS(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Send a templated email to one or more users
     * @param messageResource The new template email to be sent
     */
    sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, options: any = {}) {
        return MessagingApiFp.sendTemplatedEmail(params, options)(this.fetch, this.basePath);
    }
    /**
     * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped.
     * @summary Send a new templated SMS
     * @param templateSMSResource The new template SMS to be sent
     */
    sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, options: any = {}) {
        return MessagingApiFp.sendTemplatedSMS(params, options)(this.fetch, this.basePath);
    }
};

/**
 * MessagingApi - factory interface
 */
export const MessagingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Send a raw email to one or more users
         * @param rawEmailResource The new raw email to be sent
         */
        sendRawEmail(params: {  rawEmailResource?: RawEmailResource; }, options: any = {}) {
            return MessagingApiFp.sendRawEmail(params, options)(fetch, basePath);
        },
        /**
         * Sends a raw SMS text message to one or more users. User's without registered mobile numbers will be skipped.
         * @summary Send a raw SMS
         * @param rawSMSResource The new raw SMS to be sent
         */
        sendRawSMS(params: {  rawSMSResource?: RawSMSResource; }, options: any = {}) {
            return MessagingApiFp.sendRawSMS(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Send a templated email to one or more users
         * @param messageResource The new template email to be sent
         */
        sendTemplatedEmail(params: {  messageResource?: TemplateEmailResource; }, options: any = {}) {
            return MessagingApiFp.sendTemplatedEmail(params, options)(fetch, basePath);
        },
        /**
         * Sends a templated SMS text message to one or more users. User's without registered mobile numbers will be skipped.
         * @summary Send a new templated SMS
         * @param templateSMSResource The new template SMS to be sent
         */
        sendTemplatedSMS(params: {  templateSMSResource?: TemplateSMSResource; }, options: any = {}) {
            return MessagingApiFp.sendTemplatedSMS(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsApi - fetch parameter creator
 */
export const PaymentsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  userId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deletePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deletePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  userId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getPaymentMethods");
        }
        const baseUrl = `/users/{user_id}/payment-methods`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterPaymentType"] !== undefined) {
            urlObj.query["filter_payment_type"] = params["filterPaymentType"];
        }
        if (params["filterPaymentMethodTypeId"] !== undefined) {
            urlObj.query["filter_payment_method_type_id"] = params["filterPaymentMethodTypeId"];
        }
        if (params["filterPaymentMethodTypeName"] !== undefined) {
            urlObj.query["filter_payment_method_type_name"] = params["filterPaymentMethodTypeName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/authorizations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling paymentCapture");
        }
        const baseUrl = `/payment/authorizations/{id}/capture`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updatePaymentMethod");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updatePaymentMethod");
        }
        const baseUrl = `/users/{user_id}/payment-methods/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethod"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethod"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = {
    /**
     * 
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: { userId: number; paymentMethod?: PaymentMethodResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.createPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: { userId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.deletePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: { userId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: { userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<PaymentMethodResource>> {
        const fetchArgs = PaymentsApiFetchParamCreator.getPaymentMethods(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: { request?: PaymentAuthorizationResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentAuthorizationResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentAuthorization(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsApiFetchParamCreator.paymentCapture(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: { userId: number; id: number; paymentMethod?: PaymentMethodResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsApiFetchParamCreator.updatePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new payment method for a user
     * @param userId ID of the user for whom the payment method is being created
     * @param paymentMethod Payment method being created
     */
    createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
        return PaymentsApiFp.createPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being deleted
     */
    deletePaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
        return PaymentsApiFp.deletePaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single payment method for a user
     * @param userId ID of the user for whom the payment method is being retrieved
     * @param id ID of the payment method being retrieved
     */
    getPaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get all payment methods for a user
     * @param userId ID of the user for whom the payment methods are being retrieved
     * @param filterName Filter for payment methods whose name starts with a given string
     * @param filterPaymentType Filter for payment methods with a specific payment type
     * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
     * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsApiFp.getPaymentMethods(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Authorize payment of an invoice for later capture
     * @param request Payment authorization request
     */
    paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, options: any = {}) {
        return PaymentsApiFp.paymentAuthorization(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Capture an existing invoice payment authorization
     * @param id ID of the payment authorization to capture
     */
    paymentCapture(params: {  id: number; }, options: any = {}) {
        return PaymentsApiFp.paymentCapture(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing payment method for a user
     * @param userId ID of the user for whom the payment method is being updated
     * @param id ID of the payment method being updated
     * @param paymentMethod The updated payment method data
     */
    updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
        return PaymentsApiFp.updatePaymentMethod(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new payment method for a user
         * @param userId ID of the user for whom the payment method is being created
         * @param paymentMethod Payment method being created
         */
        createPaymentMethod(params: {  userId: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
            return PaymentsApiFp.createPaymentMethod(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being deleted
         */
        deletePaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
            return PaymentsApiFp.deletePaymentMethod(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single payment method for a user
         * @param userId ID of the user for whom the payment method is being retrieved
         * @param id ID of the payment method being retrieved
         */
        getPaymentMethod(params: {  userId: number; id: number; }, options: any = {}) {
            return PaymentsApiFp.getPaymentMethod(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all payment methods for a user
         * @param userId ID of the user for whom the payment methods are being retrieved
         * @param filterName Filter for payment methods whose name starts with a given string
         * @param filterPaymentType Filter for payment methods with a specific payment type
         * @param filterPaymentMethodTypeId Filter for payment methods with a specific payment method type by id
         * @param filterPaymentMethodTypeName Filter for payment methods whose payment method type name starts with a given string
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getPaymentMethods(params: {  userId: number; filterName?: string; filterPaymentType?: string; filterPaymentMethodTypeId?: number; filterPaymentMethodTypeName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return PaymentsApiFp.getPaymentMethods(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Authorize payment of an invoice for later capture
         * @param request Payment authorization request
         */
        paymentAuthorization(params: {  request?: PaymentAuthorizationResource; }, options: any = {}) {
            return PaymentsApiFp.paymentAuthorization(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Capture an existing invoice payment authorization
         * @param id ID of the payment authorization to capture
         */
        paymentCapture(params: {  id: number; }, options: any = {}) {
            return PaymentsApiFp.paymentCapture(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing payment method for a user
         * @param userId ID of the user for whom the payment method is being updated
         * @param id ID of the payment method being updated
         * @param paymentMethod The updated payment method data
         */
        updatePaymentMethod(params: {  userId: number; id: number; paymentMethod?: PaymentMethodResource; }, options: any = {}) {
            return PaymentsApiFp.updatePaymentMethod(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsAppleApi - fetch parameter creator
 */
export const PaymentsAppleApiFetchParamCreator = {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/apple/receipt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsAppleApi - functional programming interface
 */
export const PaymentsAppleApiFp = {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: { request?: ApplyPaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsAppleApiFetchParamCreator.verifyAppleReceipt(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsAppleApi - object-oriented interface
 */
export class PaymentsAppleApi extends BaseAPI {
    /**
     * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
     * @summary Pay invoice with Apple receipt
     * @param request The request for paying an invoice through an Apple receipt
     */
    verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, options: any = {}) {
        return PaymentsAppleApiFp.verifyAppleReceipt(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsAppleApi - factory interface
 */
export const PaymentsAppleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Mark an invoice paid using Apple payment receipt. A receipt will only be accepted once and the details of the transaction must match the invoice, including the product_id matching the sku text of the item in the invoice. Returns the transaction ID if successful.
         * @summary Pay invoice with Apple receipt
         * @param request The request for paying an invoice through an Apple receipt
         */
        verifyAppleReceipt(params: {  request?: ApplyPaymentRequest; }, options: any = {}) {
            return PaymentsAppleApiFp.verifyAppleReceipt(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsFattMerchantApi - fetch parameter creator
 */
export const PaymentsFattMerchantApiFetchParamCreator = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/fattmerchant/payment-methods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsFattMerchantApi - functional programming interface
 */
export const PaymentsFattMerchantApiFp = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: { request?: FattMerchantPaymentMethodRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsFattMerchantApiFetchParamCreator.createOrUpdateFattMerchantPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsFattMerchantApi - object-oriented interface
 */
export class PaymentsFattMerchantApi extends BaseAPI {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create or update a FattMerchant payment method for a user
     * @param request Request containing payment method information for user
     */
    createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, options: any = {}) {
        return PaymentsFattMerchantApiFp.createOrUpdateFattMerchantPaymentMethod(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsFattMerchantApi - factory interface
 */
export const PaymentsFattMerchantApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
         * @summary Create or update a FattMerchant payment method for a user
         * @param request Request containing payment method information for user
         */
        createOrUpdateFattMerchantPaymentMethod(params: {  request?: FattMerchantPaymentMethodRequest; }, options: any = {}) {
            return PaymentsFattMerchantApiFp.createOrUpdateFattMerchantPaymentMethod(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsGoogleApi - fetch parameter creator
 */
export const PaymentsGoogleApiFetchParamCreator = {
    /**
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @summary Mark an invoice paid with Google
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: {  request?: GooglePaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/google/payments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsGoogleApi - functional programming interface
 */
export const PaymentsGoogleApiFp = {
    /**
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @summary Mark an invoice paid with Google
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: { request?: GooglePaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = PaymentsGoogleApiFetchParamCreator.handleGooglePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsGoogleApi - object-oriented interface
 */
export class PaymentsGoogleApi extends BaseAPI {
    /**
     * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
     * @summary Mark an invoice paid with Google
     * @param request The request for paying an invoice through a Google in-app payment
     */
    handleGooglePayment(params: {  request?: GooglePaymentRequest; }, options: any = {}) {
        return PaymentsGoogleApiFp.handleGooglePayment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsGoogleApi - factory interface
 */
export const PaymentsGoogleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Mark an invoice paid with Google. Verifies signature from Google and treats the developerPayload field inside the json payload as the id of the invoice to pay. Returns the transaction ID if successful.
         * @summary Mark an invoice paid with Google
         * @param request The request for paying an invoice through a Google in-app payment
         */
        handleGooglePayment(params: {  request?: GooglePaymentRequest; }, options: any = {}) {
            return PaymentsGoogleApiFp.handleGooglePayment(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsOptimalApi - fetch parameter creator
 */
export const PaymentsOptimalApiFetchParamCreator = {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/optimal/silent`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsOptimalApi - functional programming interface
 */
export const PaymentsOptimalApiFp = {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: { request?: OptimalPaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsOptimalApiFetchParamCreator.silentPostOptimal(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsOptimalApi - object-oriented interface
 */
export class PaymentsOptimalApi extends BaseAPI {
    /**
     * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
     * @summary Initiate silent post with Optimal
     * @param request The payment request to initiate
     */
    silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, options: any = {}) {
        return PaymentsOptimalApiFp.silentPostOptimal(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsOptimalApi - factory interface
 */
export const PaymentsOptimalApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Will return the url for a hosted payment endpoint to post to. See Optimal documentation for details.
         * @summary Initiate silent post with Optimal
         * @param request The payment request to initiate
         */
        silentPostOptimal(params: {  request?: OptimalPaymentRequest; }, options: any = {}) {
            return PaymentsOptimalApiFp.silentPostOptimal(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsPayPalClassicApi - fetch parameter creator
 */
export const PaymentsPayPalClassicApiFetchParamCreator = {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/start`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/agreements/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/paypal/classic/checkout/finish`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsPayPalClassicApi - functional programming interface
 */
export const PaymentsPayPalClassicApiFp = {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: { request?: CreateBillingAgreementRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.createPayPalBillingAgreementUrl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: { request?: CreatePayPalPaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.createPayPalExpressCheckout(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: { request?: FinalizeBillingAgreementRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.finalizePayPalBillingAgreement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: { request?: FinalizePayPalPaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsPayPalClassicApiFetchParamCreator.finalizePayPalCheckout(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsPayPalClassicApi - object-oriented interface
 */
export class PaymentsPayPalClassicApi extends BaseAPI {
    /**
     * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
     * @summary Create a PayPal Classic billing agreement for the user
     * @param request The request to create a PayPal billing agreement
     */
    createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, options: any = {}) {
        return PaymentsPayPalClassicApiFp.createPayPalBillingAgreementUrl(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
     * @summary Create a payment token for PayPal express checkout
     * @param request The request to create a PayPal payment token
     */
    createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, options: any = {}) {
        return PaymentsPayPalClassicApiFp.createPayPalExpressCheckout(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns the ID of the new payment method created for the user for the billing agreement.
     * @summary Finalizes a billing agreement after the user has accepted through PayPal
     * @param request The request to finalize a PayPal billing agreement
     */
    finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, options: any = {}) {
        return PaymentsPayPalClassicApiFp.finalizePayPalBillingAgreement(params, options)(this.fetch, this.basePath);
    }
    /**
     * The invoice will be marked paid/failed by asynchronous IPN callback.
     * @summary Finalizes a payment after the user has completed checkout with PayPal
     * @param request The request to finalize the payment
     */
    finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, options: any = {}) {
        return PaymentsPayPalClassicApiFp.finalizePayPalCheckout(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsPayPalClassicApi - factory interface
 */
export const PaymentsPayPalClassicApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Returns the token that should be used to forward the user to PayPal so they can accept the agreement.
         * @summary Create a PayPal Classic billing agreement for the user
         * @param request The request to create a PayPal billing agreement
         */
        createPayPalBillingAgreementUrl(params: {  request?: CreateBillingAgreementRequest; }, options: any = {}) {
            return PaymentsPayPalClassicApiFp.createPayPalBillingAgreementUrl(params, options)(fetch, basePath);
        },
        /**
         * Returns the token that should be used to forward the user to PayPal so they can complete the checkout.
         * @summary Create a payment token for PayPal express checkout
         * @param request The request to create a PayPal payment token
         */
        createPayPalExpressCheckout(params: {  request?: CreatePayPalPaymentRequest; }, options: any = {}) {
            return PaymentsPayPalClassicApiFp.createPayPalExpressCheckout(params, options)(fetch, basePath);
        },
        /**
         * Returns the ID of the new payment method created for the user for the billing agreement.
         * @summary Finalizes a billing agreement after the user has accepted through PayPal
         * @param request The request to finalize a PayPal billing agreement
         */
        finalizePayPalBillingAgreement(params: {  request?: FinalizeBillingAgreementRequest; }, options: any = {}) {
            return PaymentsPayPalClassicApiFp.finalizePayPalBillingAgreement(params, options)(fetch, basePath);
        },
        /**
         * The invoice will be marked paid/failed by asynchronous IPN callback.
         * @summary Finalizes a payment after the user has completed checkout with PayPal
         * @param request The request to finalize the payment
         */
        finalizePayPalCheckout(params: {  request?: FinalizePayPalPaymentRequest; }, options: any = {}) {
            return PaymentsPayPalClassicApiFp.finalizePayPalCheckout(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsStripeApi - fetch parameter creator
 */
export const PaymentsStripeApiFetchParamCreator = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payment-methods`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  request?: StripePaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/stripe/payments`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsStripeApi - functional programming interface
 */
export const PaymentsStripeApiFp = {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: { request?: StripeCreatePaymentMethod;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PaymentMethodResource> {
        const fetchArgs = PaymentsStripeApiFetchParamCreator.createStripePaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: { request?: StripePaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsStripeApiFetchParamCreator.payStripeInvoice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsStripeApi - object-oriented interface
 */
export class PaymentsStripeApi extends BaseAPI {
    /**
     * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
     * @summary Create a Stripe payment method for a user
     * @param request The request to create a Stripe customer with payment info
     */
    createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, options: any = {}) {
        return PaymentsStripeApiFp.createStripePaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Pay with a single use token
     * @param request The request to pay an invoice
     */
    payStripeInvoice(params: {  request?: StripePaymentRequest; }, options: any = {}) {
        return PaymentsStripeApiFp.payStripeInvoice(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsStripeApi - factory interface
 */
export const PaymentsStripeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Stores customer information and creates a payment method that can be used to pay invoices through the payments endpoints.
         * @summary Create a Stripe payment method for a user
         * @param request The request to create a Stripe customer with payment info
         */
        createStripePaymentMethod(params: {  request?: StripeCreatePaymentMethod; }, options: any = {}) {
            return PaymentsStripeApiFp.createStripePaymentMethod(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Pay with a single use token
         * @param request The request to pay an invoice
         */
        payStripeInvoice(params: {  request?: StripePaymentRequest; }, options: any = {}) {
            return PaymentsStripeApiFp.payStripeInvoice(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsTransactionsApi - fetch parameter creator
 */
export const PaymentsTransactionsApiFetchParamCreator = {
    /**
     * 
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getTransaction");
        }
        const baseUrl = `/transactions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterInvoice"] !== undefined) {
            urlObj.query["filter_invoice"] = params["filterInvoice"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  id: number; request?: RefundRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling refundTransaction");
        }
        const baseUrl = `/transactions/{id}/refunds`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsTransactionsApi - functional programming interface
 */
export const PaymentsTransactionsApiFp = {
    /**
     * 
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TransactionResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.getTransaction(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: { filterInvoice?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTransactionResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.getTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: { id: number; request?: RefundRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RefundResource> {
        const fetchArgs = PaymentsTransactionsApiFetchParamCreator.refundTransaction(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsTransactionsApi - object-oriented interface
 */
export class PaymentsTransactionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the details for a single transaction
     * @param id id
     */
    getTransaction(params: {  id: number; }, options: any = {}) {
        return PaymentsTransactionsApiFp.getTransaction(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search transactions
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsTransactionsApiFp.getTransactions(params, options)(this.fetch, this.basePath);
    }
    /**
     * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
     * @summary Refund a payment transaction, in full or in part
     * @param id The id of the transaction to refund
     * @param request Request containing refund details
     */
    refundTransaction(params: {  id: number; request?: RefundRequest; }, options: any = {}) {
        return PaymentsTransactionsApiFp.refundTransaction(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsTransactionsApi - factory interface
 */
export const PaymentsTransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the details for a single transaction
         * @param id id
         */
        getTransaction(params: {  id: number; }, options: any = {}) {
            return PaymentsTransactionsApiFp.getTransaction(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search transactions
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getTransactions(params: {  filterInvoice?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return PaymentsTransactionsApiFp.getTransactions(params, options)(fetch, basePath);
        },
        /**
         * Will not allow for refunding more than the full amount even with multiple partial refunds. Money is refunded to the payment method used to make the original payment. Payment method must support refunds.
         * @summary Refund a payment transaction, in full or in part
         * @param id The id of the transaction to refund
         * @param request Request containing refund details
         */
        refundTransaction(params: {  id: number; request?: RefundRequest; }, options: any = {}) {
            return PaymentsTransactionsApiFp.refundTransaction(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsWalletsApi - fetch parameter creator
 */
export const PaymentsWalletsApiFetchParamCreator = {
    /**
     * 
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  userId: number; currencyCode: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallet");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWallet");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWalletTransactions");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getUserWalletTransactions");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/transactions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterMaxDate"] !== undefined) {
            urlObj.query["filter_max_date"] = params["filterMaxDate"];
        }
        if (params["filterMinDate"] !== undefined) {
            urlObj.query["filter_min_date"] = params["filterMinDate"];
        }
        if (params["filterSign"] !== undefined) {
            urlObj.query["filter_sign"] = params["filterSign"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserWallets");
        }
        const baseUrl = `/users/{user_id}/wallets`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options: any = {}): FetchArgs {
        const baseUrl = `/wallets/totals`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/wallets/transactions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterInvoice"] !== undefined) {
            urlObj.query["filter_invoice"] = params["filterInvoice"];
        }
        if (params["filterType"] !== undefined) {
            urlObj.query["filter_type"] = params["filterType"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        if (params["filterSign"] !== undefined) {
            urlObj.query["filter_sign"] = params["filterSign"];
        }
        if (params["filterUserId"] !== undefined) {
            urlObj.query["filter_user_id"] = params["filterUserId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterDetails"] !== undefined) {
            urlObj.query["filter_details"] = params["filterDetails"];
        }
        if (params["filterCurrencyCode"] !== undefined) {
            urlObj.query["filter_currency_code"] = params["filterCurrencyCode"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/wallets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateWalletBalance");
        }
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling updateWalletBalance");
        }
        const baseUrl = `/users/{user_id}/wallets/{currency_code}/balance`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsWalletsApi - functional programming interface
 */
export const PaymentsWalletsApiFp = {
    /**
     * 
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: { userId: number; currencyCode: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SimpleWallet> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWallet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: { userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWalletTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: { userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<SimpleWallet>> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getUserWallets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTotalResponse> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWalletBalances(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: { filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceWalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWalletTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleWallet> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.getWallets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: { userId: number; currencyCode: string; request?: WalletAlterRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<WalletTransactionResource> {
        const fetchArgs = PaymentsWalletsApiFetchParamCreator.updateWalletBalance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsWalletsApi - object-oriented interface
 */
export class PaymentsWalletsApi extends BaseAPI {
    /**
     * 
     * @summary Returns the user's wallet for the given currency code
     * @param userId The ID of the user for whom wallet is being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     */
    getUserWallet(params: {  userId: number; currencyCode: string; }, options: any = {}) {
        return PaymentsWalletsApiFp.getUserWallet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a user's wallet transactions
     * @param userId The ID of the user for whom wallet transactions are being retrieved
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param filterType Filter for transactions with specified type
     * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
     * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
     * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsWalletsApiFp.getUserWalletTransactions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List all of a user's wallets
     * @param userId The ID of the user for whom wallets are being retrieved
     */
    getUserWallets(params: {  userId: number; }, options: any = {}) {
        return PaymentsWalletsApiFp.getUserWallets(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieves a summation of wallet balances by currency code
     */
    getWalletBalances(options: any = {}) {
        return PaymentsWalletsApiFp.getWalletBalances(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve wallet transactions across the system
     * @param filterInvoice Filter for transactions from a specific invoice
     * @param filterType Filter for transactions with specified type
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     * @param filterSign Filter for transactions with amount with the given sign
     * @param filterUserId Filter for transactions for specific userId
     * @param filterUsername Filter for transactions for specific username that start with the given string
     * @param filterDetails Filter for transactions for specific details that start with the given string
     * @param filterCurrencyCode Filter for transactions for specific currency code
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsWalletsApiFp.getWalletTransactions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a list of wallets across the system
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getWallets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return PaymentsWalletsApiFp.getWallets(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates the balance for a user's wallet
     * @param userId The ID of the user for whom wallet is being modified
     * @param currencyCode Currency code of the user&#39;s wallet
     * @param request The requested balance modification to be made to the user&#39;s wallet
     */
    updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, options: any = {}) {
        return PaymentsWalletsApiFp.updateWalletBalance(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsWalletsApi - factory interface
 */
export const PaymentsWalletsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns the user's wallet for the given currency code
         * @param userId The ID of the user for whom wallet is being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         */
        getUserWallet(params: {  userId: number; currencyCode: string; }, options: any = {}) {
            return PaymentsWalletsApiFp.getUserWallet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a user's wallet transactions
         * @param userId The ID of the user for whom wallet transactions are being retrieved
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param filterType Filter for transactions with specified type
         * @param filterMaxDate Filter for transactions from no earlier than the specified date as a unix timestamp in seconds
         * @param filterMinDate Filter for transactions from no later than the specified date as a unix timestamp in seconds
         * @param filterSign Filter for transactions with amount with the given sign.  Allowable values: (&#39;positive&#39;, &#39;negative&#39;)
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserWalletTransactions(params: {  userId: number; currencyCode: string; filterType?: string; filterMaxDate?: number; filterMinDate?: number; filterSign?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return PaymentsWalletsApiFp.getUserWalletTransactions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List all of a user's wallets
         * @param userId The ID of the user for whom wallets are being retrieved
         */
        getUserWallets(params: {  userId: number; }, options: any = {}) {
            return PaymentsWalletsApiFp.getUserWallets(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieves a summation of wallet balances by currency code
         */
        getWalletBalances(options: any = {}) {
            return PaymentsWalletsApiFp.getWalletBalances(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve wallet transactions across the system
         * @param filterInvoice Filter for transactions from a specific invoice
         * @param filterType Filter for transactions with specified type
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         * @param filterSign Filter for transactions with amount with the given sign
         * @param filterUserId Filter for transactions for specific userId
         * @param filterUsername Filter for transactions for specific username that start with the given string
         * @param filterDetails Filter for transactions for specific details that start with the given string
         * @param filterCurrencyCode Filter for transactions for specific currency code
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWalletTransactions(params: {  filterInvoice?: number; filterType?: string; filterDate?: string; filterSign?: string; filterUserId?: number; filterUsername?: string; filterDetails?: string; filterCurrencyCode?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return PaymentsWalletsApiFp.getWalletTransactions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a list of wallets across the system
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getWallets(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return PaymentsWalletsApiFp.getWallets(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the balance for a user's wallet
         * @param userId The ID of the user for whom wallet is being modified
         * @param currencyCode Currency code of the user&#39;s wallet
         * @param request The requested balance modification to be made to the user&#39;s wallet
         */
        updateWalletBalance(params: {  userId: number; currencyCode: string; request?: WalletAlterRequest; }, options: any = {}) {
            return PaymentsWalletsApiFp.updateWalletBalance(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentsXsollaApi - fetch parameter creator
 */
export const PaymentsXsollaApiFetchParamCreator = {
    /**
     * 
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/xsolla/payment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["request"]) {
            fetchOptions.body = JSON.stringify(params["request"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     * @summary Receives payment response from Xsolla
     */
    receiveXsollaNotification(options: any = {}): FetchArgs {
        const baseUrl = `/payment/provider/xsolla/notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentsXsollaApi - functional programming interface
 */
export const PaymentsXsollaApiFp = {
    /**
     * 
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: { request?: XsollaPaymentRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = PaymentsXsollaApiFetchParamCreator.createXsollaTokenUrl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     * @summary Receives payment response from Xsolla
     */
    receiveXsollaNotification(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentsXsollaApiFetchParamCreator.receiveXsollaNotification(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentsXsollaApi - object-oriented interface
 */
export class PaymentsXsollaApi extends BaseAPI {
    /**
     * 
     * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
     * @param request The payment request to be sent to XSolla
     */
    createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, options: any = {}) {
        return PaymentsXsollaApiFp.createXsollaTokenUrl(params, options)(this.fetch, this.basePath);
    }
    /**
     * Only used by Xsolla to call back to JSAPI after processing user payment action
     * @summary Receives payment response from Xsolla
     */
    receiveXsollaNotification(options: any = {}) {
        return PaymentsXsollaApiFp.receiveXsollaNotification(options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentsXsollaApi - factory interface
 */
export const PaymentsXsollaApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a payment token that should be used to forward the user to Xsolla so they can complete payment
         * @param request The payment request to be sent to XSolla
         */
        createXsollaTokenUrl(params: {  request?: XsollaPaymentRequest; }, options: any = {}) {
            return PaymentsXsollaApiFp.createXsollaTokenUrl(params, options)(fetch, basePath);
        },
        /**
         * Only used by Xsolla to call back to JSAPI after processing user payment action
         * @summary Receives payment response from Xsolla
         */
        receiveXsollaNotification(options: any = {}) {
            return PaymentsXsollaApiFp.receiveXsollaNotification(options)(fetch, basePath);
        },
    };
};


/**
 * ReportingChallengesApi - fetch parameter creator
 */
export const ReportingChallengesApiFetchParamCreator = {
    /**
     * Lists all leaderboard entries with additional user details
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/events/leaderboard`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterEvent"] !== undefined) {
            urlObj.query["filter_event"] = params["filterEvent"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/events/participants`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterEvent"] !== undefined) {
            urlObj.query["filter_event"] = params["filterEvent"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingChallengesApi - functional programming interface
 */
export const ReportingChallengesApiFp = {
    /**
     * Lists all leaderboard entries with additional user details
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: { filterEvent?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = ReportingChallengesApiFetchParamCreator.getChallengeEventLeaderboard(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: { filterEvent?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceChallengeEventParticipantResource> {
        const fetchArgs = ReportingChallengesApiFetchParamCreator.getChallengeEventParticipants(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingChallengesApi - object-oriented interface
 */
export class ReportingChallengesApi extends BaseAPI {
    /**
     * Lists all leaderboard entries with additional user details
     * @summary Retrieve a challenge event leaderboard details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ReportingChallengesApiFp.getChallengeEventLeaderboard(params, options)(this.fetch, this.basePath);
    }
    /**
     * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
     * @summary Retrieve a challenge event participant details
     * @param filterEvent A sepecific challenge event id
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return ReportingChallengesApiFp.getChallengeEventParticipants(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingChallengesApi - factory interface
 */
export const ReportingChallengesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Lists all leaderboard entries with additional user details
         * @summary Retrieve a challenge event leaderboard details
         * @param filterEvent A sepecific challenge event id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEventLeaderboard(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ReportingChallengesApiFp.getChallengeEventLeaderboard(params, options)(fetch, basePath);
        },
        /**
         * Lists all user submitted scores sorted by value, including those that do not apear in the leaderboard due to value or aggregation
         * @summary Retrieve a challenge event participant details
         * @param filterEvent A sepecific challenge event id
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getChallengeEventParticipants(params: {  filterEvent?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return ReportingChallengesApiFp.getChallengeEventParticipants(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingOrdersApi - fetch parameter creator
 */
export const ReportingOrdersApiFetchParamCreator = {
    /**
     * 
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getInvoiceReports");
        }
        const baseUrl = `/reporting/orders/count/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["granularity"] !== undefined) {
            urlObj.query["granularity"] = params["granularity"];
        }
        if (params["filterPaymentStatus"] !== undefined) {
            urlObj.query["filter_payment_status"] = params["filterPaymentStatus"];
        }
        if (params["filterFulfillmentStatus"] !== undefined) {
            urlObj.query["filter_fulfillment_status"] = params["filterFulfillmentStatus"];
        }
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingOrdersApi - functional programming interface
 */
export const ReportingOrdersApiFp = {
    /**
     * 
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: { currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAggregateInvoiceReportResource> {
        const fetchArgs = ReportingOrdersApiFetchParamCreator.getInvoiceReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingOrdersApi - object-oriented interface
 */
export class ReportingOrdersApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve invoice counts aggregated by time ranges
     * @param currencyCode The code for a currency to get sales data for
     * @param granularity The time duration to aggregate by
     * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
     * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
     * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     */
    getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return ReportingOrdersApiFp.getInvoiceReports(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingOrdersApi - factory interface
 */
export const ReportingOrdersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Retrieve invoice counts aggregated by time ranges
         * @param currencyCode The code for a currency to get sales data for
         * @param granularity The time duration to aggregate by
         * @param filterPaymentStatus A payment status to filter results by, can be a comma separated list
         * @param filterFulfillmentStatus An invoice fulfillment status to filter results by, can be a comma separated list
         * @param startDate The start of the time range to return, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to return, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         */
        getInvoiceReports(params: {  currencyCode: string; granularity?: string; filterPaymentStatus?: string; filterFulfillmentStatus?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
            return ReportingOrdersApiFp.getInvoiceReports(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingRevenueApi - fetch parameter creator
 */
export const ReportingRevenueApiFetchParamCreator = {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getItemRevenue");
        }
        const baseUrl = `/reporting/revenue/item-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRefundRevenue");
        }
        const baseUrl = `/reporting/revenue/refunds/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByCountry");
        }
        const baseUrl = `/reporting/revenue/countries/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getRevenueByItem");
        }
        const baseUrl = `/reporting/revenue/products/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "currencyCode" is set
        if (params["currencyCode"] == null) {
            throw new Error("Missing required parameter currencyCode when calling getSubscriptionRevenue");
        }
        const baseUrl = `/reporting/revenue/subscription-sales/{currency_code}`
            .replace(`{${"currency_code"}}`, `${ params["currencyCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingRevenueApi - functional programming interface
 */
export const ReportingRevenueApiFp = {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getItemRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRefundRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: { currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRevenueCountryReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRevenueByCountry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: { currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceRevenueProductReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getRevenueByItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: { currencyCode: string; startDate?: number; endDate?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<RevenueReportResource> {
        const fetchArgs = ReportingRevenueApiFetchParamCreator.getSubscriptionRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingRevenueApi - object-oriented interface
 */
export class ReportingRevenueApi extends BaseAPI {
    /**
     * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
     * @summary Get item revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return ReportingRevenueApiFp.getItemRevenue(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
     * @summary Get refund revenue info
     * @param currencyCode The code for a currency to get refund data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return ReportingRevenueApiFp.getRefundRevenue(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
     * @summary Get revenue info by country
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return ReportingRevenueApiFp.getRevenueByCountry(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
     * @summary Get revenue info by item
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return ReportingRevenueApiFp.getRevenueByItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
     * @summary Get subscription revenue info
     * @param currencyCode The code for a currency to get sales data for
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     */
    getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
        return ReportingRevenueApiFp.getSubscriptionRevenue(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingRevenueApi - factory interface
 */
export const ReportingRevenueApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get basic info about revenue from sales of items and bundles (not subscriptions, shipping, etc), summed up within a time range
         * @summary Get item revenue info
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getItemRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
            return ReportingRevenueApiFp.getItemRevenue(params, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue loss from refunds (for all item types), summed up within a time range.
         * @summary Get refund revenue info
         * @param currencyCode The code for a currency to get refund data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getRefundRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
            return ReportingRevenueApiFp.getRefundRevenue(params, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by country. Sorted for largest revenue at the top
         * @summary Get revenue info by country
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByCountry(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
            return ReportingRevenueApiFp.getRevenueByCountry(params, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of all types, summed up within a time range and split out by specific item. Sorted for largest revenue at the top
         * @summary Get revenue info by item
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getRevenueByItem(params: {  currencyCode: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
            return ReportingRevenueApiFp.getRevenueByItem(params, options)(fetch, basePath);
        },
        /**
         * Get basic info about revenue from sales of new subscriptions as well as recurring payemnts, summed up within a time range
         * @summary Get subscription revenue info
         * @param currencyCode The code for a currency to get sales data for
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         */
        getSubscriptionRevenue(params: {  currencyCode: string; startDate?: number; endDate?: number; }, options: any = {}) {
            return ReportingRevenueApiFp.getSubscriptionRevenue(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingSubscriptionsApi - fetch parameter creator
 */
export const ReportingSubscriptionsApiFetchParamCreator = {
    /**
     * 
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/subscription`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingSubscriptionsApi - functional programming interface
 */
export const ReportingSubscriptionsApiFp = {
    /**
     * 
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: { size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceBillingReport> {
        const fetchArgs = ReportingSubscriptionsApiFetchParamCreator.getSubscriptionReports(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingSubscriptionsApi - object-oriented interface
 */
export class ReportingSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of available subscription reports in most recent first order
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getSubscriptionReports(params: {  size?: number; page?: number; }, options: any = {}) {
        return ReportingSubscriptionsApiFp.getSubscriptionReports(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingSubscriptionsApi - factory interface
 */
export const ReportingSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get a list of available subscription reports in most recent first order
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getSubscriptionReports(params: {  size?: number; page?: number; }, options: any = {}) {
            return ReportingSubscriptionsApiFp.getSubscriptionReports(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingUsageApi - fetch parameter creator
 */
export const ReportingUsageApiFetchParamCreator = {
    /**
     * 
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByDay");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByDay");
        }
        const baseUrl = `/reporting/usage/day`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByHour");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByHour");
        }
        const baseUrl = `/reporting/usage/hour`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMinute");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMinute");
        }
        const baseUrl = `/reporting/usage/minute`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByMonth");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByMonth");
        }
        const baseUrl = `/reporting/usage/month`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageByYear");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageByYear");
        }
        const baseUrl = `/reporting/usage/year`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["combineEndpoints"] !== undefined) {
            urlObj.query["combine_endpoints"] = params["combineEndpoints"];
        }
        if (params["method"] !== undefined) {
            urlObj.query["method"] = params["method"];
        }
        if (params["url"] !== undefined) {
            urlObj.query["url"] = params["url"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: {  startDate: number; endDate: number; }, options: any = {}): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling getUsageEndpoints");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling getUsageEndpoints");
        }
        const baseUrl = `/reporting/usage/endpoints`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingUsageApi - functional programming interface
 */
export const ReportingUsageApiFp = {
    /**
     * 
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByDay(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByHour(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByMinute(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByMonth(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: { startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUsageInfo> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageByYear(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: { startDate: number; endDate: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = ReportingUsageApiFetchParamCreator.getUsageEndpoints(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingUsageApi - object-oriented interface
 */
export class ReportingUsageApi extends BaseAPI {
    /**
     * 
     * @summary Returns aggregated endpoint usage information by day
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageByDay(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by hour
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageByHour(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by minute
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageByMinute(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by month
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageByMonth(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns aggregated endpoint usage information by year
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
     * @param method Filter for a certain endpoint method.  Must include url as well to work
     * @param url Filter for a certain endpoint.  Must include method as well to work
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageByYear(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns list of endpoints called (method and url)
     * @param startDate The beginning of the range being requested, unix timestamp in seconds
     * @param endDate The ending of the range being requested, unix timestamp in seconds
     */
    getUsageEndpoints(params: {  startDate: number; endDate: number; }, options: any = {}) {
        return ReportingUsageApiFp.getUsageEndpoints(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingUsageApi - factory interface
 */
export const ReportingUsageApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns aggregated endpoint usage information by day
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByDay(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageByDay(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns aggregated endpoint usage information by hour
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByHour(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageByHour(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns aggregated endpoint usage information by minute
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMinute(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageByMinute(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns aggregated endpoint usage information by month
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoint. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByMonth(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageByMonth(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns aggregated endpoint usage information by year
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         * @param combineEndpoints Whether to combine counts from different endpoints. Removes the url and method from the result object
         * @param method Filter for a certain endpoint method.  Must include url as well to work
         * @param url Filter for a certain endpoint.  Must include method as well to work
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUsageByYear(params: {  startDate: number; endDate: number; combineEndpoints?: boolean; method?: string; url?: string; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageByYear(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns list of endpoints called (method and url)
         * @param startDate The beginning of the range being requested, unix timestamp in seconds
         * @param endDate The ending of the range being requested, unix timestamp in seconds
         */
        getUsageEndpoints(params: {  startDate: number; endDate: number; }, options: any = {}) {
            return ReportingUsageApiFp.getUsageEndpoints(params, options)(fetch, basePath);
        },
    };
};


/**
 * ReportingUsersApi - fetch parameter creator
 */
export const ReportingUsersApiFetchParamCreator = {
    /**
     * Get user registration counts grouped by time range
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        const baseUrl = `/reporting/users/registrations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["granularity"] !== undefined) {
            urlObj.query["granularity"] = params["granularity"];
        }
        if (params["startDate"] !== undefined) {
            urlObj.query["start_date"] = params["startDate"];
        }
        if (params["endDate"] !== undefined) {
            urlObj.query["end_date"] = params["endDate"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ReportingUsersApi - functional programming interface
 */
export const ReportingUsersApiFp = {
    /**
     * Get user registration counts grouped by time range
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: { granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceAggregateCountResource> {
        const fetchArgs = ReportingUsersApiFetchParamCreator.getUserRegistrations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ReportingUsersApi - object-oriented interface
 */
export class ReportingUsersApi extends BaseAPI {
    /**
     * Get user registration counts grouped by time range
     * @summary Get user registration info
     * @param granularity The time duration to aggregate by
     * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
     * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
        return ReportingUsersApiFp.getUserRegistrations(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ReportingUsersApi - factory interface
 */
export const ReportingUsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get user registration counts grouped by time range
         * @summary Get user registration info
         * @param granularity The time duration to aggregate by
         * @param startDate The start of the time range to aggregate, unix timestamp in seconds. Default is beginning of time
         * @param endDate The end of the time range to aggregate, unix timestamp in seconds. Default is end of time
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserRegistrations(params: {  granularity?: string; startDate?: number; endDate?: number; size?: number; page?: number; }, options: any = {}) {
            return ReportingUsersApiFp.getUserRegistrations(params, options)(fetch, basePath);
        },
    };
};


/**
 * SearchApi - fetch parameter creator
 */
export const SearchApiFetchParamCreator = {
    /**
     * Mainly intended for internal use.
     * @summary Add a new object to an index
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: {  type: string; id: string; object?: any; }, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling addSearchIndex");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addSearchIndex");
        }
        const baseUrl = `/search/index/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["object"]) {
            fetchOptions.body = JSON.stringify(params["object"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @summary Register reference mappings
     * @param mappings The mappings to add
     */
    addSearchMappings(params: {  mappings?: Array<SearchReferenceMapping>; }, options: any = {}): FetchArgs {
        const baseUrl = `/search/mappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["mappings"]) {
            fetchOptions.body = JSON.stringify(params["mappings"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @summary Delete an object
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: {  type: string; id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling deleteSearchIndex");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSearchIndex");
        }
        const baseUrl = `/search/index/{type}/{id}`
            .replace(`{${"type"}}`, `${ params["type"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Mainly intended for internal use
     * @summary Delete all objects in an index
     * @param type The index type
     */
    deleteSearchIndexes(params: {  type: string; }, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling deleteSearchIndexes");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The body is an ElasticSearch query in JSON format. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html'>documentation</a> for details on the format and search options. The searchable object's format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @summary Search an index
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: {  type: string; query?: any; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling searchIndex");
        }
        const baseUrl = `/search/index/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["query"]) {
            fetchOptions.body = JSON.stringify(params["query"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SearchApi - functional programming interface
 */
export const SearchApiFp = {
    /**
     * Mainly intended for internal use.
     * @summary Add a new object to an index
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: { type: string; id: string; object?: any;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.addSearchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @summary Register reference mappings
     * @param mappings The mappings to add
     */
    addSearchMappings(params: { mappings?: Array<SearchReferenceMapping>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.addSearchMappings(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @summary Delete an object
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: { type: string; id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.deleteSearchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Mainly intended for internal use
     * @summary Delete all objects in an index
     * @param type The index type
     */
    deleteSearchIndexes(params: { type: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SearchApiFetchParamCreator.deleteSearchIndexes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The body is an ElasticSearch query in JSON format. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html'>documentation</a> for details on the format and search options. The searchable object's format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @summary Search an index
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: { type: string; query?: any; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceMapstringobject> {
        const fetchArgs = SearchApiFetchParamCreator.searchIndex(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SearchApi - object-oriented interface
 */
export class SearchApi extends BaseAPI {
    /**
     * Mainly intended for internal use.
     * @summary Add a new object to an index
     * @param type The index type
     * @param id The ID of the object
     * @param object The object to add
     */
    addSearchIndex(params: {  type: string; id: string; object?: any; }, options: any = {}) {
        return SearchApiFp.addSearchIndex(params, options)(this.fetch, this.basePath);
    }
    /**
     * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
     * @summary Register reference mappings
     * @param mappings The mappings to add
     */
    addSearchMappings(params: {  mappings?: Array<SearchReferenceMapping>; }, options: any = {}) {
        return SearchApiFp.addSearchMappings(params, options)(this.fetch, this.basePath);
    }
    /**
     * Mainly intended for internal use. Requires SEARCH_ADMIN.
     * @summary Delete an object
     * @param type The index type
     * @param id The ID of the object to delete
     */
    deleteSearchIndex(params: {  type: string; id: string; }, options: any = {}) {
        return SearchApiFp.deleteSearchIndex(params, options)(this.fetch, this.basePath);
    }
    /**
     * Mainly intended for internal use
     * @summary Delete all objects in an index
     * @param type The index type
     */
    deleteSearchIndexes(params: {  type: string; }, options: any = {}) {
        return SearchApiFp.deleteSearchIndexes(params, options)(this.fetch, this.basePath);
    }
    /**
     * The body is an ElasticSearch query in JSON format. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html'>documentation</a> for details on the format and search options. The searchable object's format depends on on the type. See individual search endpoints on other resources for details on their format.
     * @summary Search an index
     * @param type The index type
     * @param query The query to be used for the search
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    searchIndex(params: {  type: string; query?: any; size?: number; page?: number; }, options: any = {}) {
        return SearchApiFp.searchIndex(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SearchApi - factory interface
 */
export const SearchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Mainly intended for internal use.
         * @summary Add a new object to an index
         * @param type The index type
         * @param id The ID of the object
         * @param object The object to add
         */
        addSearchIndex(params: {  type: string; id: string; object?: any; }, options: any = {}) {
            return SearchApiFp.addSearchIndex(params, options)(fetch, basePath);
        },
        /**
         * Add a new type mapping to connect data from one index to another, or discover an exsting one. Mainly intended for internal use.
         * @summary Register reference mappings
         * @param mappings The mappings to add
         */
        addSearchMappings(params: {  mappings?: Array<SearchReferenceMapping>; }, options: any = {}) {
            return SearchApiFp.addSearchMappings(params, options)(fetch, basePath);
        },
        /**
         * Mainly intended for internal use. Requires SEARCH_ADMIN.
         * @summary Delete an object
         * @param type The index type
         * @param id The ID of the object to delete
         */
        deleteSearchIndex(params: {  type: string; id: string; }, options: any = {}) {
            return SearchApiFp.deleteSearchIndex(params, options)(fetch, basePath);
        },
        /**
         * Mainly intended for internal use
         * @summary Delete all objects in an index
         * @param type The index type
         */
        deleteSearchIndexes(params: {  type: string; }, options: any = {}) {
            return SearchApiFp.deleteSearchIndexes(params, options)(fetch, basePath);
        },
        /**
         * The body is an ElasticSearch query in JSON format. Please see their <a href='https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html'>documentation</a> for details on the format and search options. The searchable object's format depends on on the type. See individual search endpoints on other resources for details on their format.
         * @summary Search an index
         * @param type The index type
         * @param query The query to be used for the search
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        searchIndex(params: {  type: string; query?: any; size?: number; page?: number; }, options: any = {}) {
            return SearchApiFp.searchIndex(params, options)(fetch, basePath);
        },
    };
};


/**
 * SocialFacebookApi - fetch parameter creator
 */
export const SocialFacebookApiFetchParamCreator = {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired.
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: {  facebookToken?: FacebookToken; }, options: any = {}): FetchArgs {
        const baseUrl = `/social/facebook/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["facebookToken"]) {
            fetchOptions.body = JSON.stringify(params["facebookToken"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SocialFacebookApi - functional programming interface
 */
export const SocialFacebookApiFp = {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired.
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: { facebookToken?: FacebookToken;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SocialFacebookApiFetchParamCreator.linkAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SocialFacebookApi - object-oriented interface
 */
export class SocialFacebookApi extends BaseAPI {
    /**
     * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired.
     * @summary Link facebook account
     * @param facebookToken The token from facebook
     */
    linkAccounts(params: {  facebookToken?: FacebookToken; }, options: any = {}) {
        return SocialFacebookApiFp.linkAccounts(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SocialFacebookApi - factory interface
 */
export const SocialFacebookApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Links the current user account to a facebook account, using the acccess token from facebook. Can also be used to update the access token after it has expired.
         * @summary Link facebook account
         * @param facebookToken The token from facebook
         */
        linkAccounts(params: {  facebookToken?: FacebookToken; }, options: any = {}) {
            return SocialFacebookApiFp.linkAccounts(params, options)(fetch, basePath);
        },
    };
};


/**
 * SocialGoogleApi - fetch parameter creator
 */
export const SocialGoogleApiFetchParamCreator = {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired.
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: {  googleToken?: GoogleToken; }, options: any = {}): FetchArgs {
        const baseUrl = `/social/google/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["googleToken"]) {
            fetchOptions.body = JSON.stringify(params["googleToken"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SocialGoogleApi - functional programming interface
 */
export const SocialGoogleApiFp = {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired.
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: { googleToken?: GoogleToken;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SocialGoogleApiFetchParamCreator.linkAccounts1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SocialGoogleApi - object-oriented interface
 */
export class SocialGoogleApi extends BaseAPI {
    /**
     * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired.
     * @summary Link google account
     * @param googleToken The token from google
     */
    linkAccounts1(params: {  googleToken?: GoogleToken; }, options: any = {}) {
        return SocialGoogleApiFp.linkAccounts1(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SocialGoogleApi - factory interface
 */
export const SocialGoogleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Links the current user account to a google account, using the acccess token from google. Can also be used to update the access token after it has expired.
         * @summary Link google account
         * @param googleToken The token from google
         */
        linkAccounts1(params: {  googleToken?: GoogleToken; }, options: any = {}) {
            return SocialGoogleApiFp.linkAccounts1(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreApi - fetch parameter creator
 */
export const StoreApiFetchParamCreator = {
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List available item behaviors
     */
    getBehaviors(options: any = {}): FetchArgs {
        const baseUrl = `/store/items/behaviors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/items/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @summary Get a listing of store items
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: {  limit?: number; page?: number; useCatalog?: boolean; ignoreLocation?: boolean; inStockOnly?: boolean; }, options: any = {}): FetchArgs {
        const baseUrl = `/store`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["limit"] !== undefined) {
            urlObj.query["limit"] = params["limit"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["useCatalog"] !== undefined) {
            urlObj.query["use_catalog"] = params["useCatalog"];
        }
        if (params["ignoreLocation"] !== undefined) {
            urlObj.query["ignore_location"] = params["ignoreLocation"];
        }
        if (params["inStockOnly"] !== undefined) {
            urlObj.query["in_stock_only"] = params["inStockOnly"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/items`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterNameSearch"] !== undefined) {
            urlObj.query["filter_name_search"] = params["filterNameSearch"];
        }
        if (params["filterUniqueKey"] !== undefined) {
            urlObj.query["filter_unique_key"] = params["filterUniqueKey"];
        }
        if (params["filterPublished"] !== undefined) {
            urlObj.query["filter_published"] = params["filterPublished"];
        }
        if (params["filterDisplayable"] !== undefined) {
            urlObj.query["filter_displayable"] = params["filterDisplayable"];
        }
        if (params["filterStart"] !== undefined) {
            urlObj.query["filter_start"] = params["filterStart"];
        }
        if (params["filterEnd"] !== undefined) {
            urlObj.query["filter_end"] = params["filterEnd"];
        }
        if (params["filterStartDate"] !== undefined) {
            urlObj.query["filter_start_date"] = params["filterStartDate"];
        }
        if (params["filterStopDate"] !== undefined) {
            urlObj.query["filter_stop_date"] = params["filterStopDate"];
        }
        if (params["filterSku"] !== undefined) {
            urlObj.query["filter_sku"] = params["filterSku"];
        }
        if (params["filterPrice"] !== undefined) {
            urlObj.query["filter_price"] = params["filterPrice"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterItemsByType"] !== undefined) {
            urlObj.query["filter_items_by_type"] = params["filterItemsByType"];
        }
        if (params["filterBundledSkus"] !== undefined) {
            urlObj.query["filter_bundled_skus"] = params["filterBundledSkus"];
        }
        if (params["filterVendor"] !== undefined) {
            urlObj.query["filter_vendor"] = params["filterVendor"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/quick-buy`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["quickBuyRequest"]) {
            fetchOptions.body = JSON.stringify(params["quickBuyRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemTemplate");
        }
        const baseUrl = `/store/items/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["itemTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateStoreItem");
        }
        const baseUrl = `/store/items/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["storeItem"]) {
            fetchOptions.body = JSON.stringify(params["storeItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreApi - functional programming interface
 */
export const StoreApiFp = {
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: { itemTemplateResource?: StoreItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.createItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: { cascade?: boolean; storeItem?: StoreItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.createStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List available item behaviors
     */
    getBehaviors(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BehaviorDefinitionResource>> {
        const fetchArgs = StoreApiFetchParamCreator.getBehaviors(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.getItemTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @summary Get a listing of store items
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: { limit?: number; page?: number; useCatalog?: boolean; ignoreLocation?: boolean; inStockOnly?: boolean;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStore(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: { filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.getStoreItems(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: { quickBuyRequest?: QuickBuyRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = StoreApiFetchParamCreator.quickBuy(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: { id: string; itemTemplateResource?: StoreItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItemTemplateResource> {
        const fetchArgs = StoreApiFetchParamCreator.updateItemTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: { id: number; cascade?: boolean; storeItem?: StoreItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StoreItem> {
        const fetchArgs = StoreApiFetchParamCreator.updateStoreItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreApi - object-oriented interface
 */
export class StoreApi extends BaseAPI {
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Create an item template
     * @param itemTemplateResource The new item template
     */
    createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
        return StoreApiFp.createItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
     * @summary Create a store item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
        return StoreApiFp.createStoreItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an item template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteItemTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreApiFp.deleteItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a store item
     * @param id The id of the item
     */
    deleteStoreItem(params: {  id: number; }, options: any = {}) {
        return StoreApiFp.deleteStoreItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List available item behaviors
     */
    getBehaviors(options: any = {}) {
        return StoreApiFp.getBehaviors(options)(this.fetch, this.basePath);
    }
    /**
     * Item Templates define a type of item and the properties they have.
     * @summary Get a single item template
     * @param id The id of the template
     */
    getItemTemplate(params: {  id: string; }, options: any = {}) {
        return StoreApiFp.getItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search item templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getItemTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreApiFp.getItemTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
     * @summary Get a listing of store items
     * @param limit The amount of items returned
     * @param page The page of the request
     * @param useCatalog Whether to remove items that are not intended for display or not in date
     * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
     * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
     */
    getStore(params: {  limit?: number; page?: number; useCatalog?: boolean; ignoreLocation?: boolean; inStockOnly?: boolean; }, options: any = {}) {
        return StoreApiFp.getStore(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single store item
     * @param id The id of the item
     */
    getStoreItem(params: {  id: number; }, options: any = {}) {
        return StoreApiFp.getStoreItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search store items
     * @param filterNameSearch Filter for items whose name starts with a given string.
     * @param filterUniqueKey Filter for items whose unique_key is a given string.
     * @param filterPublished Filter for skus that have been published.
     * @param filterDisplayable Filter for items that are displayable.
     * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterSku Filter for skus whose name starts with a given string.
     * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
     * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
     * @param filterItemsByType Filter for item type based on its type hint.
     * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
     * @param filterVendor Filter for items from a given vendor, by id.
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreApiFp.getStoreItems(params, options)(this.fetch, this.basePath);
    }
    /**
     * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
     * @summary One-step purchase and pay for a single SKU item from a user's wallet
     * @param quickBuyRequest Quick buy details
     */
    quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, options: any = {}) {
        return StoreApiFp.quickBuy(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an item template
     * @param id The id of the template
     * @param itemTemplateResource The item template resource object
     */
    updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
        return StoreApiFp.updateItemTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a store item
     * @param id The id of the item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param storeItem The store item object
     */
    updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
        return StoreApiFp.updateStoreItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreApi - factory interface
 */
export const StoreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Item Templates define a type of item and the properties they have.
         * @summary Create an item template
         * @param itemTemplateResource The new item template
         */
        createItemTemplate(params: {  itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
            return StoreApiFp.createItemTemplate(params, options)(fetch, basePath);
        },
        /**
         * SKUs have to be unique in the entire store. If a duplicate SKU is found, a 400 error is generated and the response will have a \"parameters\" field that is a list of duplicates. A duplicate is an object like {item_id, offending_sku_list}. Ex:<br /> {..., parameters: [[{item: 1, skus: [\"SKU-1\"]}]]}<br /> If an item is brand new and has duplicate SKUs within itself, the item ID will be 0.  Item subclasses are not allowed here, you will have to use their respective endpoints.
         * @summary Create a store item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param storeItem The store item object
         */
        createStoreItem(params: {  cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
            return StoreApiFp.createStoreItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an item template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteItemTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreApiFp.deleteItemTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a store item
         * @param id The id of the item
         */
        deleteStoreItem(params: {  id: number; }, options: any = {}) {
            return StoreApiFp.deleteStoreItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available item behaviors
         */
        getBehaviors(options: any = {}) {
            return StoreApiFp.getBehaviors(options)(fetch, basePath);
        },
        /**
         * Item Templates define a type of item and the properties they have.
         * @summary Get a single item template
         * @param id The id of the template
         */
        getItemTemplate(params: {  id: string; }, options: any = {}) {
            return StoreApiFp.getItemTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search item templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getItemTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreApiFp.getItemTemplates(params, options)(fetch, basePath);
        },
        /**
         * The exact structure of each items may differ to include fields specific to the type. The same is true for behaviors.
         * @summary Get a listing of store items
         * @param limit The amount of items returned
         * @param page The page of the request
         * @param useCatalog Whether to remove items that are not intended for display or not in date
         * @param ignoreLocation Whether to ignore country restrictions based on the caller&#39;s location
         * @param inStockOnly Whether only in-stock items should be returned.  Default value is false
         */
        getStore(params: {  limit?: number; page?: number; useCatalog?: boolean; ignoreLocation?: boolean; inStockOnly?: boolean; }, options: any = {}) {
            return StoreApiFp.getStore(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single store item
         * @param id The id of the item
         */
        getStoreItem(params: {  id: number; }, options: any = {}) {
            return StoreApiFp.getStoreItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search store items
         * @param filterNameSearch Filter for items whose name starts with a given string.
         * @param filterUniqueKey Filter for items whose unique_key is a given string.
         * @param filterPublished Filter for skus that have been published.
         * @param filterDisplayable Filter for items that are displayable.
         * @param filterStart A comma separated string without spaces.  First value is the operator to search on, second value is the store start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterEnd A comma separated string without spaces.  First value is the operator to search on, second value is the store end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStartDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku start date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterStopDate A comma separated string without spaces.  First value is the operator to search on, second value is the sku end date, a unix timestamp in seconds.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterSku Filter for skus whose name starts with a given string.
         * @param filterPrice A colon separated string without spaces.  First value is the operator to search on, second value is the price of a sku.  Allowed operators: (LT, GT, LTE, GTE, EQ).
         * @param filterTag A comma separated list without spaces of the names of tags. Will only return items with at least one of the tags.
         * @param filterItemsByType Filter for item type based on its type hint.
         * @param filterBundledSkus Filter for skus inside bundles whose name starts with a given string.  Used only when type hint is &#39;bundle_item&#39;
         * @param filterVendor Filter for items from a given vendor, by id.
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStoreItems(params: {  filterNameSearch?: string; filterUniqueKey?: string; filterPublished?: boolean; filterDisplayable?: boolean; filterStart?: string; filterEnd?: string; filterStartDate?: string; filterStopDate?: string; filterSku?: string; filterPrice?: string; filterTag?: string; filterItemsByType?: string; filterBundledSkus?: string; filterVendor?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreApiFp.getStoreItems(params, options)(fetch, basePath);
        },
        /**
         * Used to create and automatically pay an invoice for a single unit of a single SKU from a user's wallet. SKU must be priced in virtual currency and must not be an item that requires shipping. PAYMENTS_ADMIN permission is required if user ID is specified and is not the ID of the currently logged in user. If invoice price does not match expected price, purchase is aborted
         * @summary One-step purchase and pay for a single SKU item from a user's wallet
         * @param quickBuyRequest Quick buy details
         */
        quickBuy(params: {  quickBuyRequest?: QuickBuyRequest; }, options: any = {}) {
            return StoreApiFp.quickBuy(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an item template
         * @param id The id of the template
         * @param itemTemplateResource The item template resource object
         */
        updateItemTemplate(params: {  id: string; itemTemplateResource?: StoreItemTemplateResource; }, options: any = {}) {
            return StoreApiFp.updateItemTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a store item
         * @param id The id of the item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param storeItem The store item object
         */
        updateStoreItem(params: {  id: number; cascade?: boolean; storeItem?: StoreItem; }, options: any = {}) {
            return StoreApiFp.updateStoreItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreBundlesApi - fetch parameter creator
 */
export const StoreBundlesApiFetchParamCreator = {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/bundles/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleItem");
        }
        const baseUrl = `/store/bundles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleItem"]) {
            fetchOptions.body = JSON.stringify(params["bundleItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateBundleTemplate");
        }
        const baseUrl = `/store/bundles/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["bundleTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["bundleTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreBundlesApi - functional programming interface
 */
export const StoreBundlesApiFp = {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: { cascade?: boolean; bundleItem?: BundleItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.createBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: { bundleTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.createBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.deleteBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.deleteBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.getBundleTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: { id: number; cascade?: boolean; bundleItem?: BundleItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BundleItem> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.updateBundleItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: { id: string; bundleTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreBundlesApiFetchParamCreator.updateBundleTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreBundlesApi - object-oriented interface
 */
export class StoreBundlesApi extends BaseAPI {
    /**
     * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
     * @summary Create a bundle item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
        return StoreBundlesApiFp.createBundleItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Create a bundle template
     * @param bundleTemplateResource The new bundle template
     */
    createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreBundlesApiFp.createBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a bundle item
     * @param id The id of the bundle
     */
    deleteBundleItem(params: {  id: number; }, options: any = {}) {
        return StoreBundlesApiFp.deleteBundleItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a bundle template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteBundleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreBundlesApiFp.deleteBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single bundle item
     * @param id The id of the bundle
     */
    getBundleItem(params: {  id: number; }, options: any = {}) {
        return StoreBundlesApiFp.getBundleItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Bundle Templates define a type of bundle and the properties they have.
     * @summary Get a single bundle template
     * @param id The id of the template
     */
    getBundleTemplate(params: {  id: string; }, options: any = {}) {
        return StoreBundlesApiFp.getBundleTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search bundle templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreBundlesApiFp.getBundleTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a bundle item
     * @param id The id of the bundle
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param bundleItem The bundle item object
     */
    updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
        return StoreBundlesApiFp.updateBundleItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a bundle template
     * @param id The id of the template
     * @param bundleTemplateResource The bundle template resource object
     */
    updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreBundlesApiFp.updateBundleTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreBundlesApi - factory interface
 */
export const StoreBundlesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The SKU for the bundle itself must be unique and there can only be one SKU.  Extra notes for price_override:  The price of all the items (multiplied by the quantity) must equal the price of the bundle.  With individual prices set, items will be processed individually and can be refunded as such.  However, if all prices are set to null, the price of the bundle will be used and will be treated as one item.
         * @summary Create a bundle item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param bundleItem The bundle item object
         */
        createBundleItem(params: {  cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
            return StoreBundlesApiFp.createBundleItem(params, options)(fetch, basePath);
        },
        /**
         * Bundle Templates define a type of bundle and the properties they have.
         * @summary Create a bundle template
         * @param bundleTemplateResource The new bundle template
         */
        createBundleTemplate(params: {  bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreBundlesApiFp.createBundleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a bundle item
         * @param id The id of the bundle
         */
        deleteBundleItem(params: {  id: number; }, options: any = {}) {
            return StoreBundlesApiFp.deleteBundleItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a bundle template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteBundleTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreBundlesApiFp.deleteBundleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single bundle item
         * @param id The id of the bundle
         */
        getBundleItem(params: {  id: number; }, options: any = {}) {
            return StoreBundlesApiFp.getBundleItem(params, options)(fetch, basePath);
        },
        /**
         * Bundle Templates define a type of bundle and the properties they have.
         * @summary Get a single bundle template
         * @param id The id of the template
         */
        getBundleTemplate(params: {  id: string; }, options: any = {}) {
            return StoreBundlesApiFp.getBundleTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search bundle templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getBundleTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreBundlesApiFp.getBundleTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a bundle item
         * @param id The id of the bundle
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param bundleItem The bundle item object
         */
        updateBundleItem(params: {  id: number; cascade?: boolean; bundleItem?: BundleItem; }, options: any = {}) {
            return StoreBundlesApiFp.updateBundleItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a bundle template
         * @param id The id of the template
         * @param bundleTemplateResource The bundle template resource object
         */
        updateBundleTemplate(params: {  id: string; bundleTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreBundlesApiFp.updateBundleTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreCouponsApi - fetch parameter creator
 */
export const StoreCouponsApiFetchParamCreator = {
    /**
     * SKUs have to be unique in the entire store.
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/coupons/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponItem");
        }
        const baseUrl = `/store/coupons/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponItem"]) {
            fetchOptions.body = JSON.stringify(params["couponItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCouponTemplate");
        }
        const baseUrl = `/store/coupons/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["couponTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["couponTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreCouponsApi - functional programming interface
 */
export const StoreCouponsApiFp = {
    /**
     * SKUs have to be unique in the entire store.
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: { cascade?: boolean; couponItem?: CouponItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.createCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: { couponTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.createCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.deleteCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.deleteCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.getCouponTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: { id: number; cascade?: boolean; couponItem?: CouponItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CouponItem> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.updateCouponItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: { id: string; couponTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreCouponsApiFetchParamCreator.updateCouponTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreCouponsApi - object-oriented interface
 */
export class StoreCouponsApi extends BaseAPI {
    /**
     * SKUs have to be unique in the entire store.
     * @summary Create a coupon item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
        return StoreCouponsApiFp.createCouponItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Create a coupon template
     * @param couponTemplateResource The new coupon template
     */
    createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreCouponsApiFp.createCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a coupon item
     * @param id The id of the coupon
     */
    deleteCouponItem(params: {  id: number; }, options: any = {}) {
        return StoreCouponsApiFp.deleteCouponItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a coupon template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteCouponTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreCouponsApiFp.deleteCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single coupon item
     * @param id The id of the coupon
     */
    getCouponItem(params: {  id: number; }, options: any = {}) {
        return StoreCouponsApiFp.getCouponItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Coupon Templates define a type of coupon and the properties they have.
     * @summary Get a single coupon template
     * @param id The id of the template
     */
    getCouponTemplate(params: {  id: string; }, options: any = {}) {
        return StoreCouponsApiFp.getCouponTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search coupon templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreCouponsApiFp.getCouponTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a coupon item
     * @param id The id of the coupon
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param couponItem The coupon item object
     */
    updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
        return StoreCouponsApiFp.updateCouponItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a coupon template
     * @param id The id of the template
     * @param couponTemplateResource The coupon template resource object
     */
    updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreCouponsApiFp.updateCouponTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreCouponsApi - factory interface
 */
export const StoreCouponsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * SKUs have to be unique in the entire store.
         * @summary Create a coupon item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param couponItem The coupon item object
         */
        createCouponItem(params: {  cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
            return StoreCouponsApiFp.createCouponItem(params, options)(fetch, basePath);
        },
        /**
         * Coupon Templates define a type of coupon and the properties they have.
         * @summary Create a coupon template
         * @param couponTemplateResource The new coupon template
         */
        createCouponTemplate(params: {  couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreCouponsApiFp.createCouponTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a coupon item
         * @param id The id of the coupon
         */
        deleteCouponItem(params: {  id: number; }, options: any = {}) {
            return StoreCouponsApiFp.deleteCouponItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a coupon template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteCouponTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreCouponsApiFp.deleteCouponTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single coupon item
         * @param id The id of the coupon
         */
        getCouponItem(params: {  id: number; }, options: any = {}) {
            return StoreCouponsApiFp.getCouponItem(params, options)(fetch, basePath);
        },
        /**
         * Coupon Templates define a type of coupon and the properties they have.
         * @summary Get a single coupon template
         * @param id The id of the template
         */
        getCouponTemplate(params: {  id: string; }, options: any = {}) {
            return StoreCouponsApiFp.getCouponTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search coupon templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCouponTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreCouponsApiFp.getCouponTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a coupon item
         * @param id The id of the coupon
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param couponItem The coupon item object
         */
        updateCouponItem(params: {  id: number; cascade?: boolean; couponItem?: CouponItem; }, options: any = {}) {
            return StoreCouponsApiFp.updateCouponItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a coupon template
         * @param id The id of the template
         * @param couponTemplateResource The coupon template resource object
         */
        updateCouponTemplate(params: {  id: string; couponTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreCouponsApiFp.updateCouponTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreSalesApi - fetch parameter creator
 */
export const StoreSalesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  catalogSale?: CatalogSale; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/sales`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateCatalogSale");
        }
        const baseUrl = `/store/sales/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["catalogSale"]) {
            fetchOptions.body = JSON.stringify(params["catalogSale"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreSalesApi - functional programming interface
 */
export const StoreSalesApiFp = {
    /**
     * 
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: { catalogSale?: CatalogSale;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.createCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSalesApiFetchParamCreator.deleteCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.getCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.getCatalogSales(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: { id: number; catalogSale?: CatalogSale;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CatalogSale> {
        const fetchArgs = StoreSalesApiFetchParamCreator.updateCatalogSale(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreSalesApi - object-oriented interface
 */
export class StoreSalesApi extends BaseAPI {
    /**
     * 
     * @summary Create a sale
     * @param catalogSale The catalog sale object
     */
    createCatalogSale(params: {  catalogSale?: CatalogSale; }, options: any = {}) {
        return StoreSalesApiFp.createCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a sale
     * @param id The id of the sale
     */
    deleteCatalogSale(params: {  id: number; }, options: any = {}) {
        return StoreSalesApiFp.deleteCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single sale
     * @param id The id of the sale
     */
    getCatalogSale(params: {  id: number; }, options: any = {}) {
        return StoreSalesApiFp.getCatalogSale(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search sales
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCatalogSales(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreSalesApiFp.getCatalogSales(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a sale
     * @param id The id of the sale
     * @param catalogSale The catalog sale object
     */
    updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, options: any = {}) {
        return StoreSalesApiFp.updateCatalogSale(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreSalesApi - factory interface
 */
export const StoreSalesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a sale
         * @param catalogSale The catalog sale object
         */
        createCatalogSale(params: {  catalogSale?: CatalogSale; }, options: any = {}) {
            return StoreSalesApiFp.createCatalogSale(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a sale
         * @param id The id of the sale
         */
        deleteCatalogSale(params: {  id: number; }, options: any = {}) {
            return StoreSalesApiFp.deleteCatalogSale(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single sale
         * @param id The id of the sale
         */
        getCatalogSale(params: {  id: number; }, options: any = {}) {
            return StoreSalesApiFp.getCatalogSale(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search sales
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCatalogSales(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreSalesApiFp.getCatalogSales(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a sale
         * @param id The id of the sale
         * @param catalogSale The catalog sale object
         */
        updateCatalogSale(params: {  id: number; catalogSale?: CatalogSale; }, options: any = {}) {
            return StoreSalesApiFp.updateCatalogSale(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreShippingApi - fetch parameter creator
 */
export const StoreShippingApiFetchParamCreator = {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/store/shipping/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingItem");
        }
        const baseUrl = `/store/shipping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingItem"]) {
            fetchOptions.body = JSON.stringify(params["shippingItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingTemplate");
        }
        const baseUrl = `/store/shipping/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["shippingTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["shippingTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreShippingApi - functional programming interface
 */
export const StoreShippingApiFp = {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: { cascade?: boolean; shippingItem?: ShippingItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = StoreShippingApiFetchParamCreator.createShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: { shippingTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.createShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.deleteShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShippingApiFetchParamCreator.deleteShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.getShippingTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: { id: number; cascade?: boolean; shippingItem?: ShippingItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ShippingItem> {
        const fetchArgs = StoreShippingApiFetchParamCreator.updateShippingItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: { id: string; shippingTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreShippingApiFetchParamCreator.updateShippingTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreShippingApi - object-oriented interface
 */
export class StoreShippingApi extends BaseAPI {
    /**
     * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
     * @summary Create a shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
        return StoreShippingApiFp.createShippingItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Create a shipping template
     * @param shippingTemplateResource The new shipping template
     */
    createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreShippingApiFp.createShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a shipping item
     * @param id The id of the shipping item
     */
    deleteShippingItem(params: {  id: number; }, options: any = {}) {
        return StoreShippingApiFp.deleteShippingItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a shipping template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteShippingTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreShippingApiFp.deleteShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single shipping item
     * @param id The id of the shipping item
     */
    getShippingItem(params: {  id: number; }, options: any = {}) {
        return StoreShippingApiFp.getShippingItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Shipping Templates define a type of shipping and the properties they have.
     * @summary Get a single shipping template
     * @param id The id of the template
     */
    getShippingTemplate(params: {  id: string; }, options: any = {}) {
        return StoreShippingApiFp.getShippingTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search shipping templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreShippingApiFp.getShippingTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a shipping item
     * @param id The id of the shipping item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param shippingItem The shipping item object
     */
    updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
        return StoreShippingApiFp.updateShippingItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a shipping template
     * @param id The id of the template
     * @param shippingTemplateResource The shipping template resource object
     */
    updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreShippingApiFp.updateShippingTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreShippingApi - factory interface
 */
export const StoreShippingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A shipping item represents a shipping option and cost. SKUs have to be unique in the entire store.
         * @summary Create a shipping item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param shippingItem The shipping item object
         */
        createShippingItem(params: {  cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
            return StoreShippingApiFp.createShippingItem(params, options)(fetch, basePath);
        },
        /**
         * Shipping Templates define a type of shipping and the properties they have.
         * @summary Create a shipping template
         * @param shippingTemplateResource The new shipping template
         */
        createShippingTemplate(params: {  shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreShippingApiFp.createShippingTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a shipping item
         * @param id The id of the shipping item
         */
        deleteShippingItem(params: {  id: number; }, options: any = {}) {
            return StoreShippingApiFp.deleteShippingItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a shipping template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteShippingTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreShippingApiFp.deleteShippingTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single shipping item
         * @param id The id of the shipping item
         */
        getShippingItem(params: {  id: number; }, options: any = {}) {
            return StoreShippingApiFp.getShippingItem(params, options)(fetch, basePath);
        },
        /**
         * Shipping Templates define a type of shipping and the properties they have.
         * @summary Get a single shipping template
         * @param id The id of the template
         */
        getShippingTemplate(params: {  id: string; }, options: any = {}) {
            return StoreShippingApiFp.getShippingTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search shipping templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getShippingTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreShippingApiFp.getShippingTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a shipping item
         * @param id The id of the shipping item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param shippingItem The shipping item object
         */
        updateShippingItem(params: {  id: number; cascade?: boolean; shippingItem?: ShippingItem; }, options: any = {}) {
            return StoreShippingApiFp.updateShippingItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a shipping template
         * @param id The id of the template
         * @param shippingTemplateResource The shipping template resource object
         */
        updateShippingTemplate(params: {  id: string; shippingTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreShippingApiFp.updateShippingTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreShoppingCartsApi - fetch parameter creator
 */
export const StoreShoppingCartsApiFetchParamCreator = {
    /**
     * 
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addCustomDiscount");
        }
        const baseUrl = `/carts/{id}/custom-discounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["customDiscount"]) {
            fetchOptions.body = JSON.stringify(params["customDiscount"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addDiscountToCart");
        }
        const baseUrl = `/carts/{id}/discounts`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["skuRequest"]) {
            fetchOptions.body = JSON.stringify(params["skuRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  owner?: number; currencyCode?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["owner"] !== undefined) {
            urlObj.query["owner"] = params["owner"];
        }
        if (params["currencyCode"] !== undefined) {
            urlObj.query["currency_code"] = params["currencyCode"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getCart");
        }
        const baseUrl = `/carts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/carts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterOwnerId"] !== undefined) {
            urlObj.query["filter_owner_id"] = params["filterOwnerId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippable");
        }
        const baseUrl = `/carts/{id}/shippable`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getShippingCountries");
        }
        const baseUrl = `/carts/{id}/countries`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  id: string; code: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeDiscountFromCart");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling removeDiscountFromCart");
        }
        const baseUrl = `/carts/{id}/discounts/{code}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May be disallowed by site settings.
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartCurrency");
        }
        const baseUrl = `/carts/{id}/currency`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["currencyCode"]) {
            fetchOptions.body = JSON.stringify(params["currencyCode"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  id: string; userId?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setCartOwner");
        }
        const baseUrl = `/carts/{id}/owner`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userId"]) {
            fetchOptions.body = JSON.stringify(params["userId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A quantity of zero will remove the item from the cart altogether.
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateItemInCart");
        }
        const baseUrl = `/carts/{id}/items`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartItemRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartItemRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateShippingAddress");
        }
        const baseUrl = `/carts/{id}/shipping-address`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["cartShippingAddressRequest"]) {
            fetchOptions.body = JSON.stringify(params["cartShippingAddressRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreShoppingCartsApi - functional programming interface
 */
export const StoreShoppingCartsApiFp = {
    /**
     * 
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: { id: string; customDiscount?: CouponDefinition;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.addCustomDiscount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: { id: string; skuRequest?: SkuRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.addDiscountToCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: { id: string; cartItemRequest?: CartItemRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.addItemToCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: { owner?: number; currencyCode?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.createCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Cart> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: { filterOwnerId?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCartSummary> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getCarts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CartShippableResponse> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getShippable(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SampleCountriesResponse> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.getShippingCountries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: { id: string; code: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.removeDiscountFromCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May be disallowed by site settings.
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: { id: string; currencyCode?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.setCartCurrency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: { id: string; userId?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.setCartOwner(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A quantity of zero will remove the item from the cart altogether.
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: { id: string; cartItemRequest?: CartItemRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.updateItemInCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: { id: string; cartShippingAddressRequest?: CartShippingAddressRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreShoppingCartsApiFetchParamCreator.updateShippingAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreShoppingCartsApi - object-oriented interface
 */
export class StoreShoppingCartsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a custom discount to the cart
     * @param id The id of the cart
     * @param customDiscount The details of the discount to add
     */
    addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, options: any = {}) {
        return StoreShoppingCartsApiFp.addCustomDiscount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds a discount coupon to the cart
     * @param id The id of the cart
     * @param skuRequest The request of the sku
     */
    addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, options: any = {}) {
        return StoreShoppingCartsApiFp.addDiscountToCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
     * @summary Add an item to the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
        return StoreShoppingCartsApiFp.addItemToCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * You don't have to have a user to create a cart but the API requires authentication to checkout
     * @summary Create a cart
     * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
     * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
     */
    createCart(params: {  owner?: number; currencyCode?: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.createCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns the cart with the given GUID
     * @param id The id of the cart
     */
    getCart(params: {  id: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.getCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a list of carts
     * @param filterOwnerId Filter by the id of the owner
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.getCarts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns whether a cart requires shipping
     * @param id The id of the cart
     */
    getShippable(params: {  id: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.getShippable(params, options)(this.fetch, this.basePath);
    }
    /**
     * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
     * @summary Get the list of available shipping countries per vendor
     * @param id The id of the cart
     */
    getShippingCountries(params: {  id: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.getShippingCountries(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Removes a discount coupon from the cart
     * @param id The id of the cart
     * @param code The SKU code of the coupon to remove
     */
    removeDiscountFromCart(params: {  id: string; code: string; }, options: any = {}) {
        return StoreShoppingCartsApiFp.removeDiscountFromCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * May be disallowed by site settings.
     * @summary Sets the currency to use for the cart
     * @param id The id of the cart
     * @param currencyCode The code of the currency
     */
    setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, options: any = {}) {
        return StoreShoppingCartsApiFp.setCartCurrency(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Sets the owner of a cart if none is set already
     * @param id The id of the cart
     * @param userId The id of the user
     */
    setCartOwner(params: {  id: string; userId?: IntWrapper; }, options: any = {}) {
        return StoreShoppingCartsApiFp.setCartOwner(params, options)(this.fetch, this.basePath);
    }
    /**
     * A quantity of zero will remove the item from the cart altogether.
     * @summary Changes the quantity of an item already in the cart
     * @param id The id of the cart
     * @param cartItemRequest The cart item request object
     */
    updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
        return StoreShoppingCartsApiFp.updateItemInCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Modifies or sets the order shipping address
     * @param id The id of the cart
     * @param cartShippingAddressRequest The cart shipping address request object
     */
    updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, options: any = {}) {
        return StoreShoppingCartsApiFp.updateShippingAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreShoppingCartsApi - factory interface
 */
export const StoreShoppingCartsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds a custom discount to the cart
         * @param id The id of the cart
         * @param customDiscount The details of the discount to add
         */
        addCustomDiscount(params: {  id: string; customDiscount?: CouponDefinition; }, options: any = {}) {
            return StoreShoppingCartsApiFp.addCustomDiscount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a discount coupon to the cart
         * @param id The id of the cart
         * @param skuRequest The request of the sku
         */
        addDiscountToCart(params: {  id: string; skuRequest?: SkuRequest; }, options: any = {}) {
            return StoreShoppingCartsApiFp.addDiscountToCart(params, options)(fetch, basePath);
        },
        /**
         * Currently, carts cannot contain virtual and real currency items at the same time. Furthermore, the API only support a single virtual item at the moment
         * @summary Add an item to the cart
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        addItemToCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
            return StoreShoppingCartsApiFp.addItemToCart(params, options)(fetch, basePath);
        },
        /**
         * You don't have to have a user to create a cart but the API requires authentication to checkout
         * @summary Create a cart
         * @param owner Set the owner of a cart. If not specified, defaults to the calling user&#39;s id. If specified and is not the calling user&#39;s id, SHOPPING_CARTS_ADMIN permission is required
         * @param currencyCode Set the currency for the cart, by currency code. May be disallowed by site settings.
         */
        createCart(params: {  owner?: number; currencyCode?: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.createCart(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the cart with the given GUID
         * @param id The id of the cart
         */
        getCart(params: {  id: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.getCart(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of carts
         * @param filterOwnerId Filter by the id of the owner
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCarts(params: {  filterOwnerId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.getCarts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns whether a cart requires shipping
         * @param id The id of the cart
         */
        getShippable(params: {  id: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.getShippable(params, options)(fetch, basePath);
        },
        /**
         * Since a cart can have multiple vendors with different shipping options, the countries are broken down by vendors. Please see notes about the response object as the fields are variable.
         * @summary Get the list of available shipping countries per vendor
         * @param id The id of the cart
         */
        getShippingCountries(params: {  id: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.getShippingCountries(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes a discount coupon from the cart
         * @param id The id of the cart
         * @param code The SKU code of the coupon to remove
         */
        removeDiscountFromCart(params: {  id: string; code: string; }, options: any = {}) {
            return StoreShoppingCartsApiFp.removeDiscountFromCart(params, options)(fetch, basePath);
        },
        /**
         * May be disallowed by site settings.
         * @summary Sets the currency to use for the cart
         * @param id The id of the cart
         * @param currencyCode The code of the currency
         */
        setCartCurrency(params: {  id: string; currencyCode?: StringWrapper; }, options: any = {}) {
            return StoreShoppingCartsApiFp.setCartCurrency(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sets the owner of a cart if none is set already
         * @param id The id of the cart
         * @param userId The id of the user
         */
        setCartOwner(params: {  id: string; userId?: IntWrapper; }, options: any = {}) {
            return StoreShoppingCartsApiFp.setCartOwner(params, options)(fetch, basePath);
        },
        /**
         * A quantity of zero will remove the item from the cart altogether.
         * @summary Changes the quantity of an item already in the cart
         * @param id The id of the cart
         * @param cartItemRequest The cart item request object
         */
        updateItemInCart(params: {  id: string; cartItemRequest?: CartItemRequest; }, options: any = {}) {
            return StoreShoppingCartsApiFp.updateItemInCart(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Modifies or sets the order shipping address
         * @param id The id of the cart
         * @param cartShippingAddressRequest The cart shipping address request object
         */
        updateShippingAddress(params: {  id: string; cartShippingAddressRequest?: CartShippingAddressRequest; }, options: any = {}) {
            return StoreShoppingCartsApiFp.updateShippingAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreSubscriptionsApi - fetch parameter creator
 */
export const StoreSubscriptionsApiFetchParamCreator = {
    /**
     * 
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Must not be locked or a migration target
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  id: number; planId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscription");
        }
        // verify required parameter "planId" is set
        if (params["planId"] == null) {
            throw new Error("Missing required parameter planId when calling deleteSubscription");
        }
        const baseUrl = `/subscriptions/{id}/plans/{plan_id}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"plan_id"}}`, `${ params["planId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(options: any = {}): FetchArgs {
        const baseUrl = `/subscriptions/process`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will not remove plans left out
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscription");
        }
        const baseUrl = `/subscriptions/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateSubscriptionTemplate");
        }
        const baseUrl = `/subscriptions/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["subscriptionTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["subscriptionTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreSubscriptionsApi - functional programming interface
 */
export const StoreSubscriptionsApiFp = {
    /**
     * 
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: { subscriptionResource?: SubscriptionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.createSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: { subscriptionTemplateResource?: SubscriptionTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.createSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Must not be locked or a migration target
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: { id: number; planId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.deleteSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.deleteSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptionTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSubscriptionResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.getSubscriptions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.processSubscriptions(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will not remove plans left out
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: { id: number; subscriptionResource?: SubscriptionResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.updateSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: { id: string; subscriptionTemplateResource?: SubscriptionTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SubscriptionTemplateResource> {
        const fetchArgs = StoreSubscriptionsApiFetchParamCreator.updateSubscriptionTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreSubscriptionsApi - object-oriented interface
 */
export class StoreSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a subscription item and associated plans
     * @param subscriptionResource The subscription to be created
     */
    createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, options: any = {}) {
        return StoreSubscriptionsApiFp.createSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Create a subscription template
     * @param subscriptionTemplateResource The new subscription template
     */
    createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
        return StoreSubscriptionsApiFp.createSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Must not be locked or a migration target
     * @summary Delete a subscription plan
     * @param id The id of the subscription
     * @param planId The id of the plan
     */
    deleteSubscription(params: {  id: number; planId: string; }, options: any = {}) {
        return StoreSubscriptionsApiFp.deleteSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a subscription template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreSubscriptionsApiFp.deleteSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Retrieve a single subscription item and associated plans
     * @param id The id of the subscription
     */
    getSubscription(params: {  id: number; }, options: any = {}) {
        return StoreSubscriptionsApiFp.getSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     * Subscription Templates define a type of subscription and the properties they have.
     * @summary Get a single subscription template
     * @param id The id of the template
     */
    getSubscriptionTemplate(params: {  id: string; }, options: any = {}) {
        return StoreSubscriptionsApiFp.getSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search subscription templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreSubscriptionsApiFp.getSubscriptionTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List available subscription items and associated plans
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getSubscriptions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreSubscriptionsApiFp.getSubscriptions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Processes subscriptions and charge dues
     */
    processSubscriptions(options: any = {}) {
        return StoreSubscriptionsApiFp.processSubscriptions(options)(this.fetch, this.basePath);
    }
    /**
     * Will not remove plans left out
     * @summary Updates a subscription item and associated plans
     * @param id The id of the subscription
     * @param subscriptionResource The subscription resource object
     */
    updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, options: any = {}) {
        return StoreSubscriptionsApiFp.updateSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a subscription template
     * @param id The id of the template
     * @param subscriptionTemplateResource The subscription template resource object
     */
    updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
        return StoreSubscriptionsApiFp.updateSubscriptionTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreSubscriptionsApi - factory interface
 */
export const StoreSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a subscription item and associated plans
         * @param subscriptionResource The subscription to be created
         */
        createSubscription(params: {  subscriptionResource?: SubscriptionResource; }, options: any = {}) {
            return StoreSubscriptionsApiFp.createSubscription(params, options)(fetch, basePath);
        },
        /**
         * Subscription Templates define a type of subscription and the properties they have.
         * @summary Create a subscription template
         * @param subscriptionTemplateResource The new subscription template
         */
        createSubscriptionTemplate(params: {  subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
            return StoreSubscriptionsApiFp.createSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /**
         * Must not be locked or a migration target
         * @summary Delete a subscription plan
         * @param id The id of the subscription
         * @param planId The id of the plan
         */
        deleteSubscription(params: {  id: number; planId: string; }, options: any = {}) {
            return StoreSubscriptionsApiFp.deleteSubscription(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a subscription template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteSubscriptionTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreSubscriptionsApiFp.deleteSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve a single subscription item and associated plans
         * @param id The id of the subscription
         */
        getSubscription(params: {  id: number; }, options: any = {}) {
            return StoreSubscriptionsApiFp.getSubscription(params, options)(fetch, basePath);
        },
        /**
         * Subscription Templates define a type of subscription and the properties they have.
         * @summary Get a single subscription template
         * @param id The id of the template
         */
        getSubscriptionTemplate(params: {  id: string; }, options: any = {}) {
            return StoreSubscriptionsApiFp.getSubscriptionTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search subscription templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptionTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreSubscriptionsApiFp.getSubscriptionTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List available subscription items and associated plans
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getSubscriptions(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreSubscriptionsApiFp.getSubscriptions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Processes subscriptions and charge dues
         */
        processSubscriptions(options: any = {}) {
            return StoreSubscriptionsApiFp.processSubscriptions(options)(fetch, basePath);
        },
        /**
         * Will not remove plans left out
         * @summary Updates a subscription item and associated plans
         * @param id The id of the subscription
         * @param subscriptionResource The subscription resource object
         */
        updateSubscription(params: {  id: number; subscriptionResource?: SubscriptionResource; }, options: any = {}) {
            return StoreSubscriptionsApiFp.updateSubscription(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a subscription template
         * @param id The id of the template
         * @param subscriptionTemplateResource The subscription template resource object
         */
        updateSubscriptionTemplate(params: {  id: string; subscriptionTemplateResource?: SubscriptionTemplateResource; }, options: any = {}) {
            return StoreSubscriptionsApiFp.updateSubscriptionTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreVendorsApi - fetch parameter creator
 */
export const StoreVendorsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  vendor?: VendorResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/vendors/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendorTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["vendorTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/vendors/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/vendors`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  id: number; vendor?: VendorResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVendor");
        }
        const baseUrl = `/vendors/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendor"]) {
            fetchOptions.body = JSON.stringify(params["vendor"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateVendorTemplate");
        }
        const baseUrl = `/vendors/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vendorTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["vendorTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreVendorsApi - functional programming interface
 */
export const StoreVendorsApiFp = {
    /**
     * 
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: { vendor?: VendorResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.createVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: { vendorTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.createVendorTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.deleteVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.deleteVendorTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendorTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendorTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: { filterName?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceVendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.getVendors(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: { id: number; vendor?: VendorResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<VendorResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.updateVendor(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: { id: string; vendorTemplateResource?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = StoreVendorsApiFetchParamCreator.updateVendorTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreVendorsApi - object-oriented interface
 */
export class StoreVendorsApi extends BaseAPI {
    /**
     * 
     * @summary Create a vendor
     * @param vendor The vendor
     */
    createVendor(params: {  vendor?: VendorResource; }, options: any = {}) {
        return StoreVendorsApiFp.createVendor(params, options)(this.fetch, this.basePath);
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Create a vendor template
     * @param vendorTemplateResource The new vendor template
     */
    createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreVendorsApiFp.createVendorTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a vendor
     * @param id The id of the vendor
     */
    deleteVendor(params: {  id: number; }, options: any = {}) {
        return StoreVendorsApiFp.deleteVendor(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a vendor template
     * @param id The id of the template
     * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
     */
    deleteVendorTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return StoreVendorsApiFp.deleteVendorTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single vendor
     * @param id The id of the vendor
     */
    getVendor(params: {  id: number; }, options: any = {}) {
        return StoreVendorsApiFp.getVendor(params, options)(this.fetch, this.basePath);
    }
    /**
     * Vendor Templates define a type of vendor and the properties they have.
     * @summary Get a single vendor template
     * @param id The id of the template
     */
    getVendorTemplate(params: {  id: string; }, options: any = {}) {
        return StoreVendorsApiFp.getVendorTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search vendor templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreVendorsApiFp.getVendorTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search vendors
     * @param filterName Filters vendors by name starting with the text provided in the filter
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return StoreVendorsApiFp.getVendors(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a vendor
     * @param id The id of the vendor
     * @param vendor The vendor
     */
    updateVendor(params: {  id: number; vendor?: VendorResource; }, options: any = {}) {
        return StoreVendorsApiFp.updateVendor(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a vendor template
     * @param id The id of the template
     * @param vendorTemplateResource The vendor template resource object
     */
    updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
        return StoreVendorsApiFp.updateVendorTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreVendorsApi - factory interface
 */
export const StoreVendorsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a vendor
         * @param vendor The vendor
         */
        createVendor(params: {  vendor?: VendorResource; }, options: any = {}) {
            return StoreVendorsApiFp.createVendor(params, options)(fetch, basePath);
        },
        /**
         * Vendor Templates define a type of vendor and the properties they have.
         * @summary Create a vendor template
         * @param vendorTemplateResource The new vendor template
         */
        createVendorTemplate(params: {  vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreVendorsApiFp.createVendorTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a vendor
         * @param id The id of the vendor
         */
        deleteVendor(params: {  id: number; }, options: any = {}) {
            return StoreVendorsApiFp.deleteVendor(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a vendor template
         * @param id The id of the template
         * @param cascade force deleting the template if it&#39;s attached to other objects, cascade &#x3D; detach
         */
        deleteVendorTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return StoreVendorsApiFp.deleteVendorTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single vendor
         * @param id The id of the vendor
         */
        getVendor(params: {  id: number; }, options: any = {}) {
            return StoreVendorsApiFp.getVendor(params, options)(fetch, basePath);
        },
        /**
         * Vendor Templates define a type of vendor and the properties they have.
         * @summary Get a single vendor template
         * @param id The id of the template
         */
        getVendorTemplate(params: {  id: string; }, options: any = {}) {
            return StoreVendorsApiFp.getVendorTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search vendor templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVendorTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreVendorsApiFp.getVendorTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search vendors
         * @param filterName Filters vendors by name starting with the text provided in the filter
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getVendors(params: {  filterName?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return StoreVendorsApiFp.getVendors(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a vendor
         * @param id The id of the vendor
         * @param vendor The vendor
         */
        updateVendor(params: {  id: number; vendor?: VendorResource; }, options: any = {}) {
            return StoreVendorsApiFp.updateVendor(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a vendor template
         * @param id The id of the template
         * @param vendorTemplateResource The vendor template resource object
         */
        updateVendorTemplate(params: {  id: string; vendorTemplateResource?: ItemTemplateResource; }, options: any = {}) {
            return StoreVendorsApiFp.updateVendorTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxesApi - fetch parameter creator
 */
export const TaxesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  taxResource?: CountryTaxResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling createStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  countryCodeIso3: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling deleteStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling deleteStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  countryCodeIso3: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/tax/countries`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling getStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/tax/states`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling getStateTaxesForCountry");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateCountryTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, options: any = {}): FetchArgs {
        // verify required parameter "countryCodeIso3" is set
        if (params["countryCodeIso3"] == null) {
            throw new Error("Missing required parameter countryCodeIso3 when calling updateStateTax");
        }
        // verify required parameter "stateCode" is set
        if (params["stateCode"] == null) {
            throw new Error("Missing required parameter stateCode when calling updateStateTax");
        }
        const baseUrl = `/tax/countries/{country_code_iso3}/states/{state_code}`
            .replace(`{${"country_code_iso3"}}`, `${ params["countryCodeIso3"] }`)
            .replace(`{${"state_code"}}`, `${ params["stateCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxResource"]) {
            fetchOptions.body = JSON.stringify(params["taxResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxesApi - functional programming interface
 */
export const TaxesApiFp = {
    /**
     * 
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: { taxResource?: CountryTaxResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.createCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: { countryCodeIso3: string; taxResource?: StateTaxResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.createStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: { countryCodeIso3: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: { countryCodeIso3: string; stateCode: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxesApiFetchParamCreator.deleteStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: { countryCodeIso3: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceCountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getCountryTaxes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: { countryCodeIso3: string; stateCode: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of taxes
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: { countryCodeIso3: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceStateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.getStateTaxesForCountry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: { countryCodeIso3: string; taxResource?: CountryTaxResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<CountryTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.updateCountryTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: { countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<StateTaxResource> {
        const fetchArgs = TaxesApiFetchParamCreator.updateStateTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxesApi - object-oriented interface
 */
export class TaxesApi extends BaseAPI {
    /**
     * 
     * @summary Create a country tax
     * @param taxResource The tax object
     */
    createCountryTax(params: {  taxResource?: CountryTaxResource; }, options: any = {}) {
        return TaxesApiFp.createCountryTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, options: any = {}) {
        return TaxesApiFp.createStateTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    deleteCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
        return TaxesApiFp.deleteCountryTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an existing state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
        return TaxesApiFp.deleteStateTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single tax
     * @param countryCodeIso3 The iso3 code of the country
     */
    getCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
        return TaxesApiFp.getCountryTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getCountryTaxes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     */
    getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
        return TaxesApiFp.getStateTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes across all countries
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getStateTaxesForCountries(params, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of taxes
     * @summary List and search taxes within a country
     * @param countryCodeIso3 The iso3 code of the country
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return TaxesApiFp.getStateTaxesForCountry(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create or update a tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param taxResource The tax object
     */
    updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, options: any = {}) {
        return TaxesApiFp.updateCountryTax(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create or update a state tax
     * @param countryCodeIso3 The iso3 code of the country
     * @param stateCode The code of the state
     * @param taxResource The tax object
     */
    updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, options: any = {}) {
        return TaxesApiFp.updateStateTax(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxesApi - factory interface
 */
export const TaxesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a country tax
         * @param taxResource The tax object
         */
        createCountryTax(params: {  taxResource?: CountryTaxResource; }, options: any = {}) {
            return TaxesApiFp.createCountryTax(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        createStateTax(params: {  countryCodeIso3: string; taxResource?: StateTaxResource; }, options: any = {}) {
            return TaxesApiFp.createStateTax(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        deleteCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
            return TaxesApiFp.deleteCountryTax(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an existing state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        deleteStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
            return TaxesApiFp.deleteStateTax(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single tax
         * @param countryCodeIso3 The iso3 code of the country
         */
        getCountryTax(params: {  countryCodeIso3: string; }, options: any = {}) {
            return TaxesApiFp.getCountryTax(params, options)(fetch, basePath);
        },
        /**
         * Get a list of taxes
         * @summary List and search taxes
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getCountryTaxes(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return TaxesApiFp.getCountryTaxes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         */
        getStateTax(params: {  countryCodeIso3: string; stateCode: string; }, options: any = {}) {
            return TaxesApiFp.getStateTax(params, options)(fetch, basePath);
        },
        /**
         * Get a list of taxes
         * @summary List and search taxes across all countries
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountries(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return TaxesApiFp.getStateTaxesForCountries(params, options)(fetch, basePath);
        },
        /**
         * Get a list of taxes
         * @summary List and search taxes within a country
         * @param countryCodeIso3 The iso3 code of the country
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getStateTaxesForCountry(params: {  countryCodeIso3: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return TaxesApiFp.getStateTaxesForCountry(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create or update a tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param taxResource The tax object
         */
        updateCountryTax(params: {  countryCodeIso3: string; taxResource?: CountryTaxResource; }, options: any = {}) {
            return TaxesApiFp.updateCountryTax(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create or update a state tax
         * @param countryCodeIso3 The iso3 code of the country
         * @param stateCode The code of the state
         * @param taxResource The tax object
         */
        updateStateTax(params: {  countryCodeIso3: string; stateCode: string; taxResource?: StateTaxResource; }, options: any = {}) {
            return TaxesApiFp.updateStateTax(params, options)(fetch, basePath);
        },
    };
};


/**
 * TemplatesPropertiesApi - fetch parameter creator
 */
export const TemplatesPropertiesApiFetchParamCreator = {
    /**
     * 
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: {  type: string; }, options: any = {}): FetchArgs {
        // verify required parameter "type" is set
        if (params["type"] == null) {
            throw new Error("Missing required parameter type when calling getTemplatePropertyType");
        }
        const baseUrl = `/templates/properties/{type}`
            .replace(`{${"type"}}`, `${ params["type"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List template property types
     */
    getTemplatePropertyTypes(options: any = {}): FetchArgs {
        const baseUrl = `/templates/properties`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TemplatesPropertiesApi - functional programming interface
 */
export const TemplatesPropertiesApiFp = {
    /**
     * 
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: { type: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PropertyFieldListResource> {
        const fetchArgs = TemplatesPropertiesApiFetchParamCreator.getTemplatePropertyType(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List template property types
     */
    getTemplatePropertyTypes(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<PropertyFieldListResource>> {
        const fetchArgs = TemplatesPropertiesApiFetchParamCreator.getTemplatePropertyTypes(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TemplatesPropertiesApi - object-oriented interface
 */
export class TemplatesPropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Get details for a template property type
     * @param type type
     */
    getTemplatePropertyType(params: {  type: string; }, options: any = {}) {
        return TemplatesPropertiesApiFp.getTemplatePropertyType(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List template property types
     */
    getTemplatePropertyTypes(options: any = {}) {
        return TemplatesPropertiesApiFp.getTemplatePropertyTypes(options)(this.fetch, this.basePath);
    }
};

/**
 * TemplatesPropertiesApi - factory interface
 */
export const TemplatesPropertiesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get details for a template property type
         * @param type type
         */
        getTemplatePropertyType(params: {  type: string; }, options: any = {}) {
            return TemplatesPropertiesApiFp.getTemplatePropertyType(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List template property types
         */
        getTemplatePropertyTypes(options: any = {}) {
            return TemplatesPropertiesApiFp.getTemplatePropertyTypes(options)(fetch, basePath);
        },
    };
};


/**
 * UsersApi - fetch parameter creator
 */
export const UsersApiFetchParamCreator = {
    /**
     * 
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  userId: number; tag: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling addUserTag");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["tag"]) {
            fetchOptions.body = JSON.stringify(params["tag"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * User Templates define a type of user and the properties they have
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserTags");
        }
        const baseUrl = `/users/{user_id}/tags`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterDisplayname"] !== undefined) {
            urlObj.query["filter_displayname"] = params["filterDisplayname"];
        }
        if (params["filterEmail"] !== undefined) {
            urlObj.query["filter_email"] = params["filterEmail"];
        }
        if (params["filterFirstname"] !== undefined) {
            urlObj.query["filter_firstname"] = params["filterFirstname"];
        }
        if (params["filterFullname"] !== undefined) {
            urlObj.query["filter_fullname"] = params["filterFullname"];
        }
        if (params["filterLastname"] !== undefined) {
            urlObj.query["filter_lastname"] = params["filterLastname"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterTag"] !== undefined) {
            urlObj.query["filter_tag"] = params["filterTag"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterRole"] !== undefined) {
            urlObj.query["filter_role"] = params["filterRole"];
        }
        if (params["filterSearch"] !== undefined) {
            urlObj.query["filter_search"] = params["filterSearch"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling passwordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newPasswordRequest"]) {
            fetchOptions.body = JSON.stringify(params["newPasswordRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: {  userResource?: UserResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  userId: number; tag: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeUserTag");
        }
        // verify required parameter "tag" is set
        if (params["tag"] == null) {
            throw new Error("Missing required parameter tag when calling removeUserTag");
        }
        const baseUrl = `/users/{user_id}/tags/{tag}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"tag"}}`, `${ params["tag"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  id: number; password?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling setPassword");
        }
        const baseUrl = `/users/{id}/password`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["password"]) {
            fetchOptions.body = JSON.stringify(params["password"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling startPasswordReset");
        }
        const baseUrl = `/users/{id}/password-reset`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/password-reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["passwordReset"]) {
            fetchOptions.body = JSON.stringify(params["passwordReset"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  id: string; userResource?: UserResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUser");
        }
        const baseUrl = `/users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userResource"]) {
            fetchOptions.body = JSON.stringify(params["userResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserTemplate");
        }
        const baseUrl = `/users/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["userTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = {
    /**
     * 
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: { userId: number; tag: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.addUserTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * User Templates define a type of user and the properties they have
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: { userTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.createUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.deleteUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: { userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUserTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: { filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterSearch?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserBaseResource> {
        const fetchArgs = UsersApiFetchParamCreator.getUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: { id: number; newPasswordRequest?: NewPasswordRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.passwordReset(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: { userResource?: UserResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserResource> {
        const fetchArgs = UsersApiFetchParamCreator.registerUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: { userId: number; tag: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.removeUserTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: { id: number; password?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.setPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.startPasswordReset(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: { passwordReset?: PasswordResetRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.submitPasswordReset(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: { id: string; userResource?: UserResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersApiFetchParamCreator.updateUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: { id: string; userTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersApiFetchParamCreator.updateUserTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Add a tag to a user
     * @param userId The id of the user
     * @param tag tag
     */
    addUserTag(params: {  userId: number; tag: StringWrapper; }, options: any = {}) {
        return UsersApiFp.addUserTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * User Templates define a type of user and the properties they have
     * @summary Create a user template
     * @param userTemplateResource The user template resource object
     */
    createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersApiFp.createUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a user template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteUserTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return UsersApiFp.deleteUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary Get a single user
     * @param id The id of the user or &#39;me&#39;
     */
    getUser(params: {  id: string; }, options: any = {}) {
        return UsersApiFp.getUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List tags for a user
     * @param userId The id of the user
     */
    getUserTags(params: {  userId: number; }, options: any = {}) {
        return UsersApiFp.getUserTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single user template
     * @param id The id of the template
     */
    getUserTemplate(params: {  id: string; }, options: any = {}) {
        return UsersApiFp.getUserTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search user templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersApiFp.getUserTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * Additional private info is included as USERS_ADMIN
     * @summary List and search users
     * @param filterDisplayname Filter for users whose display name starts with provided string.
     * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
     * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
     * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
     * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
     * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
     * @param filterTag Filter for users who have a given tag
     * @param filterGroup Filter for users in a given group, by unique name
     * @param filterRole Filter for users with a given role
     * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersApiFp.getUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Choose a new password after a reset
     * @param id The id of the user
     * @param newPasswordRequest The new password request object
     */
    passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, options: any = {}) {
        return UsersApiFp.passwordReset(params, options)(this.fetch, this.basePath);
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security
     * @summary Register a new user
     * @param userResource The user resource object
     */
    registerUser(params: {  userResource?: UserResource; }, options: any = {}) {
        return UsersApiFp.registerUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove a tag from a user
     * @param userId The id of the user
     * @param tag The tag to remove
     */
    removeUserTag(params: {  userId: number; tag: string; }, options: any = {}) {
        return UsersApiFp.removeUserTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
     * @summary Set a user's password
     * @param id The id of the user
     * @param password The new plain text password
     */
    setPassword(params: {  id: number; password?: StringWrapper; }, options: any = {}) {
        return UsersApiFp.setPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit
     * @summary Reset a user's password
     * @param id The id of the user
     */
    startPasswordReset(params: {  id: number; }, options: any = {}) {
        return UsersApiFp.startPasswordReset(params, options)(this.fetch, this.basePath);
    }
    /**
     * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number
     * @summary Reset a user's password without user id
     * @param passwordReset An object containing one of three methods to look up a user
     */
    submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, options: any = {}) {
        return UsersApiFp.submitPasswordReset(params, options)(this.fetch, this.basePath);
    }
    /**
     * Password will not be edited on this endpoint, use password specific endpoints.
     * @summary Update a user
     * @param id The id of the user or &#39;me&#39;
     * @param userResource The user resource object
     */
    updateUser(params: {  id: string; userResource?: UserResource; }, options: any = {}) {
        return UsersApiFp.updateUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a user template
     * @param id The id of the template
     * @param userTemplateResource The user template resource object
     */
    updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersApiFp.updateUserTemplate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a tag to a user
         * @param userId The id of the user
         * @param tag tag
         */
        addUserTag(params: {  userId: number; tag: StringWrapper; }, options: any = {}) {
            return UsersApiFp.addUserTag(params, options)(fetch, basePath);
        },
        /**
         * User Templates define a type of user and the properties they have
         * @summary Create a user template
         * @param userTemplateResource The user template resource object
         */
        createUserTemplate(params: {  userTemplateResource?: TemplateResource; }, options: any = {}) {
            return UsersApiFp.createUserTemplate(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a user template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteUserTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return UsersApiFp.deleteUserTemplate(params, options)(fetch, basePath);
        },
        /**
         * Additional private info is included as USERS_ADMIN
         * @summary Get a single user
         * @param id The id of the user or &#39;me&#39;
         */
        getUser(params: {  id: string; }, options: any = {}) {
            return UsersApiFp.getUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List tags for a user
         * @param userId The id of the user
         */
        getUserTags(params: {  userId: number; }, options: any = {}) {
            return UsersApiFp.getUserTags(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single user template
         * @param id The id of the template
         */
        getUserTemplate(params: {  id: string; }, options: any = {}) {
            return UsersApiFp.getUserTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search user templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersApiFp.getUserTemplates(params, options)(fetch, basePath);
        },
        /**
         * Additional private info is included as USERS_ADMIN
         * @summary List and search users
         * @param filterDisplayname Filter for users whose display name starts with provided string.
         * @param filterEmail Filter for users whose email starts with provided string. Requires USERS_ADMIN permission
         * @param filterFirstname Filter for users whose first name starts with provided string. Requires USERS_ADMIN permission
         * @param filterFullname Filter for users whose full name starts with provided string. Requires USERS_ADMIN permission
         * @param filterLastname Filter for users whose last name starts with provided string. Requires USERS_ADMIN permission
         * @param filterUsername Filter for users whose username starts with the provided string. Requires USERS_ADMIN permission
         * @param filterTag Filter for users who have a given tag
         * @param filterGroup Filter for users in a given group, by unique name
         * @param filterRole Filter for users with a given role
         * @param filterSearch Filter for users whose display_name starts with the provided string, or username if display_name is null
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUsers(params: {  filterDisplayname?: string; filterEmail?: string; filterFirstname?: string; filterFullname?: string; filterLastname?: string; filterUsername?: string; filterTag?: string; filterGroup?: string; filterRole?: string; filterSearch?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersApiFp.getUsers(params, options)(fetch, basePath);
        },
        /**
         * Finish resetting a user's password using the secret provided from the password-reset endpoint.  Password should be in plain text and will be encrypted on receipt. Use SSL for security.
         * @summary Choose a new password after a reset
         * @param id The id of the user
         * @param newPasswordRequest The new password request object
         */
        passwordReset(params: {  id: number; newPasswordRequest?: NewPasswordRequest; }, options: any = {}) {
            return UsersApiFp.passwordReset(params, options)(fetch, basePath);
        },
        /**
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security
         * @summary Register a new user
         * @param userResource The user resource object
         */
        registerUser(params: {  userResource?: UserResource; }, options: any = {}) {
            return UsersApiFp.registerUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a tag from a user
         * @param userId The id of the user
         * @param tag The tag to remove
         */
        removeUserTag(params: {  userId: number; tag: string; }, options: any = {}) {
            return UsersApiFp.removeUserTag(params, options)(fetch, basePath);
        },
        /**
         * Password should be in plain text and will be encrypted on receipt. Use SSL for security.
         * @summary Set a user's password
         * @param id The id of the user
         * @param password The new plain text password
         */
        setPassword(params: {  id: number; password?: StringWrapper; }, options: any = {}) {
            return UsersApiFp.setPassword(params, options)(fetch, basePath);
        },
        /**
         * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit
         * @summary Reset a user's password
         * @param id The id of the user
         */
        startPasswordReset(params: {  id: number; }, options: any = {}) {
            return UsersApiFp.startPasswordReset(params, options)(fetch, basePath);
        },
        /**
         * A reset code will be generated and a 'forgot_password' BRE event will be fired with that code.  The default system rule will send an email to the selected user if an email service has been setup. You can modify that rule in BRE to send an SMS instead or any other type of notification as you see fit.  Must submit their email, username, or mobile phone number
         * @summary Reset a user's password without user id
         * @param passwordReset An object containing one of three methods to look up a user
         */
        submitPasswordReset(params: {  passwordReset?: PasswordResetRequest; }, options: any = {}) {
            return UsersApiFp.submitPasswordReset(params, options)(fetch, basePath);
        },
        /**
         * Password will not be edited on this endpoint, use password specific endpoints.
         * @summary Update a user
         * @param id The id of the user or &#39;me&#39;
         * @param userResource The user resource object
         */
        updateUser(params: {  id: string; userResource?: UserResource; }, options: any = {}) {
            return UsersApiFp.updateUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a user template
         * @param id The id of the template
         * @param userTemplateResource The user template resource object
         */
        updateUserTemplate(params: {  id: string; userTemplateResource?: TemplateResource; }, options: any = {}) {
            return UsersApiFp.updateUserTemplate(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersAddressesApi - fetch parameter creator
 */
export const UsersAddressesApiFetchParamCreator = {
    /**
     * 
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling createAddress");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  userId: string; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling deleteAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  userId: string; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getAddresses");
        }
        const baseUrl = `/users/{user_id}/addresses`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateAddress");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateAddress");
        }
        const baseUrl = `/users/{user_id}/addresses/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["savedAddressResource"]) {
            fetchOptions.body = JSON.stringify(params["savedAddressResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersAddressesApi - functional programming interface
 */
export const UsersAddressesApiFp = {
    /**
     * 
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: { userId: string; savedAddressResource?: SavedAddressResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.createAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: { userId: string; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.deleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: { userId: string; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.getAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: { userId: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.getAddresses(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: { userId: string; id: number; savedAddressResource?: SavedAddressResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<SavedAddressResource> {
        const fetchArgs = UsersAddressesApiFetchParamCreator.updateAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersAddressesApi - object-oriented interface
 */
export class UsersAddressesApi extends BaseAPI {
    /**
     * 
     * @summary Create a new address
     * @param userId The id of the user
     * @param savedAddressResource The new address
     */
    createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
        return UsersAddressesApiFp.createAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an address
     * @param userId The id of the user
     * @param id The id of the address
     */
    deleteAddress(params: {  userId: string; id: number; }, options: any = {}) {
        return UsersAddressesApiFp.deleteAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single address
     * @param userId The id of the user
     * @param id The id of the address
     */
    getAddress(params: {  userId: string; id: number; }, options: any = {}) {
        return UsersAddressesApiFp.getAddress(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search addresses
     * @param userId The id of the user
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersAddressesApiFp.getAddresses(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an address
     * @param userId The id of the user
     * @param id The id of the address
     * @param savedAddressResource The saved address resource object
     */
    updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
        return UsersAddressesApiFp.updateAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersAddressesApi - factory interface
 */
export const UsersAddressesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a new address
         * @param userId The id of the user
         * @param savedAddressResource The new address
         */
        createAddress(params: {  userId: string; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
            return UsersAddressesApiFp.createAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an address
         * @param userId The id of the user
         * @param id The id of the address
         */
        deleteAddress(params: {  userId: string; id: number; }, options: any = {}) {
            return UsersAddressesApiFp.deleteAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single address
         * @param userId The id of the user
         * @param id The id of the address
         */
        getAddress(params: {  userId: string; id: number; }, options: any = {}) {
            return UsersAddressesApiFp.getAddress(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search addresses
         * @param userId The id of the user
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getAddresses(params: {  userId: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersAddressesApiFp.getAddresses(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an address
         * @param userId The id of the user
         * @param id The id of the address
         * @param savedAddressResource The saved address resource object
         */
        updateAddress(params: {  userId: string; id: number; savedAddressResource?: SavedAddressResource; }, options: any = {}) {
            return UsersAddressesApiFp.updateAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersFriendshipsApi - fetch parameter creator
 */
export const UsersFriendshipsApiFetchParamCreator = {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  userId: string; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling addFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: {  userId: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getFriends");
        }
        const baseUrl = `/users/{user_id}/friends`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  userId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInviteToken");
        }
        const baseUrl = `/users/{user_id}/invite-token`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Invites that the specified user received
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: {  userId: string; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getInvites");
        }
        const baseUrl = `/users/{user_id}/invites`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling redeemFriendshipToken");
        }
        const baseUrl = `/users/{user_id}/friends/tokens`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["token"]) {
            fetchOptions.body = JSON.stringify(params["token"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  userId: string; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeOrDeclineFriend");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling removeOrDeclineFriend");
        }
        const baseUrl = `/users/{user_id}/friends/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersFriendshipsApi - functional programming interface
 */
export const UsersFriendshipsApiFp = {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: { userId: string; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.addFriend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: { userId: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getFriends(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: { userId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getInviteToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Invites that the specified user received
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: { userId: string; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceSimpleUserResource> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.getInvites(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: { userId: string; token?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.redeemFriendshipToken(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: { userId: string; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersFriendshipsApiFetchParamCreator.removeOrDeclineFriend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersFriendshipsApi - object-oriented interface
 */
export class UsersFriendshipsApi extends BaseAPI {
    /**
     * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
     * @summary Add a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    addFriend(params: {  userId: string; id: number; }, options: any = {}) {
        return UsersFriendshipsApiFp.addFriend(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get friends list
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getFriends(params: {  userId: string; size?: number; page?: number; }, options: any = {}) {
        return UsersFriendshipsApiFp.getFriends(params, options)(this.fetch, this.basePath);
    }
    /**
     * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
     * @summary Returns the invite token
     * @param userId The id of the user or &#39;me&#39; if logged in
     */
    getInviteToken(params: {  userId: string; }, options: any = {}) {
        return UsersFriendshipsApiFp.getInviteToken(params, options)(this.fetch, this.basePath);
    }
    /**
     * Invites that the specified user received
     * @summary Get pending invites
     * @param userId The id of the user or &#39;me&#39;
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getInvites(params: {  userId: string; size?: number; page?: number; }, options: any = {}) {
        return UsersFriendshipsApiFp.getInvites(params, options)(this.fetch, this.basePath);
    }
    /**
     * Immediately connects the requested user with the user mapped by the provided invite token
     * @summary Redeem friendship token
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param token The invite token
     */
    redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, options: any = {}) {
        return UsersFriendshipsApiFp.redeemFriendshipToken(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove or decline a friend
     * @param userId The id of the user or &#39;me&#39; if logged in
     * @param id The id of the user to befriend
     */
    removeOrDeclineFriend(params: {  userId: string; id: number; }, options: any = {}) {
        return UsersFriendshipsApiFp.removeOrDeclineFriend(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersFriendshipsApi - factory interface
 */
export const UsersFriendshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * As a user, either creates or confirm a pending request. As an admin, call this endpoint twice while inverting the IDs to create a confirmed friendship.
         * @summary Add a friend
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        addFriend(params: {  userId: string; id: number; }, options: any = {}) {
            return UsersFriendshipsApiFp.addFriend(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get friends list
         * @param userId The id of the user or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getFriends(params: {  userId: string; size?: number; page?: number; }, options: any = {}) {
            return UsersFriendshipsApiFp.getFriends(params, options)(fetch, basePath);
        },
        /**
         * This is a unique invite token that allows direct connection to the request user.  Exposing that token presents privacy issues if the token is leaked. Use friend request flow instead if confirmation is required
         * @summary Returns the invite token
         * @param userId The id of the user or &#39;me&#39; if logged in
         */
        getInviteToken(params: {  userId: string; }, options: any = {}) {
            return UsersFriendshipsApiFp.getInviteToken(params, options)(fetch, basePath);
        },
        /**
         * Invites that the specified user received
         * @summary Get pending invites
         * @param userId The id of the user or &#39;me&#39;
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getInvites(params: {  userId: string; size?: number; page?: number; }, options: any = {}) {
            return UsersFriendshipsApiFp.getInvites(params, options)(fetch, basePath);
        },
        /**
         * Immediately connects the requested user with the user mapped by the provided invite token
         * @summary Redeem friendship token
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param token The invite token
         */
        redeemFriendshipToken(params: {  userId: string; token?: StringWrapper; }, options: any = {}) {
            return UsersFriendshipsApiFp.redeemFriendshipToken(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove or decline a friend
         * @param userId The id of the user or &#39;me&#39; if logged in
         * @param id The id of the user to befriend
         */
        removeOrDeclineFriend(params: {  userId: string; id: number; }, options: any = {}) {
            return UsersFriendshipsApiFp.removeOrDeclineFriend(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersGroupsApi - fetch parameter creator
 */
export const UsersGroupsApiFetchParamCreator = {
    /**
     * 
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling addMemberToGroup");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling addMemberToGroup");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["user"]) {
            fetchOptions.body = JSON.stringify(params["user"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling addMembersToGroup");
        }
        // verify required parameter "users" is set
        if (params["users"] == null) {
            throw new Error("Missing required parameter users when calling addMembersToGroup");
        }
        const baseUrl = `/users/groups/{unique_name}/members/batch-add`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["users"]) {
            fetchOptions.body = JSON.stringify(params["users"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  groupResource?: GroupResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Group Templates define a type of group and the properties they have
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  uniqueName: string; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling deleteGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  uniqueName: string; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling getGroupMembers");
        }
        const baseUrl = `/users/groups/{unique_name}/members`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: {  userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getGroupsForUser");
        }
        const baseUrl = `/users/{user_id}/groups`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling removeGroupMember");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling removeGroupMember");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroup");
        }
        const baseUrl = `/users/groups/{unique_name}`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupResource"]) {
            fetchOptions.body = JSON.stringify(params["groupResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: string; }, options: any = {}): FetchArgs {
        // verify required parameter "uniqueName" is set
        if (params["uniqueName"] == null) {
            throw new Error("Missing required parameter uniqueName when calling updateGroupMemberStatus");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateGroupMemberStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling updateGroupMemberStatus");
        }
        const baseUrl = `/users/groups/{unique_name}/members/{user_id}/status`
            .replace(`{${"unique_name"}}`, `${ params["uniqueName"] }`)
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateGroupTemplate");
        }
        const baseUrl = `/users/groups/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["groupTemplateResource"]) {
            fetchOptions.body = JSON.stringify(params["groupTemplateResource"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/groups`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["filterTemplate"] !== undefined) {
            urlObj.query["filter_template"] = params["filterTemplate"];
        }
        if (params["filterMemberCount"] !== undefined) {
            urlObj.query["filter_member_count"] = params["filterMemberCount"];
        }
        if (params["filterName"] !== undefined) {
            urlObj.query["filter_name"] = params["filterName"];
        }
        if (params["filterUniqueName"] !== undefined) {
            urlObj.query["filter_unique_name"] = params["filterUniqueName"];
        }
        if (params["filterParent"] !== undefined) {
            urlObj.query["filter_parent"] = params["filterParent"];
        }
        if (params["filterStatus"] !== undefined) {
            urlObj.query["filter_status"] = params["filterStatus"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersGroupsApi - functional programming interface
 */
export const UsersGroupsApiFp = {
    /**
     * 
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: { uniqueName: string; user: GroupMemberResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.addMemberToGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: { uniqueName: string; users: Array<GroupMemberResource>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<GroupMemberResource>> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.addMembersToGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: { groupResource?: GroupResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.createGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Group Templates define a type of group and the properties they have
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: { groupTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.createGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: { uniqueName: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.deleteGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.deleteGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: { uniqueName: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: { uniqueName: string; userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupMember(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: { uniqueName: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceGroupMemberResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceTemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: { userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.getGroupsForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: { uniqueName: string; userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.removeGroupMember(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: { uniqueName: string; groupResource?: GroupResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: { uniqueName: string; userId: number; status: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroupMemberStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: { id: string; groupTemplateResource?: TemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TemplateResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroupTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: { filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceGroupResource> {
        const fetchArgs = UsersGroupsApiFetchParamCreator.updateGroups(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersGroupsApi - object-oriented interface
 */
export class UsersGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new member to the group
     * @param uniqueName The group unique name
     * @param user The id and status for a user to add to the group
     */
    addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, options: any = {}) {
        return UsersGroupsApiFp.addMemberToGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Adds multiple members to the group
     * @param uniqueName The group unique name
     * @param users The id and status for a list of users to add to the group
     */
    addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, options: any = {}) {
        return UsersGroupsApiFp.addMembersToGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a group
     * @param groupResource The new group
     */
    createGroup(params: {  groupResource?: GroupResource; }, options: any = {}) {
        return UsersGroupsApiFp.createGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * Group Templates define a type of group and the properties they have
     * @summary Create a group template
     * @param groupTemplateResource The group template resource object
     */
    createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersGroupsApiFp.createGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Removes a group from the system IF no resources are attached to it
     * @param uniqueName The group unique name
     */
    deleteGroup(params: {  uniqueName: string; }, options: any = {}) {
        return UsersGroupsApiFp.deleteGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete a group template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteGroupTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return UsersGroupsApiFp.deleteGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Loads a specific group's details
     * @param uniqueName The group unique name
     */
    getGroup(params: {  uniqueName: string; }, options: any = {}) {
        return UsersGroupsApiFp.getGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user
     */
    getGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
        return UsersGroupsApiFp.getGroupMember(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Lists members of the group
     * @param uniqueName The group unique name
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersGroupsApiFp.getGroupMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single group template
     * @param id The id of the template
     */
    getGroupTemplate(params: {  id: string; }, options: any = {}) {
        return UsersGroupsApiFp.getGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search group templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersGroupsApiFp.getGroupTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List groups a user is in
     * @param userId The id of the user
     */
    getGroupsForUser(params: {  userId: number; }, options: any = {}) {
        return UsersGroupsApiFp.getGroupsForUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Removes a user from a group
     * @param uniqueName The group unique name
     * @param userId The id of the user to remove
     */
    removeGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
        return UsersGroupsApiFp.removeGroupMember(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a group
     * @param uniqueName The group unique name
     * @param groupResource The updated group
     */
    updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, options: any = {}) {
        return UsersGroupsApiFp.updateGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Change a user's status
     * @param uniqueName The group unique name
     * @param userId The user id of the member to modify
     * @param status The new status for the user
     */
    updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: string; }, options: any = {}) {
        return UsersGroupsApiFp.updateGroupMemberStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a group template
     * @param id The id of the template
     * @param groupTemplateResource The group template resource object
     */
    updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, options: any = {}) {
        return UsersGroupsApiFp.updateGroupTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search groups
     * @param filterTemplate Filter for groups using a specific template, by id
     * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
     * @param filterName Filter for groups with names starting with the given string
     * @param filterUniqueName Filter for groups whose unique_name starts with provided string
     * @param filterParent Filter for groups with a specific parent, by unique name
     * @param filterStatus Filter for groups with a certain status
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    updateGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersGroupsApiFp.updateGroups(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersGroupsApi - factory interface
 */
export const UsersGroupsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds a new member to the group
         * @param uniqueName The group unique name
         * @param user The id and status for a user to add to the group
         */
        addMemberToGroup(params: {  uniqueName: string; user: GroupMemberResource; }, options: any = {}) {
            return UsersGroupsApiFp.addMemberToGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds multiple members to the group
         * @param uniqueName The group unique name
         * @param users The id and status for a list of users to add to the group
         */
        addMembersToGroup(params: {  uniqueName: string; users: Array<GroupMemberResource>; }, options: any = {}) {
            return UsersGroupsApiFp.addMembersToGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a group
         * @param groupResource The new group
         */
        createGroup(params: {  groupResource?: GroupResource; }, options: any = {}) {
            return UsersGroupsApiFp.createGroup(params, options)(fetch, basePath);
        },
        /**
         * Group Templates define a type of group and the properties they have
         * @summary Create a group template
         * @param groupTemplateResource The group template resource object
         */
        createGroupTemplate(params: {  groupTemplateResource?: TemplateResource; }, options: any = {}) {
            return UsersGroupsApiFp.createGroupTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes a group from the system IF no resources are attached to it
         * @param uniqueName The group unique name
         */
        deleteGroup(params: {  uniqueName: string; }, options: any = {}) {
            return UsersGroupsApiFp.deleteGroup(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete a group template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteGroupTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return UsersGroupsApiFp.deleteGroupTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Loads a specific group's details
         * @param uniqueName The group unique name
         */
        getGroup(params: {  uniqueName: string; }, options: any = {}) {
            return UsersGroupsApiFp.getGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user
         */
        getGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
            return UsersGroupsApiFp.getGroupMember(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Lists members of the group
         * @param uniqueName The group unique name
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupMembers(params: {  uniqueName: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersGroupsApiFp.getGroupMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single group template
         * @param id The id of the template
         */
        getGroupTemplate(params: {  id: string; }, options: any = {}) {
            return UsersGroupsApiFp.getGroupTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search group templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order a comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getGroupTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersGroupsApiFp.getGroupTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List groups a user is in
         * @param userId The id of the user
         */
        getGroupsForUser(params: {  userId: number; }, options: any = {}) {
            return UsersGroupsApiFp.getGroupsForUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes a user from a group
         * @param uniqueName The group unique name
         * @param userId The id of the user to remove
         */
        removeGroupMember(params: {  uniqueName: string; userId: number; }, options: any = {}) {
            return UsersGroupsApiFp.removeGroupMember(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a group
         * @param uniqueName The group unique name
         * @param groupResource The updated group
         */
        updateGroup(params: {  uniqueName: string; groupResource?: GroupResource; }, options: any = {}) {
            return UsersGroupsApiFp.updateGroup(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change a user's status
         * @param uniqueName The group unique name
         * @param userId The user id of the member to modify
         * @param status The new status for the user
         */
        updateGroupMemberStatus(params: {  uniqueName: string; userId: number; status: string; }, options: any = {}) {
            return UsersGroupsApiFp.updateGroupMemberStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a group template
         * @param id The id of the template
         * @param groupTemplateResource The group template resource object
         */
        updateGroupTemplate(params: {  id: string; groupTemplateResource?: TemplateResource; }, options: any = {}) {
            return UsersGroupsApiFp.updateGroupTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search groups
         * @param filterTemplate Filter for groups using a specific template, by id
         * @param filterMemberCount Filters groups by member count. Multiple values possible for range search. Format: filter_member_count&#x3D;OP,ts&amp;... where OP in (GT, LT, GOE, LOE, EQ). Ex: filter_member_count&#x3D;GT,14,LT,17
         * @param filterName Filter for groups with names starting with the given string
         * @param filterUniqueName Filter for groups whose unique_name starts with provided string
         * @param filterParent Filter for groups with a specific parent, by unique name
         * @param filterStatus Filter for groups with a certain status
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        updateGroups(params: {  filterTemplate?: string; filterMemberCount?: string; filterName?: string; filterUniqueName?: string; filterParent?: string; filterStatus?: string; size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersGroupsApiFp.updateGroups(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersInventoryApi - fetch parameter creator
 */
export const UsersInventoryApiFetchParamCreator = {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling addItemToUserInventory");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["userInventoryAddRequest"]) {
            fetchOptions.body = JSON.stringify(params["userInventoryAddRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Useful for pre-check and accounts for all various buisness rules
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling checkUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling checkUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/check`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["sku"] !== undefined) {
            urlObj.query["sku"] = params["sku"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Entitlement templates define a type of entitlement and the properties they have
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  entitlementId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling deleteEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  entitlementId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling getEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  id: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/entitlements/templates`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventories");
        }
        const baseUrl = `/users/{id}/inventory`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["inactive"] !== undefined) {
            urlObj.query["inactive"] = params["inactive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterItemId"] !== undefined) {
            urlObj.query["filter_item_id"] = params["filterItemId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  userId: number; id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventory");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventory");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserInventoryLog");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserInventoryLog");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/log`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/inventories`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["inactive"] !== undefined) {
            urlObj.query["inactive"] = params["inactive"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["filterItemName"] !== undefined) {
            urlObj.query["filter_item_name"] = params["filterItemName"];
        }
        if (params["filterItemId"] !== undefined) {
            urlObj.query["filter_item_id"] = params["filterItemId"];
        }
        if (params["filterUsername"] !== undefined) {
            urlObj.query["filter_username"] = params["filterUsername"];
        }
        if (params["filterGroup"] !== undefined) {
            urlObj.query["filter_group"] = params["filterGroup"];
        }
        if (params["filterDate"] !== undefined) {
            urlObj.query["filter_date"] = params["filterDate"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling grantUserEntitlement");
        }
        // verify required parameter "grantRequest" is set
        if (params["grantRequest"] == null) {
            throw new Error("Missing required parameter grantRequest when calling grantUserEntitlement");
        }
        const baseUrl = `/users/{user_id}/entitlements`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["grantRequest"]) {
            fetchOptions.body = JSON.stringify(params["grantRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}): FetchArgs {
        // verify required parameter "entitlementId" is set
        if (params["entitlementId"] == null) {
            throw new Error("Missing required parameter entitlementId when calling updateEntitlementItem");
        }
        const baseUrl = `/entitlements/{entitlement_id}`
            .replace(`{${"entitlement_id"}}`, `${ params["entitlementId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["cascade"] !== undefined) {
            urlObj.query["cascade"] = params["cascade"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entitlementItem"]) {
            fetchOptions.body = JSON.stringify(params["entitlementItem"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateEntitlementTemplate");
        }
        const baseUrl = `/entitlements/templates/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["template"]) {
            fetchOptions.body = JSON.stringify(params["template"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryBehaviorData");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryBehaviorData");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/behavior-data`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryExpires");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryExpires");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/expires`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["timestamp"]) {
            fetchOptions.body = JSON.stringify(params["timestamp"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling updateUserInventoryStatus");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserInventoryStatus");
        }
        const baseUrl = `/users/{user_id}/inventory/{id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["inventoryStatus"]) {
            fetchOptions.body = JSON.stringify(params["inventoryStatus"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling useUserEntitlementItem");
        }
        // verify required parameter "itemId" is set
        if (params["itemId"] == null) {
            throw new Error("Missing required parameter itemId when calling useUserEntitlementItem");
        }
        const baseUrl = `/users/{user_id}/entitlements/{item_id}/use`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"item_id"}}`, `${ params["itemId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["sku"] !== undefined) {
            urlObj.query["sku"] = params["sku"];
        }
        if (params["info"] !== undefined) {
            urlObj.query["info"] = params["info"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersInventoryApi - functional programming interface
 */
export const UsersInventoryApiFp = {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: { id: number; userInventoryAddRequest?: UserInventoryAddRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.addItemToUserInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Useful for pre-check and accounts for all various buisness rules
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: { userId: string; itemId: number; sku?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.checkUserEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: { cascade?: boolean; entitlementItem?: EntitlementItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.createEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Entitlement templates define a type of entitlement and the properties they have
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: { template?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.createEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: { entitlementId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.deleteEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: { id: string; cascade?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.deleteEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: { entitlementId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<EntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceEntitlementItem> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementItems(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: { id: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getEntitlementTemplates(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: { id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventories(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: { userId: number; id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: { userId: string; id: number; size?: number; page?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserItemLogResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUserInventoryLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: { inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserInventoryResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.getUsersInventory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: { userId: number; grantRequest: EntitlementGrantRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.grantUserEntitlement(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: { entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: { id: string; template?: ItemTemplateResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ItemTemplateResource> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateEntitlementTemplate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: { userId: number; id: number; data?: any;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryBehaviorData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: { userId: number; id: number; timestamp?: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryExpires(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: { userId: number; id: number; inventoryStatus?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.updateUserInventoryStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: { userId: string; itemId: number; sku?: string; info?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersInventoryApiFetchParamCreator.useUserEntitlementItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersInventoryApi - object-oriented interface
 */
export class UsersInventoryApi extends BaseAPI {
    /**
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @summary Adds an item to the user inventory
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, options: any = {}) {
        return UsersInventoryApiFp.addItemToUserInventory(params, options)(this.fetch, this.basePath);
    }
    /**
     * Useful for pre-check and accounts for all various buisness rules
     * @summary Check for access to an item without consuming
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, options: any = {}) {
        return UsersInventoryApiFp.checkUserEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create an entitlement item
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
        return UsersInventoryApiFp.createEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * Entitlement templates define a type of entitlement and the properties they have
     * @summary Create an entitlement template
     * @param template The entitlement template to be created
     */
    createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, options: any = {}) {
        return UsersInventoryApiFp.createEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete an entitlement item
     * @param entitlementId The id of the entitlement
     */
    deleteEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
        return UsersInventoryApiFp.deleteEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an entitlement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
        return UsersInventoryApiFp.deleteEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single entitlement item
     * @param entitlementId The id of the entitlement
     */
    getEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
        return UsersInventoryApiFp.getEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search entitlement items
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementItems(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersInventoryApiFp.getEntitlementItems(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a single entitlement template
     * @param id The id of the template
     */
    getEntitlementTemplate(params: {  id: string; }, options: any = {}) {
        return UsersInventoryApiFp.getEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List and search entitlement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersInventoryApiFp.getEntitlementTemplates(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the user inventory entries for a given user
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
        return UsersInventoryApiFp.getUserInventories(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get an inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    getUserInventory(params: {  userId: number; id: number; }, options: any = {}) {
        return UsersInventoryApiFp.getUserInventory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the log entries for this inventory entry
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, options: any = {}) {
        return UsersInventoryApiFp.getUserInventoryLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary List the user inventory entries for all users
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
        return UsersInventoryApiFp.getUsersInventory(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Grant an entitlement
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, options: any = {}) {
        return UsersInventoryApiFp.grantUserEntitlement(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an entitlement item
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
        return UsersInventoryApiFp.updateEntitlementItem(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an entitlement template
     * @param id The id of the template
     * @param template The updated template
     */
    updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, options: any = {}) {
        return UsersInventoryApiFp.updateEntitlementTemplate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set the behavior data for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, options: any = {}) {
        return UsersInventoryApiFp.updateUserInventoryBehaviorData(params, options)(this.fetch, this.basePath);
    }
    /**
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @summary Set the expiration date
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, options: any = {}) {
        return UsersInventoryApiFp.updateUserInventoryExpires(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set the status for an inventory entry
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: string; }, options: any = {}) {
        return UsersInventoryApiFp.updateUserInventoryStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Use an item
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, options: any = {}) {
        return UsersInventoryApiFp.useUserEntitlementItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersInventoryApi - factory interface
 */
export const UsersInventoryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
         * @summary Adds an item to the user inventory
         * @param id The id of the user
         * @param userInventoryAddRequest The user inventory add request object
         */
        addItemToUserInventory(params: {  id: number; userInventoryAddRequest?: UserInventoryAddRequest; }, options: any = {}) {
            return UsersInventoryApiFp.addItemToUserInventory(params, options)(fetch, basePath);
        },
        /**
         * Useful for pre-check and accounts for all various buisness rules
         * @summary Check for access to an item without consuming
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         */
        checkUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; }, options: any = {}) {
            return UsersInventoryApiFp.checkUserEntitlementItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an entitlement item
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param entitlementItem The entitlement item object
         */
        createEntitlementItem(params: {  cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
            return UsersInventoryApiFp.createEntitlementItem(params, options)(fetch, basePath);
        },
        /**
         * Entitlement templates define a type of entitlement and the properties they have
         * @summary Create an entitlement template
         * @param template The entitlement template to be created
         */
        createEntitlementTemplate(params: {  template?: ItemTemplateResource; }, options: any = {}) {
            return UsersInventoryApiFp.createEntitlementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an entitlement item
         * @param entitlementId The id of the entitlement
         */
        deleteEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
            return UsersInventoryApiFp.deleteEntitlementItem(params, options)(fetch, basePath);
        },
        /**
         * If cascade = 'detach', it will force delete the template even if it's attached to other objects
         * @summary Delete an entitlement template
         * @param id The id of the template
         * @param cascade The value needed to delete used templates
         */
        deleteEntitlementTemplate(params: {  id: string; cascade?: string; }, options: any = {}) {
            return UsersInventoryApiFp.deleteEntitlementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single entitlement item
         * @param entitlementId The id of the entitlement
         */
        getEntitlementItem(params: {  entitlementId: number; }, options: any = {}) {
            return UsersInventoryApiFp.getEntitlementItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search entitlement items
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementItems(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersInventoryApiFp.getEntitlementItems(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a single entitlement template
         * @param id The id of the template
         */
        getEntitlementTemplate(params: {  id: string; }, options: any = {}) {
            return UsersInventoryApiFp.getEntitlementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List and search entitlement templates
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getEntitlementTemplates(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersInventoryApiFp.getEntitlementTemplates(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the user inventory entries for a given user
         * @param id The id of the user
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterItemId Filter by item id
         * @param filterUsername Filter by entries owned by the user with the specified username
         * @param filterGroup Filter by entries owned by the users in a given group, by unique name
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         */
        getUserInventories(params: {  id: number; inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
            return UsersInventoryApiFp.getUserInventories(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         */
        getUserInventory(params: {  userId: number; id: number; }, options: any = {}) {
            return UsersInventoryApiFp.getUserInventory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the log entries for this inventory entry
         * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
         * @param id The id of the user inventory
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         */
        getUserInventoryLog(params: {  userId: string; id: number; size?: number; page?: number; }, options: any = {}) {
            return UsersInventoryApiFp.getUserInventoryLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary List the user inventory entries for all users
         * @param inactive If true, accepts inactive user inventories
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param filterItemName Filter by items whose name starts with a string
         * @param filterItemId Filter by item id
         * @param filterUsername Filter by entries owned by the user with the specified username
         * @param filterGroup Filter by entries owned by the users in a given group, by unique name
         * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
         */
        getUsersInventory(params: {  inactive?: boolean; size?: number; page?: number; filterItemName?: string; filterItemId?: number; filterUsername?: string; filterGroup?: string; filterDate?: string; }, options: any = {}) {
            return UsersInventoryApiFp.getUsersInventory(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant an entitlement
         * @param userId The id of the user to grant the entitlement to
         * @param grantRequest grantRequest
         */
        grantUserEntitlement(params: {  userId: number; grantRequest: EntitlementGrantRequest; }, options: any = {}) {
            return UsersInventoryApiFp.grantUserEntitlement(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an entitlement item
         * @param entitlementId The id of the entitlement
         * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
         * @param entitlementItem The entitlement item object
         */
        updateEntitlementItem(params: {  entitlementId: number; cascade?: boolean; entitlementItem?: EntitlementItem; }, options: any = {}) {
            return UsersInventoryApiFp.updateEntitlementItem(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an entitlement template
         * @param id The id of the template
         * @param template The updated template
         */
        updateEntitlementTemplate(params: {  id: string; template?: ItemTemplateResource; }, options: any = {}) {
            return UsersInventoryApiFp.updateEntitlementTemplate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the behavior data for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param data The data map
         */
        updateUserInventoryBehaviorData(params: {  userId: number; id: number; data?: any; }, options: any = {}) {
            return UsersInventoryApiFp.updateUserInventoryBehaviorData(params, options)(fetch, basePath);
        },
        /**
         * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
         * @summary Set the expiration date
         * @param userId user_id
         * @param id The id of the user inventory
         * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
         */
        updateUserInventoryExpires(params: {  userId: number; id: number; timestamp?: number; }, options: any = {}) {
            return UsersInventoryApiFp.updateUserInventoryExpires(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the status for an inventory entry
         * @param userId The id of the user
         * @param id The id of the user inventory
         * @param inventoryStatus The inventory status object
         */
        updateUserInventoryStatus(params: {  userId: number; id: number; inventoryStatus?: string; }, options: any = {}) {
            return UsersInventoryApiFp.updateUserInventoryStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Use an item
         * @param userId The id of the user to check for or &#39;me&#39; for logged in user
         * @param itemId The id of the item
         * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
         * @param info Any additional info to add to the log about this use
         */
        useUserEntitlementItem(params: {  userId: string; itemId: number; sku?: string; info?: string; }, options: any = {}) {
            return UsersInventoryApiFp.useUserEntitlementItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersRelationshipsApi - fetch parameter creator
 */
export const UsersRelationshipsApiFetchParamCreator = {
    /**
     * 
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  relationship?: UserRelationshipResource; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling deleteUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  id: number; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling getUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: {  size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/users/relationships`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, options: any = {}): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling updateUserRelationship");
        }
        const baseUrl = `/users/relationships/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["relationship"]) {
            fetchOptions.body = JSON.stringify(params["relationship"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersRelationshipsApi - functional programming interface
 */
export const UsersRelationshipsApiFp = {
    /**
     * 
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: { relationship?: UserRelationshipResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.createUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.deleteUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: { id: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.getUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: { size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceUserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.getUserRelationships(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: { id: number; relationship?: UserRelationshipResource;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserRelationshipResource> {
        const fetchArgs = UsersRelationshipsApiFetchParamCreator.updateUserRelationship(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersRelationshipsApi - object-oriented interface
 */
export class UsersRelationshipsApi extends BaseAPI {
    /**
     * 
     * @summary Create a user relationship
     * @param relationship The new relationship
     */
    createUserRelationship(params: {  relationship?: UserRelationshipResource; }, options: any = {}) {
        return UsersRelationshipsApiFp.createUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a user relationship
     * @param id The id of the relationship
     */
    deleteUserRelationship(params: {  id: number; }, options: any = {}) {
        return UsersRelationshipsApiFp.deleteUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a user relationship
     * @param id The id of the relationship
     */
    getUserRelationship(params: {  id: number; }, options: any = {}) {
        return UsersRelationshipsApiFp.getUserRelationship(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get a list of user relationships
     * @param size The number of objects returned per page
     * @param page The number of the page returned
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserRelationships(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
        return UsersRelationshipsApiFp.getUserRelationships(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a user relationship
     * @param id The id of the relationship
     * @param relationship The new relationship
     */
    updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, options: any = {}) {
        return UsersRelationshipsApiFp.updateUserRelationship(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersRelationshipsApi - factory interface
 */
export const UsersRelationshipsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a user relationship
         * @param relationship The new relationship
         */
        createUserRelationship(params: {  relationship?: UserRelationshipResource; }, options: any = {}) {
            return UsersRelationshipsApiFp.createUserRelationship(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a user relationship
         * @param id The id of the relationship
         */
        deleteUserRelationship(params: {  id: number; }, options: any = {}) {
            return UsersRelationshipsApiFp.deleteUserRelationship(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a user relationship
         * @param id The id of the relationship
         */
        getUserRelationship(params: {  id: number; }, options: any = {}) {
            return UsersRelationshipsApiFp.getUserRelationship(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a list of user relationships
         * @param size The number of objects returned per page
         * @param page The number of the page returned
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserRelationships(params: {  size?: number; page?: number; order?: string; }, options: any = {}) {
            return UsersRelationshipsApiFp.getUserRelationships(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a user relationship
         * @param id The id of the relationship
         * @param relationship The new relationship
         */
        updateUserRelationship(params: {  id: number; relationship?: UserRelationshipResource; }, options: any = {}) {
            return UsersRelationshipsApiFp.updateUserRelationship(params, options)(fetch, basePath);
        },
    };
};


/**
 * UsersSubscriptionsApi - fetch parameter creator
 */
export const UsersSubscriptionsApiFetchParamCreator = {
    /**
     * 
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUserSubscriptionDetails");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling getUserSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  userId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling getUsersSubscriptionDetails");
        }
        const baseUrl = `/users/{user_id}/subscriptions`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling reactivateUserSubscription");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling reactivateUserSubscription");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/reactivate`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["reactivateSubscriptionRequest"]) {
            fetchOptions.body = JSON.stringify(params["reactivateSubscriptionRequest"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionBillDate");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionBillDate");
        }
        // verify required parameter "billDate" is set
        if (params["billDate"] == null) {
            throw new Error("Missing required parameter billDate when calling setSubscriptionBillDate");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/bill-date`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["billDate"]) {
            fetchOptions.body = JSON.stringify(params["billDate"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * May send null to use floating default
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionPaymentMethod");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionPaymentMethod");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/payment-method`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["paymentMethodId"]) {
            fetchOptions.body = JSON.stringify(params["paymentMethodId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setSubscriptionStatus");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setSubscriptionStatus");
        }
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling setSubscriptionStatus");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/status`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["status"]) {
            fetchOptions.body = JSON.stringify(params["status"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserSubscriptionPlan");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setUserSubscriptionPlan");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/plan`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["planId"]) {
            fetchOptions.body = JSON.stringify(params["planId"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, options: any = {}): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling setUserSubscriptionPrice");
        }
        // verify required parameter "inventoryId" is set
        if (params["inventoryId"] == null) {
            throw new Error("Missing required parameter inventoryId when calling setUserSubscriptionPrice");
        }
        const baseUrl = `/users/{user_id}/subscriptions/{inventory_id}/price-override`
            .replace(`{${"user_id"}}`, `${ params["userId"] }`)
            .replace(`{${"inventory_id"}}`, `${ params["inventoryId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["the override details"]) {
            fetchOptions.body = JSON.stringify(params["the override details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UsersSubscriptionsApi - functional programming interface
 */
export const UsersSubscriptionsApiFp = {
    /**
     * 
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: { userId: number; inventoryId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InventorySubscriptionResource> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.getUserSubscriptionDetails(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: { userId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<InventorySubscriptionResource>> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.getUsersSubscriptionDetails(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: { userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<InvoiceResource> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.reactivateUserSubscription(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: { userId: number; inventoryId: number; billDate: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionBillDate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * May send null to use floating default
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: { userId: number; inventoryId: number; paymentMethodId?: IntWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionPaymentMethod(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: { userId: number; inventoryId: number; status: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setSubscriptionStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: { userId: number; inventoryId: number; planId?: StringWrapper;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setUserSubscriptionPlan(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: { userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UsersSubscriptionsApiFetchParamCreator.setUserSubscriptionPrice(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UsersSubscriptionsApi - object-oriented interface
 */
export class UsersSubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get details about a user's subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     */
    getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, options: any = {}) {
        return UsersSubscriptionsApiFp.getUserSubscriptionDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get details about a user's subscriptions
     * @param userId The id of the user
     */
    getUsersSubscriptionDetails(params: {  userId: number; }, options: any = {}) {
        return UsersSubscriptionsApiFp.getUsersSubscriptionDetails(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reactivate a subscription and charge fee
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
     */
    reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, options: any = {}) {
        return UsersSubscriptionsApiFp.reactivateUserSubscription(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set a new date to bill a subscription on
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param billDate The new bill date. Unix timestamp in seconds
     */
    setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, options: any = {}) {
        return UsersSubscriptionsApiFp.setSubscriptionBillDate(params, options)(this.fetch, this.basePath);
    }
    /**
     * May send null to use floating default
     * @summary Set the payment method to use for a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param paymentMethodId The id of the payment method
     */
    setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, options: any = {}) {
        return UsersSubscriptionsApiFp.setSubscriptionPaymentMethod(params, options)(this.fetch, this.basePath);
    }
    /**
     * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
     * @summary Set the status of a subscription
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
     */
    setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: StringWrapper; }, options: any = {}) {
        return UsersSubscriptionsApiFp.setSubscriptionStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set a new subscription plan for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param planId The id of the new plan. Must be from the same subscription
     */
    setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, options: any = {}) {
        return UsersSubscriptionsApiFp.setUserSubscriptionPlan(params, options)(this.fetch, this.basePath);
    }
    /**
     * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
     * @summary Set a new subscription price for a user
     * @param userId The id of the user
     * @param inventoryId The id of the user&#39;s inventory
     * @param the override details override
     */
    setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, options: any = {}) {
        return UsersSubscriptionsApiFp.setUserSubscriptionPrice(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UsersSubscriptionsApi - factory interface
 */
export const UsersSubscriptionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get details about a user's subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         */
        getUserSubscriptionDetails(params: {  userId: number; inventoryId: number; }, options: any = {}) {
            return UsersSubscriptionsApiFp.getUserSubscriptionDetails(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get details about a user's subscriptions
         * @param userId The id of the user
         */
        getUsersSubscriptionDetails(params: {  userId: number; }, options: any = {}) {
            return UsersSubscriptionsApiFp.getUsersSubscriptionDetails(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reactivate a subscription and charge fee
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param reactivateSubscriptionRequest The reactivate subscription request object inventory
         */
        reactivateUserSubscription(params: {  userId: number; inventoryId: number; reactivateSubscriptionRequest?: ReactivateSubscriptionRequest; }, options: any = {}) {
            return UsersSubscriptionsApiFp.reactivateUserSubscription(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a new date to bill a subscription on
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param billDate The new bill date. Unix timestamp in seconds
         */
        setSubscriptionBillDate(params: {  userId: number; inventoryId: number; billDate: number; }, options: any = {}) {
            return UsersSubscriptionsApiFp.setSubscriptionBillDate(params, options)(fetch, basePath);
        },
        /**
         * May send null to use floating default
         * @summary Set the payment method to use for a subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param paymentMethodId The id of the payment method
         */
        setSubscriptionPaymentMethod(params: {  userId: number; inventoryId: number; paymentMethodId?: IntWrapper; }, options: any = {}) {
            return UsersSubscriptionsApiFp.setSubscriptionPaymentMethod(params, options)(fetch, basePath);
        },
        /**
         * Note that the new status may be blocked if the system is not configured to allow the current status to be changed to the new, to enforce proper flow. The default options for statuses are shown below but may be altered for special use cases
         * @summary Set the status of a subscription
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param status The new status for the subscription. Actual options may differ from the indicated set if the invoice status type data has been altered.  Allowable values: (&#39;current&#39;, &#39;canceled&#39;, &#39;stopped&#39;, &#39;payment_failed&#39;, &#39;suspended&#39;)
         */
        setSubscriptionStatus(params: {  userId: number; inventoryId: number; status: StringWrapper; }, options: any = {}) {
            return UsersSubscriptionsApiFp.setSubscriptionStatus(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a new subscription plan for a user
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param planId The id of the new plan. Must be from the same subscription
         */
        setUserSubscriptionPlan(params: {  userId: number; inventoryId: number; planId?: StringWrapper; }, options: any = {}) {
            return UsersSubscriptionsApiFp.setUserSubscriptionPlan(params, options)(fetch, basePath);
        },
        /**
         * This new price will be what the user is charged at the begining of each new period. This override is specific to the current subscription and will not carry over if they end and later re-subscribe. It will persist if the plan is changed using the setUserSubscriptionPlan endpoint.
         * @summary Set a new subscription price for a user
         * @param userId The id of the user
         * @param inventoryId The id of the user&#39;s inventory
         * @param the override details override
         */
        setUserSubscriptionPrice(params: {  userId: number; inventoryId: number; the override details?: SubscriptionPriceOverrideRequest; }, options: any = {}) {
            return UsersSubscriptionsApiFp.setUserSubscriptionPrice(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilBatchApi - fetch parameter creator
 */
export const UtilBatchApiFetchParamCreator = {
    /**
     * Tokens expire in 24 hours
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: {  token: string; }, options: any = {}): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling getBatch");
        }
        const baseUrl = `/batch/{token}`
            .replace(`{${"token"}}`, `${ params["token"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  batch?: Batch; }, options: any = {}): FetchArgs {
        const baseUrl = `/batch`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["batch"]) {
            fetchOptions.body = JSON.stringify(params["batch"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilBatchApi - functional programming interface
 */
export const UtilBatchApiFp = {
    /**
     * Tokens expire in 24 hours
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: { token: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BatchReturn>> {
        const fetchArgs = UtilBatchApiFetchParamCreator.getBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: { batch?: Batch;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<BatchReturn>> {
        const fetchArgs = UtilBatchApiFetchParamCreator.sendBatch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilBatchApi - object-oriented interface
 */
export class UtilBatchApi extends BaseAPI {
    /**
     * Tokens expire in 24 hours
     * @summary Get batch result with token
     * @param token token
     */
    getBatch(params: {  token: string; }, options: any = {}) {
        return UtilBatchApiFp.getBatch(params, options)(this.fetch, this.basePath);
    }
    /**
     * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service
     * @summary Request to run API call given the method, content type, path url, and body of request
     * @param batch The batch object
     */
    sendBatch(params: {  batch?: Batch; }, options: any = {}) {
        return UtilBatchApiFp.sendBatch(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UtilBatchApi - factory interface
 */
export const UtilBatchApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Tokens expire in 24 hours
         * @summary Get batch result with token
         * @param token token
         */
        getBatch(params: {  token: string; }, options: any = {}) {
            return UtilBatchApiFp.getBatch(params, options)(fetch, basePath);
        },
        /**
         * Should the request take longer than one of the alloted timeout parameters, a token will be returned instead, which can be used on the token endpoint in this service
         * @summary Request to run API call given the method, content type, path url, and body of request
         * @param batch The batch object
         */
        sendBatch(params: {  batch?: Batch; }, options: any = {}) {
            return UtilBatchApiFp.sendBatch(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilHealthApi - fetch parameter creator
 */
export const UtilHealthApiFetchParamCreator = {
    /**
     * 
     * @summary Get health info
     */
    getHealth(options: any = {}): FetchArgs {
        const baseUrl = `/health`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilHealthApi - functional programming interface
 */
export const UtilHealthApiFp = {
    /**
     * 
     * @summary Get health info
     */
    getHealth(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilHealthApiFetchParamCreator.getHealth(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilHealthApi - object-oriented interface
 */
export class UtilHealthApi extends BaseAPI {
    /**
     * 
     * @summary Get health info
     */
    getHealth(options: any = {}) {
        return UtilHealthApiFp.getHealth(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilHealthApi - factory interface
 */
export const UtilHealthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get health info
         */
        getHealth(options: any = {}) {
            return UtilHealthApiFp.getHealth(options)(fetch, basePath);
        },
    };
};


/**
 * UtilMaintenanceApi - fetch parameter creator
 */
export const UtilMaintenanceApiFetchParamCreator = {
    /**
     * 
     * @summary Delete maintenance info
     */
    deleteMaintenance(options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get current maintenance info. 404 if no maintenance.
     * @summary Get current maintenance info
     */
    getMaintenance(options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}): FetchArgs {
        const baseUrl = `/maintenance`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["maintenance"]) {
            fetchOptions.body = JSON.stringify(params["maintenance"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilMaintenanceApi - functional programming interface
 */
export const UtilMaintenanceApiFp = {
    /**
     * 
     * @summary Delete maintenance info
     */
    deleteMaintenance(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.deleteMaintenance(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get current maintenance info. 404 if no maintenance.
     * @summary Get current maintenance info
     */
    getMaintenance(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Maintenance> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.getMaintenance(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: { maintenance?: Maintenance;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.setMaintenance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: { maintenance?: Maintenance;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UtilMaintenanceApiFetchParamCreator.updateMaintenance(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilMaintenanceApi - object-oriented interface
 */
export class UtilMaintenanceApi extends BaseAPI {
    /**
     * 
     * @summary Delete maintenance info
     */
    deleteMaintenance(options: any = {}) {
        return UtilMaintenanceApiFp.deleteMaintenance(options)(this.fetch, this.basePath);
    }
    /**
     * Get current maintenance info. 404 if no maintenance.
     * @summary Get current maintenance info
     */
    getMaintenance(options: any = {}) {
        return UtilMaintenanceApiFp.getMaintenance(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Set current maintenance info
     * @param maintenance The maintenance object
     */
    setMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
        return UtilMaintenanceApiFp.setMaintenance(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update current maintenance info
     * @param maintenance The maintenance object
     */
    updateMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
        return UtilMaintenanceApiFp.updateMaintenance(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UtilMaintenanceApi - factory interface
 */
export const UtilMaintenanceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete maintenance info
         */
        deleteMaintenance(options: any = {}) {
            return UtilMaintenanceApiFp.deleteMaintenance(options)(fetch, basePath);
        },
        /**
         * Get current maintenance info. 404 if no maintenance.
         * @summary Get current maintenance info
         */
        getMaintenance(options: any = {}) {
            return UtilMaintenanceApiFp.getMaintenance(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set current maintenance info
         * @param maintenance The maintenance object
         */
        setMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
            return UtilMaintenanceApiFp.setMaintenance(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update current maintenance info
         * @param maintenance The maintenance object
         */
        updateMaintenance(params: {  maintenance?: Maintenance; }, options: any = {}) {
            return UtilMaintenanceApiFp.updateMaintenance(params, options)(fetch, basePath);
        },
    };
};


/**
 * UtilSecurityApi - fetch parameter creator
 */
export const UtilSecurityApiFetchParamCreator = {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, options: any = {}): FetchArgs {
        const baseUrl = `/security/country-log`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["userId"] !== undefined) {
            urlObj.query["user_id"] = params["userId"];
        }
        if (params["size"] !== undefined) {
            urlObj.query["size"] = params["size"];
        }
        if (params["page"] !== undefined) {
            urlObj.query["page"] = params["page"];
        }
        if (params["order"] !== undefined) {
            urlObj.query["order"] = params["order"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(options: any = {}): FetchArgs {
        const baseUrl = `/me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilSecurityApi - functional programming interface
 */
export const UtilSecurityApiFp = {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: { userId?: number; size?: number; page?: number; order?: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PageResourceLocationLogResource> {
        const fetchArgs = UtilSecurityApiFetchParamCreator.getUserLocationLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<TokenDetailsResource> {
        const fetchArgs = UtilSecurityApiFetchParamCreator.getUserTokenDetails(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilSecurityApi - object-oriented interface
 */
export class UtilSecurityApi extends BaseAPI {
    /**
     * A log entry is recorded everytime a user requests a new token. Standard pagination available
     * @summary Returns the authentication log for a user
     * @param userId The user id
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
        return UtilSecurityApiFp.getUserLocationLog(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
     */
    getUserTokenDetails(options: any = {}) {
        return UtilSecurityApiFp.getUserTokenDetails(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilSecurityApi - factory interface
 */
export const UtilSecurityApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A log entry is recorded everytime a user requests a new token. Standard pagination available
         * @summary Returns the authentication log for a user
         * @param userId The user id
         * @param size The number of objects returned per page
         * @param page The number of the page returned, starting with 1
         * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
         */
        getUserLocationLog(params: {  userId?: number; size?: number; page?: number; order?: string; }, options: any = {}) {
            return UtilSecurityApiFp.getUserLocationLog(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the authentication token details. Use /users endpoint for detailed user's info
         */
        getUserTokenDetails(options: any = {}) {
            return UtilSecurityApiFp.getUserTokenDetails(options)(fetch, basePath);
        },
    };
};


/**
 * UtilVersionApi - fetch parameter creator
 */
export const UtilVersionApiFetchParamCreator = {
    /**
     * 
     * @summary Get current version info
     */
    getVersion(options: any = {}): FetchArgs {
        const baseUrl = `/version`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UtilVersionApi - functional programming interface
 */
export const UtilVersionApiFp = {
    /**
     * 
     * @summary Get current version info
     */
    getVersion(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Version> {
        const fetchArgs = UtilVersionApiFetchParamCreator.getVersion(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UtilVersionApi - object-oriented interface
 */
export class UtilVersionApi extends BaseAPI {
    /**
     * 
     * @summary Get current version info
     */
    getVersion(options: any = {}) {
        return UtilVersionApiFp.getVersion(options)(this.fetch, this.basePath);
    }
};

/**
 * UtilVersionApi - factory interface
 */
export const UtilVersionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get current version info
         */
        getVersion(options: any = {}) {
            return UtilVersionApiFp.getVersion(options)(fetch, basePath);
        },
    };
};

